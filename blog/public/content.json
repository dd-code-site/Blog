{"meta":{"title":"Coding花园","subtitle":"柳旦旦的blog","description":"","author":"Dawson Liu","url":"https://dd-code.site","root":"/"},"pages":[{"title":"About","date":"2021-05-18T01:40:54.042Z","updated":"2021-04-20T04:53:43.658Z","comments":true,"path":"about/index.html","permalink":"https://dd-code.site/about/index.html","excerpt":"","text":"我就是我，最美的烟火"},{"title":"Categories","date":"2021-04-20T04:56:34.695Z","updated":"2021-04-20T04:55:01.949Z","comments":true,"path":"categories/index.html","permalink":"https://dd-code.site/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-05-18T01:41:20.618Z","updated":"2021-04-20T04:53:56.600Z","comments":true,"path":"tags/index.html","permalink":"https://dd-code.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《网络经济与企业管理》第一次课","slug":"自考提升/网络经济与企业管理/第一次课","date":"2021-08-10T15:56:52.307Z","updated":"2021-08-10T15:56:52.309Z","comments":true,"path":"post/701979186.html","link":"","permalink":"https://dd-code.site/post/701979186.html","excerpt":"","text":"","categories":[{"name":"自考提升","slug":"自考提升","permalink":"https://dd-code.site/categories/%E8%87%AA%E8%80%83%E6%8F%90%E5%8D%87/"},{"name":"网络经济与企业管理","slug":"自考提升/网络经济与企业管理","permalink":"https://dd-code.site/categories/%E8%87%AA%E8%80%83%E6%8F%90%E5%8D%87/%E7%BD%91%E7%BB%9C%E7%BB%8F%E6%B5%8E%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%AE%A1%E7%90%86/"}],"tags":[]},{"title":"linux系统scp文件传输","slug":"技术学习/Service/linux系统scp文件传输","date":"2021-07-26T03:23:17.319Z","updated":"2021-08-10T15:51:26.872Z","comments":true,"path":"post/82110573.html","link":"","permalink":"https://dd-code.site/post/82110573.html","excerpt":"","text":"命令格式1scp [参数] [原路径] [目标路径] 命令参数 -1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 保留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号。 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 使用实例从本地服务器复制到远程服务器：(1) 复制文件： 1scp local_file remote_username@remote_ip:remote_folder 1scp local_file remote_username@remote_ip:remote_file 1scp local_file remote_ip:remote_folder 1scp local_file remote_ip:remote_file 第1,2个已指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名。 第3,4个没有指定用户名，命令执行后需要输入用户名和用户密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名。 (2) 复制目录： 1scp -r local_folder remote_username@remote_ip:remote_folder 1scp -r local_folder remote_ip:remote_folder 二、从远程服务器复制到本地服务器： (1) 从远处复制文件到本地目录: 1scp root@192.168.1.68:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/ 从192.168.1.68机器上的/opt/soft/的目录中下载nginx-0.5.38.tar.gz 文件到本地/opt/soft/目录中 (2) 从远处复制目录到本地目录 1scp -r root@192.168.1.68:/opt/soft/mongodb /opt/soft/ 从192.168.1.68机器上的/opt/soft/的目录中下载mongodb 目录到本地的/opt/soft/目录来。","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Service","slug":"技术学习/Service","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Service/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://dd-code.site/tags/Linux/"},{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/tags/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"Ubuntu防火墙的使用和开放关闭端口","slug":"技术学习/Service/ubuntu防火墙的使用和开放关闭端口","date":"2021-07-26T03:23:17.319Z","updated":"2021-08-10T15:51:26.871Z","comments":true,"path":"post/1879866913.html","link":"","permalink":"https://dd-code.site/post/1879866913.html","excerpt":"","text":"查看防火墙状态（Ubuntu系统默认是安装了ufw防火墙） 1sudo ufw status inactive表示防火墙没有开启，并不是没有安装防火墙。 安装防火墙： 1sudo apt-get install ufw 开启防火墙 1sudo ufw enable 开放22端口： 1sudo ufw allow 22 开启完成，需要重启防火墙生效： 1sudo ufw reload 查看22端口的监听状态： 1sudo netstat -tunlp | grep 22 防火墙关闭普通端口 1sudo ufw delete allow 21 防火墙开放规定协议的端口 1sudo ufw allow 8001/tcp 防火墙关闭指定协议端口 1sudo ufw delete allow 8001/tcp 防火墙开放限定ip地址端口开放指定ip所有操作 1sudo ufw allow from 192.168.1.11 关闭指定ip所有操作 1sudo ufw delete allow from 192.168.1.11 开放指定ip对应端口操作 1sudo ufw allow from 192.168.1.12 to any port 3306 关闭指定ip对应端口操作 1sudo ufw delete allow from 192.168.1.12 to any port 3306 关闭防火墙 1sudo ufw disable 参考资料 https://blog.csdn.net/willingtolove/article/details/109863064","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Service","slug":"技术学习/Service","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Service/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://dd-code.site/tags/Ubuntu/"},{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/tags/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"缓存Memcache和Redis的区别","slug":"技术学习/Redis/缓存Memcache和Redis的区别","date":"2021-07-26T03:23:17.318Z","updated":"2021-08-10T15:51:11.450Z","comments":true,"path":"post/894376550.html","link":"","permalink":"https://dd-code.site/post/894376550.html","excerpt":"","text":"Redis 和 Memcache 都是将数据存放在内存中，都是内存数据库。不过 memcache 还可用于缓存其他东西，例如图片、视频等等 Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，hash 等数据结构的存储 虚拟内存：Redis 当物理内存用完时，可以将一些很久没用到的 value 交换到磁盘 过期策略：memcache 在 set 时就指定，例如 set key1 0 0 8，即永不过期。Redis 可以通过例如 expire 设定，例如 expire name 10 分布式：设定 memcache 集群，利用 magent 做一主多从；redis 可以做一主多从。都可以一主一从 存储数据安全：memcache 挂掉后，数据没了；redis 可以定期保存到磁盘（持久化） 灾难恢复：memcache 挂掉后，数据不可恢复; redis 数据丢失后可以通过 aof 恢复 Redis支持数据的备份，即 master-slave 模式的数据备份","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Redis","slug":"技术学习/Redis","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Redis/"}],"tags":[]},{"title":"安装SSDB","slug":"技术学习/Redis/安装SSDB","date":"2021-07-26T03:23:17.317Z","updated":"2021-08-10T15:51:02.362Z","comments":true,"path":"post/1058490118.html","link":"","permalink":"https://dd-code.site/post/1058490118.html","excerpt":"","text":"什么是SSDB一个高性能的支持丰富数据结构的 NoSQL 数据库, 用于替代 Redis. 特性 替代 Redis 数据库, Redis 的 100 倍容量 LevelDB 网络支持, 使用 C/C++ 开发 Redis API 兼容, 支持 Redis 客户端 适合存储集合数据, 如 list, hash, zset… 客户端 API 支持的语言包括: C++, PHP, Python, Java, Go 持久化的队列服务 主从复制, 负载均衡 强烈推荐你把 SSDB 部署在 Linux 操作系统上. 不要在生产环境中使用 Windows 操作系统来运行 SSDB 服务器. 如果你确实必须使用 Windows 操作系统, 请在上面运行一个 Linux 虚拟机, 然后再让 SSDB 运行于这个虚拟机之中. 编译和安装123456wget --no-check-certificate https://github.com/ideawu/ssdb/archive/master.zipunzip mastercd ssdb-mastermake# 将安装在 /usr/local/ssdb 目录下sudo make install 如果你想安装 ssdb 在其它的目录, 不在 /usr/local 目录下, 可以这样 1sudo make install PREFIX=/your/direcotry 问题解决如果出现如下错误: 12g++ ...deps/snappy-1.1.0/.libs/libsnappy.a: No such file or directorymake[1]: *** [all] Error 1 或者 12g++ ...deps/jemalloc-3.3.1/lib/libjemalloc.a: No such file or directorymake[1]: *** [all] Error 1 这是因为 Snappy 或者 Jemalloc 没有编译成功, 这一般是因为你的系统时钟有问题. 可以这样解决: 1234cd deps/snappy-1.1.0autoreconf --force --install./configuremake 或者 1234cd deps/jemalloc-3.3.1autoreconf --force --install./configuremake 启动和停止12345678910111213# 启动主库, 此命令会阻塞住命令行./ssdb-server ssdb.conf# 或者启动为后台进程(不阻塞命令行)./ssdb-server -d ssdb.conf# 停止 ssdb-server./ssdb-server ssdb.conf -s stop# 对于旧版本kill `cat ./var/ssdb.pid`# 重启./ssdb-server ssdb.conf -s restart 到目前为止, 你需要手动管理 ssdb-server 进程, 如果你希望在操作系统启动和停止时自动地管理, 请按下面的说明进行. SSDB 启动脚本(随操作系统自启动)假设你已经安装 SSDB 在默认的 /usr/local/ssdb 目录, 把 tools/ssdb.sh 脚本放到 /etc/init.d 目录下. 注意: 对于 CentOS 用户, 请将 ssdb.sh 重命名为 ssdb. 编辑下面的内容: 12# each config file for one instanceconfigs=/data/ssdb_data/test/ssdb.conf 将 /data/ssdb_data/test/ssdb.conf 修改为你的 SSDB 配置文件的路径. 如果你有多个 SSDB 实例, 那么把它们写在一行, 用空格来分隔, 例如: 12# each config file for one instanceconfigs=/data/ssdb_data/test/ssdb.conf /data/ssdb_data/demo/ssdb.conf CentOS 12sudo chkconfig --add ssdbsudo chkconfig ssdb on Ubuntu 12sudo chmod a+x /etc/init.d/ssdb.shsudo update-rc.d ssdb.sh defaults 资料: 中文官网 从 Redis 迁移到 SSDB","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Redis","slug":"技术学习/Redis","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Redis/"}],"tags":[{"name":"SSDB","slug":"SSDB","permalink":"https://dd-code.site/tags/SSDB/"}]},{"title":"了解Redis","slug":"技术学习/Redis/了解Redis","date":"2021-07-26T03:23:17.317Z","updated":"2021-08-10T15:51:11.451Z","comments":true,"path":"post/1099414406.html","link":"","permalink":"https://dd-code.site/post/1099414406.html","excerpt":"","text":"Redis 是一个开源的内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。它支持多种类型的数据结构，如： 字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）。 Redis 内置了复制、LUA 脚本、LRU 驱动事件、事务和不同级别的磁盘持久化，并通过 Redis哨兵 和 自动分区 提供高可用性。 Redis 数据类型介绍Redis 并不是简单的 key-value 存储，实际上是一个数据结构服务器，支持不同类型的值。也就是说，你不必仅仅把字符串当做键所指向的值。 Redis 的值类型有： 二进制安全的字符串 Lists：按插入顺序排序的字符串元素的集合，他们基本上都是链表（linked lists） Sets：不重复且无序的字符串元素的集合 Sorted sets：类似 Sets ，但是每个字符串元素都关联到一个叫 score 浮动数值。里边的元素总是通过 score 进行排序，所以不同的是，它是可以检索的一系列元素。 Hashes：由 field 和关联的 value 组成的 map。 Bit arrays：通过特殊的命令，你可以将 String 值当做一系列 bits 处理：可以设置和清除单独的 bits，数出所有设为1 的bits 的数量，找到 最前的被设置为 1 或者0 的bit，等等。 HyperLogLogs：这是被用于估计一个 set 中元素数量的概率性的数据结构。 Redis 超时：数据在限定时间内存货（过期时间设定）在 redis 中可以对 key 设置一个超时时间，当这个时间达到后会被删除。精度可以使用毫秒或者秒。 123456// 对指定keys设置过期时间为60sexpire key 60// 在给key设置value的时候同时设置过期时间为60sset key value ex 60// 查询key还有多久过期ttl key","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Redis","slug":"技术学习/Redis","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Redis/"}],"tags":[]},{"title":"Redis设置密码","slug":"技术学习/Redis/Redis设置密码","date":"2021-07-26T03:23:17.316Z","updated":"2021-08-10T15:51:11.451Z","comments":true,"path":"post/1685059487.html","link":"","permalink":"https://dd-code.site/post/1685059487.html","excerpt":"","text":"Redis 没有实现访问控制这个功能，但是它提供了一个轻量级的认证方式，可以编辑 redis.conf 配置来启用认证。 1、初始化Redis密码 在配置文件中有个参数： requirepass 这个就是配置 Redis 访问密码的参数，需重启 Redis 才能生效） 1requirepass 密码 Redis 的查询速度是非常快的，外部用户一秒内可以尝试多大150K个密码，所以密码要尽量长（对于DBA 没有必要必须记住密码）； 2、不重启Redis设置密码 在配置文件中配置 requirepass 的密码（当 Redis 重启时密码依然有效） 1redis 127.0.0.1:6379&gt; config set requirepass 密码 查询密码12redis 127.0.0.1:6379&gt; config get requirepass(error) ERR operation not permitted 密码验证12redis 127.0.0.1:6379&gt; auth 密码OK 再次查询123redis 127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;test123&quot; PS：如果配置文件中没添加密码 那么 Redis 重启后，密码失效。 3、登陆有密码的 Redis：在登录的时候的时候输入密码1redis-cli -p 6379 -a test123 先登陆后验证123redis-cli -p 6379redis 127.0.0.1:6379&gt; auth test123OK AUTH 命令跟其他redis命令一样，是没有加密的；阻止不了攻击者在网络上窃取你的密码。 认证层的目标是提供多一层的保护。如果防火墙或者用来保护redis的系统防御外部攻击失败的话，外部用户如果没有通过密码认证还是无法访问 Redis 的。 参考资料： https://blog.51cto.com/weipengfei/1217872 &lt;&lt;点击返回主页","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Redis","slug":"技术学习/Redis","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Redis/"}],"tags":[]},{"title":"了解Memcache","slug":"技术学习/Redis/了解Memcache","date":"2021-07-26T03:23:17.316Z","updated":"2021-08-10T15:06:31.702Z","comments":true,"path":"post/2253204330.html","link":"","permalink":"https://dd-code.site/post/2253204330.html","excerpt":"","text":"memcache 概述memcache 就是一个数据库，但是数据存在内存中。常用来做缓存服务器、将数据库查询的数据缓存起来，减少数据库缓存、加快查询速度。memcache 的数据仅保存在内存中，服务器重启后，数据将会丢失。 memcache 使用场景缓存服务器 适合存储的数据 访问比较频繁的数据，安全性较差的数据，丢失无所谓的数据 数据更新比较频繁的数据，比如用户的在线状态 数据的单个键值不能太大，不能超过 1Mb 数据 memcache 可以存储的数据类型整型、浮点型、布尔型、字符串型、数组型、对象类型、空类型 memcache 相关算法1、惰性过期机制 说明：memcached 内部不会监视记录是否过期，而是在 get 时查看记录的时间戳，检查记录是否过期，这种技术被称为惰性过期。 好处：减少监控过期产生的开销 2、最近最少使用算法 缓存空间已满，将使用频率最低数据进行删除。 memcache 常见问题1、缓存雪崩场景：项目缓存同一时间失效 问题：瞬间几万次、几千万次的同时访问数据库，数据库崩溃。 解决： ①不要集中设置缓存有效期 ②控制缓存在闲时过期 ③主从复制、读写分离 2、永久数据被踢原因：因为惰性过期机制和最少使用机制导致 解决：永久数据和飞=非永久数据分开存放 ​","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"数据库","slug":"技术学习/数据库","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Memcache","slug":"技术学习/数据库/Memcache","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/Memcache/"}],"tags":[]},{"title":"Redis持久化","slug":"技术学习/Redis/Redis持久化","date":"2021-07-26T03:23:17.315Z","updated":"2021-08-10T15:51:11.451Z","comments":true,"path":"post/295621084.html","link":"","permalink":"https://dd-code.site/post/295621084.html","excerpt":"","text":"Redis是一种高级的key- value数据库。它所有的数据都保存在内存中，然后不定期的通过异步方式保存到磁盘上（这种称为“半持久化模式”），也可以把每一次的数据变化都写入到append only file（aof）里面（称为“全持久化模式”）。 由于Redis的数据都放在内存中，如果没有配置持久化，redis重启后数据就全部丢失了，于是需要开启redis的持久化功能，将数据保存在磁盘上，当Redis重启后，可以从磁盘恢复数据。 Redis提供两种方式进行持久化： ①是RDB持久化，原理是将Redis的数据记录定时备份到磁盘中； ②是AOF持久化，原理是将Redis的操作日志以追加的方式写入文件。","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Redis","slug":"技术学习/Redis","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Redis/"}],"tags":[]},{"title":"Redis数据类型比较和使用场景","slug":"技术学习/Redis/Redis数据类型比较和使用场景","date":"2021-07-26T03:23:17.315Z","updated":"2021-08-10T15:51:11.451Z","comments":true,"path":"post/1349846639.html","link":"","permalink":"https://dd-code.site/post/1349846639.html","excerpt":"","text":"Redis 支持五种数据类型： string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合） 字符串（String）string 是 redis 最基本的类型，可以理解为和 memcache 一模一样的类型，key-&gt;value 结构 string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。 string 类型是 redis 最基本的数据类型，string 类型的值最大能存储 512MB 应用场景： 手机验证码存储，过期时间失效 缓存功能 计数器 bitmap 位图：可广泛用于，签到、活跃、打卡等场景统计 分布式锁 哈希（Hash）Redis hash 是一个键值对（key-&gt;value）集合，是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 每个 hash 可以存储 232-1 键值对（40多亿）。 应用场景： 存储一个用户信息对象数据，比如用户的昵称、年龄、性别、积分等 购物车数据 列表（List）Redis List 是一个双向链表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）。 应用场景： List 类型经常会被用于消息队列的服务，以完成多程序之间的消息交换 各种列表，比如：关注列表、粉丝列表、最新消息排行、每篇文章的评论 利用 lrange 可以很方便的实现 list 内容分页的功能 集合（Set）Redis 的 set 是 string 类型的无序集合。集合中的元素没有先后顺序，不重复。将重复的元素放入 Set 会自动去重。 和列表一样，在执行插入、删除、判断是否存在某元素时，效率比较高。集合最大的优势在于可以进行交集、并集、差集 操作。 set 可包含的最大元素数量是 4294967295。 集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是 O（1）。 应用场景： 利用交集求共同好友 利用唯一性，可以统计访问网站的所有独立IP、需要去重列表场景 好友推荐的时候可以根据 tag 求交集，大于某个临界值就可以推荐，集合最大的成员数为 232 - 1（4294967295，每个集合可存储40多亿个成员） 有序集合（zset）Redis zset 和 set 一样也是 string 类型元素的集合，且不允许重复的成员。 不同的是每个元素都会关联一个 double 类型的分数。Redis 正是通过分数来为集合中的成员进行从小到大的排序。 zset 的成员是惟一的，但分数 score 却可以重复。 sorted、 set 是插入有序的，即自动排序。 应用场景： 当你需要一个有序的并且不重复的集合列表是，那么可以选择 sorted 、set 数据结构。 应用举例： 例如存储全班同学的成绩，其集合 value 可以是同学的学号，而 score 就可以是成绩 排行榜应用，更具得分列出 topN 的用户 不重复的集合列表 过期淘汰场景","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Redis","slug":"技术学习/Redis","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Redis/"}],"tags":[]},{"title":"docker安装oracle19c","slug":"技术学习/Oracle/docker安装oracle19c","date":"2021-07-26T03:23:17.314Z","updated":"2021-08-10T15:50:52.845Z","comments":true,"path":"post/3032572741.html","link":"","permalink":"https://dd-code.site/post/3032572741.html","excerpt":"","text":"拉取镜像1docker pull registry.cn-hangzhou.aliyuncs.com/zhuyijun/oracle:19c 启动1234567891011docker run -p 1521:1521 -p 5500:5500 \\-e ORACLE_SID=orcl \\-e ORACLE_PDB=orclpdb1 \\-e ORACLE_PWD=123456 \\-e ORACLE_CHARACTERSET=zhs16gbk \\-e ORACLE_BASE=/opt/oracle \\-e ORACLE_HOME=/opt/oracle/product/19c/dbhome_1 \\-e PATH=/opt/oracle/product/19c/dbhome_1/bin:/opt/oracle/product/19c/dbhome_1/OPatch/:/usr/sbin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin \\-v /Users/liudandan/homedata/oradata:/opt/oracle/oradata \\--name myoracle \\registry.cn-hangzhou.aliyuncs.com/zhuyijun/oracle:19c 注意1： 1、注意使用之前请修改启动参数 2、修改/Users/liudandan/homedata/oradata为自己创建的orcale数据存储目录 3、请填写镜像的容器id或者容器名 注意2： 1、出现DATABASE IS READY TO USE 代表者成功了 2、这时先不要关闭终端，另外开启一个 3、进入环境修改oracle密码 启动成功之后的界面启动需要一定时间，这是正在启动的画面 修改Oralce数据库密码1docker exec myoracle ./setPassword.sh 123456 ！修改完密码后可以关闭之前终端了，出现 DATABASE IS READY TO USE之后，后边都是显示的日志，可以关闭终端，关闭终端不会导致它停止运行 进入Oracle Enterprise Manager Database Express页面1https:&#x2F;&#x2F;localhost:5500&#x2F;em ！注意输入网址是采用的是https，http无法访问。 账号 system/sys/等 密码 123456 容器名 orclpdb1","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Oracle","slug":"技术学习/Oracle","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Oracle/"}],"tags":[]},{"title":"Centos7下Oracle19c的安装","slug":"技术学习/Oracle/Centos7下Oracle19c的安装","date":"2021-07-26T03:23:17.310Z","updated":"2021-08-10T15:50:52.844Z","comments":true,"path":"post/1452475922.html","link":"","permalink":"https://dd-code.site/post/1452475922.html","excerpt":"","text":"第一步：检查Linux系统版本执行命令 lsb_release -a 查看系统版本 1lsb_release -a 用yum更新升级自己的系统到当前最新。 1yum -y clean all 1yum -y update 第二步：下载Oracle19c的安装包下载地址：https://www.oracle.com/database/technologies/oracle-database-software-downloads.html#19c 第三步：下载Oracle19c的预安装包下载地址：http://yum.oracle.com/repo/OracleLinux/OL7/latest/x86_64/getPackage/oracle-database-preinstall-19c-1.0-1.el7.x86_64.rpm 第四步：安装包全部上传到Linux1scp oracle-database-ee-19c-1.0-1.x86_64.rpm root@39.107.245.19:/root","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Oracle","slug":"技术学习/Oracle","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Oracle/"}],"tags":[]},{"title":"事务的四个特性","slug":"技术学习/MySQL/事务的四个特性","date":"2021-07-26T03:23:17.309Z","updated":"2021-08-10T15:50:26.793Z","comments":true,"path":"post/1868093003.html","link":"","permalink":"https://dd-code.site/post/1868093003.html","excerpt":"","text":"简介数据库事务 (Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务隔离同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如 A 正在从一张银行卡中取钱，在 A 取钱的过程结束前，B 不能向这张卡转账。 数据库事务的四个特性（四种隔离状态）事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。 原子性：事务由一个或多个行为捆绑在一起，好像是一个独立的工作单元。原子性保证事务内的操作要么都发生，要么都不发生。假如所有的操作都成功了，那么事务是成功的；假如任何一个操作失败，那么事务就会进行回滚 一致性：一旦一个事务结束了，不管是成功还是失败，系统所处的状态和业务规则是一致的。也就是说，数据应当不会被破坏 隔离性：事务应当允许多个用户操作同一个数据，一个用户的操作不应该和其他用户的操作相混淆。因此事务是相互隔离的，防止并行读写同一个数据的情况发生。注意：隔离性通常意味着要锁定数据库的表或行 不同的隔离级别 ： Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生 Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题 Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读 Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题 持久性：一旦事务完成，事务的结果应当持久化。这样不管什么样的系统崩溃，都不会造成数据异常。","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"MySQL","slug":"技术学习/MySQL","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/MySQL/"}],"tags":[]},{"title":"使用MySqlDump备份","slug":"技术学习/MySQL/使用MySqlDump备份","date":"2021-07-26T03:23:17.309Z","updated":"2021-08-10T15:50:30.422Z","comments":true,"path":"post/2178661577.html","link":"","permalink":"https://dd-code.site/post/2178661577.html","excerpt":"","text":"如何备份数据库语法1mysqldump [arguments] &gt; file_name 要转储所有数据库，请使用以下选项调用1mysqldump --all-databases &gt; dump.sql 要仅转储特定数据库，请在命令行上命名它们并使用以下1mysqldump --databases db1 db2 db3 &gt; dump.sql 要转储单个数据库，请在命令行上将其命名1mysqldump --databases test &gt; dump.sql 在单数据库情况下，可以忽略以下 –databases 选项1mysqldump test &gt; dump.sql 要仅转储数据库中的特定表，请在数据库名称后的命令行中将其命名1mysqldump test t1 t3 t7 &gt; dump.sql 备份到当前的目录（在对应目录下执行以下命令）1mysqldump -u root -p --opt database &gt; database.sql 如何恢复数据库语法登录数据库 1mysql -u root -p 进入对应的数据库 1use test; 执行恢复命令 1source /source /tmp/test.sql","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"MySQL","slug":"技术学习/MySQL","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/MySQL/"}],"tags":[]},{"title":"MySQL索引失效情况","slug":"技术学习/MySQL/MySQL索引失效情况","date":"2021-07-26T03:23:17.307Z","updated":"2021-08-10T15:50:26.794Z","comments":true,"path":"post/548465112.html","link":"","permalink":"https://dd-code.site/post/548465112.html","excerpt":"","text":"首先，复习一下索引的创建： 普通的索引的创建 1CREATE INDEX (自定义)索引名 ON 数据表(字段) 复合索引的创建 1CREATE INDEX (自定义)索引名 ON 数据表(字段，字段，。。。) 删除索引 1DROP INDEX 索引名 以下通过 explain 显示出 mysql 执行的字段内容： id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符. select_type: SELECT 查询的类型. table: 查询的是哪个表 partitions: 匹配的分区 type: join 类型 possible_keys: 此次查询中可能选用的索引 key: 此次查询中确切使用到的索引 ref: 哪个字段或常数与 key 一起被使用 rows: 显示此查询一共扫描了多少行. 这个是一个估计值. filtered: 表示此查询条件所过滤的数据的百分比 extra: 额外的信息 索引查询失效的几个情况： 1、like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效。 2、or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效 3、组合索引，不是使用第一列索引，索引失效 4、数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。 5、在索引列上使用 IS NULL 或 IS NOT NULL操作。索引是不索引空值的，所以这样的操作不能使用索引，可以用其他的办法处理，例如：数字类型，判断大于0，字符串类型设置一个默认值，判断是否等于默认值即可。 6、在索引字段上使用not，&lt;&gt;，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。 7、对索引字段进行计算操作、字段上使用函数。（索引为 emp(ename,empno,sal)） 8、当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。 索引失效分析工具： 可以使用 explain 命令加在要分析的 sql 语句前面，在执行结果中查看 key 这一列的值，如果为 NULL，说明没有使用索引。 explain 命令的详细用法，可以查看这篇文章：https://segmentfault.com/a/1190000008131735","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"MySQL","slug":"技术学习/MySQL","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/MySQL/"}],"tags":[]},{"title":"MySQL索引类型","slug":"技术学习/MySQL/MySQL索引类型","date":"2021-07-26T03:23:17.307Z","updated":"2021-08-10T15:50:26.793Z","comments":true,"path":"post/1647528259.html","link":"","permalink":"https://dd-code.site/post/1647528259.html","excerpt":"","text":"1：普通索引这是最基本的索引，它没有任何限制，比如某个字段创建的索引就是一个普通索引，MyISAM 默认的 BTREE 类型的索引，也是我们大多数情况下用到的索引。 直接创建索引 1CREATE INDEX index_name ON TABLE(column(lehgth)) 修改表结构的方式添加索引 1ALTER TABLE table_name ADD INDEX index_name ON (column(length)) 创建表的时候同时创建索引 12345678CREATE TABLE &#x27;TABLE&#x27; ( &#x27;id&#x27; int(11) NOT NULL AUTO_INCREMENT, &#x27;title&#x27; char(255) CHARACTER SET UTF8 COLLATE utf8_general_ci NOT NULL, &#x27;content&#x27; text CHARACTER SET UTF8 COLLATE utf8_general_ci NOT NULL, &#x27;time&#x27; int(10) NULL DEFAULT NULL,PRIMARY KEYo(&#x27;id&#x27;),INDEX index_name(title(length))) 删除索引 1DROP INDEX INDEX_NAME ON table 2：唯一索引与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值得组合必须唯一，创建方法和普通索类似。 创建唯一索引 1CREATE UNIQUE INDEX index_name ON TABLE(columm(length)) 修改表结构 1ALTER TABLE table_name ADD UNIQUE index_name ON (column(length)) 创建表的时候直接指定 12345678CREATE TABLE &#x27;TABLE&#x27;( &#x27;id&#x27; int(11) NOT NULL AUTO_INCREMENT, &#x27;title&#x27; char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, &#x27;content&#x27; text CHARACTER SET utf8 COLLATE utf8_general_ci NULL, &#x27;time&#x27; int(10) NULL DEFAULT NULL,PRIMARY KEY(&#x27;id&#x27;),UNIQUE index_name (titlt(length))) 3：全文索引对于较大的数据集，将你的资料输入一个没有 FULLTEXT 索引的表中，然后创建索引，其速度比把资料输入现有 FULLTEXT索引的速度更为快。不过对于大容量的数据表，生成全文索引是一个消耗时间非常消耗硬盘空间的做法。 创建表的时候添加全文索引 12345678CREATE TABLE &#x27;TABLE&#x27;( &#x27;id&#x27; int(11) NOT NULL AUTO_INCREMENT, &#x27;title&#x27; char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, &#x27;content&#x27; text CHARACTER SET utf8 COLLATE utf8_general_ci NULL, &#x27;time&#x27; int(10) NULL DEFAULT NULL, PRIMARY KEY (&#x27;id&#x27;), FULLTEXT (content)) 修改表结构添加全文索引 1ALTER TABLE article ADD FULLTEXT index_content(content) 直接创建索引 1CREATE FULLTEXT INDEX index_content ON article(content) 4：单列索引、多列索引多个单列索引与单个单列索引的查询效果不同，因为执行查询时，MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。 5：组合索引（最左前缀）平时用的 SQL 查询语句一般都有比较多的限制条件，所以为了进一步榨取 MySQL 的效率，就要考虑简历组合索引。 比如：针对 title 和 time 建立一个组合索引 1ALTER TABLE article ADD INDEX index_title_time(title(50),time(10)) 建立这样的组合索引，其实相当于分别建立了下面两组组合索引： 12-title,time-title 为什么没有 time 这样的组合索引呢？这是因为 MySQL 组合索引“最左前缀”的结果。简单理解就是只从最左面的开始组合。并不是只要包含这两列的查询都会用到该组合索引，如下面几个 SQL 所示： 12345-- 使用上面的索引SELECT * FROM article WHERE title=&#x27;测试&#x27; AND time=123456789;SELECT * FROM article WHERE title=&#x27;测试&#x27;;-- 不适用上面的索引SELECT * FROM article WHERE time=123456789; MySQL 索引的优化上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有其它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件。建立索引文件会占用磁盘空间的索引文件。一般情况下这个问题不太严重，但如果你在一个大表中创建了多种组合索引，索引文件会膨胀的很快。索引只是提高效率的一个因素，如果你的 MySQL 有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。 1：何时使用聚集索引或非聚集索引？ 动作描述 使用聚集索引 使用非聚集索引 列经常被分组排序 使用 使用 返回某范围内的数据 使用 不使用 一个或极少不同值 不使用 不使用 小数目的不同值 使用 不使用 大数目的不同值 不使用 使用 频繁更新的列 不使用 使用 外键列 使用 使用 主键列 使用 使用 频繁修改索引列 不使用 使用 还需再研究下…. 2：索引不会包含有 null 值得列只要列中包含有 null 值都将不会被包含在索引中，复合索引中只要有一列含有 null 值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为 NULL。 3：使用短索引对串列进行索引，如果可能应该指定一个前缀长度。例如： 如果有一个 CHAR(255) 的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且还可以节省磁盘空间和 I/O 操作。 4：索引列排序MySQL 查询只使用一个索引，因此如果 where 子句中已经使用了索引的话，那么 order by 中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这里写列创建符合索引。 5：like 语句操作一般情况下不鼓励使用 like 操作，如果非使用不可，如何使用也是一个问题，比如： like &quot;%aaa%&quot; 不会使用索引而 like &quot;aaa%&quot; 可以使用索引。 6：不要在列上使用运算例如： 1SELECT * FROM users WHERE YEAR(adddate) &lt; 2007 这个将在每个行上进行运算，导致索引失效而进行全表扫描，因此我们可以改成 1SELECT * FROM users where adddate &lt; &#x27;2007-01-01&#x27; 欣赏：一个单引号引发的MYSQL性能损失 总结：MySQL 只对以下操作符才使用索引： &lt;、&lt;=、=、&gt;、&gt;=、between、in，以及某些时候的 like（不以通配符 % 或 _ 开头的情形），而理论上每张表里面最多可创建 16 个索引，不过除非数据是真的多，否则过多使用索引也不行。","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"MySQL","slug":"技术学习/MySQL","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/MySQL/"}],"tags":[]},{"title":"MySQL常见问题","slug":"技术学习/MySQL/MySQL常见问题","date":"2021-07-26T03:23:17.306Z","updated":"2021-08-10T15:50:26.904Z","comments":true,"path":"post/445316081.html","link":"","permalink":"https://dd-code.site/post/445316081.html","excerpt":"","text":"（一）死锁问题原因随着线上流量的变大，突然开始报如下异常，就是发生了死锁问题： 1Deadlock found when trying to get lock; try restarting transaction ; 问题分析查询事务的隔离级别 利用 select @@tx_isolation 命令获取到数据库隔离级别信息。 查询数据库的死锁日志，利用 show engine innodb status 命令获取到如下死锁信息： 由上可知，是由于两个事物对这条记录同时持有S锁(共享锁)的情况下，再次尝试获取该条记录的X锁(排它锁)，从而导致互相等待引发死锁 获得结论分析获得产生问题的加锁时如下，然后修改代码以解决该问题。 （二）慢SQL问题出现应用的 TPS 下降，并出现 SQL 执行超时异常或者出现了类似如下的告警信息，则常常意味着出现了慢 SQL。 问题分析分析执行计划：利用 explain 指令获得该 SQL 语句的执行计划，根据该执行计划，可能有两种场景。 SQL 不走索引或扫描行数过多等，导致执行时长过长 SQL 没问题，只是因为事务并发导致等待锁，导致执行时长过长 场景一（SQL 不走索引或扫描行数过多等，导致执行时长过长）的解决方案优化SQL通过增加索引，调整 SQL 语句的方式优化执行时长，例如以下执行计划： 该 SQL 的执行计划的 TYPE 为 ALL，同时根据以下 type 予以，可知无索引的全表查询，可以判断为其检索列增加索引可以解决。 场景二（SQL 没问题，只是因为事务并发导致等待锁，导致执行时长过长）的解决方案查询当前事务情况可以通过查看如下 3 张表做相应的处理： 123456-- 当前运行的所有事务SELECT * FROM information_schema.innodb_trx;-- 当前出现的锁SELECT * FROM information_schema.INNODB_LOCKS;-- 锁等待的对应关系SELECT * FROM information_schema.INNODB_LOCK_WAITS; （1）查看当前的事务有哪些： （2）查看事务锁类型索引的详细信息： look_table 字段能看到被锁的索引的表名，lock_model 可以看到锁类型是 X 锁，lock_type 可以看到是行锁 record 。 分析根据事务情况，得到表信息，和相关的事务时序信息： 12345678DROP TABLE IF EXISTS `emp`;CREATE TABLE `emp` (`id` int(11) NOT NULL AUTO_INCREMENT,`salary` int(10) DEFAULT NULL,`name` varchar(255) DEFAULT NULL,PRIMARY KEY (`id`),KEY `idx_name` (`name`(191)) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4; A 事务锁住一条记录，不提交，B 事务需要更新此条记录，此时会阻塞，如下图是执行顺序： 解决方案（一）修改方案由前一步的结果，分析事务间加锁时序，例如可以通过 tx_query 字段得知被阻塞的事务 SQL，trx_state 得知事务状态等，找到对应的代码逻辑，进行优化修改。 （二）临时修改方案trx_mysql_thread_id 是对应的事务 sessionId，可以通过以下命令杀死上时间执行的命令，从而避免阻塞其他事务执行。 1kill 105853 （三）连接数过多问题出现常出现 too many connections 异常，数据库连接到达最大连接数。 解决方案解决方案 通过 set global max_connections=XXX 增大最大连接数 先利用 show processlist 获取连接信息，然后利用 kill 杀死过多的连接 常用脚本如下 12排序数据库连接的数目 mysql -h127.0.0.0.1 -uabc_test -pXXXXX -P3306 -A -e &#x27;show processlist&#x27;| awk &#x27;&#123;print $4&#125;&#x27;|sort|uniq -c|sort -rn|head -10","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"MySQL","slug":"技术学习/MySQL","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/MySQL/"}],"tags":[]},{"title":"MySQL查询重复的数据","slug":"技术学习/MySQL/MySQL查询重复的数据","date":"2021-07-26T03:23:17.306Z","updated":"2021-08-10T15:50:26.793Z","comments":true,"path":"post/961775144.html","link":"","permalink":"https://dd-code.site/post/961775144.html","excerpt":"","text":"查询字段 fund_id 重复的数据 12SELECT * FROM fund a WHERE (a.fund_id) IN (SELECT fund_id FROM fund GROUP BY fund_id HAVING count(*)&gt; 1);","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"MySQL","slug":"技术学习/MySQL","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/MySQL/"}],"tags":[]},{"title":"MySQL索引和存储引擎","slug":"技术学习/MySQL/MySQL索引和存储引擎","date":"2021-07-26T03:23:17.306Z","updated":"2021-08-10T15:50:26.794Z","comments":true,"path":"post/70487411.html","link":"","permalink":"https://dd-code.site/post/70487411.html","excerpt":"","text":"索引MySQL 不同的存储引擎 InnoDB B+Tree 索引实现主键索引（聚集索引）： 叶子节点 data 域保存了完整的数据的地址 主键和数据完全存在一棵树上 Root 节点常驻内存 每个非叶子节点一个 innodb_page_size 大小，加速磁盘 IO 磁盘的 IO 要比内存慢几百倍，而磁盘慢的原因在于机械设备寻找磁盘慢，因此采用磁盘预读，每次读取一个磁盘页（计算机管理存储器的逻辑快-通常为4k）的整倍数 如果没有主键，MySQL 默认生成隐含字段作为主键，这个字段长度为 6 个字节，类型为长整形 辅助索引结构和主索引相同，但叶子节点 data 域保存的是主键指针 InnnoDB 以表空间 Tablespace（idb文件）结构进行组织，每个 Tbalespace 包含多个 Segment 段 每个段（分为2种段：叶子节点 Segment &amp; 非叶子节点 Segment），一个 Segment 段包含多个 Extent 一个 Extent 占用 1M 空间包含 64 个 Page（每个Page 16k），InnoDB 的 B-Tree 一个逻辑节点就分配一个物理 Page，一个节点一次 IO 操作 一个 Page 里包含很多有序数据 Row 行数据，Row 行数据中包含 Filed 属性数据等信息 InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用4个字节）或 BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的节点）中大概存储 16KB/(8B+8B)=1k个键值（因为是估值，为方便计算，这里的K的取值为[10]^3）. 也就是说一个深度为 3 的 B+Tree 索引可以维护 10^3 * 10^3 * 10^3=10 亿条记录。 每个索引的左指针都是比自己小的 索引/节点，右指针是大于自己的 索引/节点。","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"MySQL","slug":"技术学习/MySQL","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/MySQL/"}],"tags":[]},{"title":"MySQL基础-小数类型","slug":"技术学习/MySQL/MySQL基础-小数类型","date":"2021-07-26T03:23:17.305Z","updated":"2021-08-10T15:50:26.793Z","comments":true,"path":"post/1724192415.html","link":"","permalink":"https://dd-code.site/post/1724192415.html","excerpt":"","text":"MySQL 中使用浮点数和定点数来表示小数。 浮点类型有两种，分别是单精度浮点数 float 和双精度浮点数 double ；定点类型只有一种，就是 decimal 。 类型名称 说明 存储需求 FLOAT 单精度浮点数 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 decimal 类型不同于 float 和 double 。double 实际上是以字符串的形式存放的，decimal 可能的最大取值范围与 double 相同，但是有效的取值范围由 M 和 D 决定。如果改变 M 而固定 D，则取值范围将随 M 的变大而变大。 从上表中可以看到，decimal 的存储空间并不是固定的，而由精度值 M 决定，占用 M+2 个字节。 float 类型的取值范围如下： 有符号的取值范围：-3.402823466E+38 ～ -1.175494351E-38。 无符号的取值范围：0 和 -1.175494351E-38 ～ -3.402823466E+38。 double 类型的取值范围如下： 有符号的取值范围：-1.7976931348623157E+308 ～ -2.2250738585072014E-308。 无符号的取值范围：0 和 -2.2250738585072014E-308 ～ -1.7976931348623157E+308。 提示：不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。 float 和 double 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），decimal 如果不指定精度，默认为 （10，0）。 浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。 在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"MySQL","slug":"技术学习/MySQL","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/MySQL/"}],"tags":[]},{"title":"MySQL基础-整数类型","slug":"技术学习/MySQL/MySQL基础-整数类型","date":"2021-07-26T03:23:17.305Z","updated":"2021-08-10T15:50:26.793Z","comments":true,"path":"post/1988337205.html","link":"","permalink":"https://dd-code.site/post/1988337205.html","excerpt":"","text":"整数类型又称数值型数据，数值型数据类型主要用来存储数字。 MySQL 主要提供的整数类型有 tinyint、smallint、mediumint、int、bigint，其属性字段可以添加 AUTO_INCREMENT(auto_increment) 自增约束条件。 类型名称 说明 存储需求 TINYINT 很小的整数（-128〜127） 1个字节（0 〜255） SMALLINT 小的整数（-32768〜32767） 2个宇节（0〜65535） MEDIUMINT 中等大小的整数（-8388608〜8388607） 3个字节（0〜16777215） INT (INTEGHR) 普通大小的整数（-2147483648〜2147483647） 4个字节（0〜4294967295） BIGINT 大整数（-9223372036854775808〜9223372036854775807） 8个字节（0〜18446744073709551615）","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"MySQL","slug":"技术学习/MySQL","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/MySQL/"}],"tags":[]},{"title":"MySQL优化","slug":"技术学习/MySQL/MySQL优化","date":"2021-07-26T03:23:17.304Z","updated":"2021-08-10T15:50:26.794Z","comments":true,"path":"post/748313607.html","link":"","permalink":"https://dd-code.site/post/748313607.html","excerpt":"","text":"对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： 1select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询： 1select id from t where num = 0 应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： 1select id from t where num=10 or num = 20 可以这样查询： 1select id from t where num=10 union all select id from t where num = 20 in 和 not in 也要慎用，否则会导致全表扫描，如： 1select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： 1select id from t where num between 1 and 3 下面的查询也将导致全表扫描： 1select id from t where name like &#x27;%abc%&#x27; 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： 1select id from t where num/2=100 应改为: 1select id from t where num=100*2 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： 1select id from t where substring(name,1,3) = &#x27;abc&#x27; --name以 abc 开头的 id 应改为: 1select id from t where name like &#x27;abc%&#x27; 不要在 where 子句中的 = 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致 不要写一些没有意义的查询，如需要生成一个空表结构： 1select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： 1create table #t(...) 很多时候用 exists 代替 in 是一个好的选择： 1select num from a where num in(select num from b) 用下面的语句替换： 1select num from a where exists(select 1 from b where num=a.num) 并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL 查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在 sex 上建了索引也对查询效率起不了作用 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率， 因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。 一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。 这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了 尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间， 其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些 任何地方都不要使用 select * from t ，用具体的字段列表代替 *，不要返回用不到的任何字段 避免频繁创建和删除临时表，以减少系统表资源的消耗 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 create table，然后 insert 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效 尽量避免大事务操作，提高系统并发能力 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"MySQL","slug":"技术学习/MySQL","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/MySQL/"}],"tags":[]},{"title":"MySQL千万级大数据量查询优化","slug":"技术学习/MySQL/MySQL千万级大数据量查询优化","date":"2021-07-26T03:23:17.304Z","updated":"2021-08-10T15:50:26.794Z","comments":true,"path":"post/1213461122.html","link":"","permalink":"https://dd-code.site/post/1213461122.html","excerpt":"","text":"对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询： 1select id from t where num=0 应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则引擎将放弃使用索引而进行全表扫描。 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num=10 or num=20 可以这样查询： 1select id from t where num=10 union all select id from t where num=20 in 和 not in 也要慎用，否则会导致全表扫描，如：select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： 1select id from t where num between 1 and 3 下面的查询也将导致全表扫描：select id from t where name like ‘%李%’， 若要提高效率，可以考虑全文检索： 1select id from t where name = ‘X李X’ 如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项，如下面语句将进行全表扫描：select id from t where num=@num 可以改为强制查询使用索引：select id from t with(index(索引名)) where num=@num 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num/2=100 应改为: select id from t where num=100*2 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where substring(name,1,3)=’abc’ ，name 以 abc 开头的 id 应改为: 1select id from t where name like ‘abc%’ 不要在 where 子句中的 = 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 很多时候用 exists 代替 in 是一个好的选择：select num from a where num in(select num from b) 用下面的语句替换： 1select num from a where exists(select 1 from b where num=a.num) 并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL 查询可能不会去利用索引，如一表中有字段 sex、male、female 几乎各一半，那么即使在 sex 上建了索引也对查询效率起不了作用。 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 任何地方都不要使用 select * from table ，用具体的字段列表代替 * ，不要返回用不到的任何字段。 避免频繁创建和删除临时表，以减少系统表资源的消耗。 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 create table，然后 insert 。 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 与临时表一样，游标并不是不可使 用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时；在结果集中包括“合计”的例程通常要比使用游标执行的速度快；如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF ，无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC 消息。 尽量避免大事务操作，提高系统并发能力。 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"MySQL","slug":"技术学习/MySQL","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/MySQL/"}],"tags":[]},{"title":"mongo新建用户","slug":"技术学习/Mongo/mongo新建用户","date":"2021-07-26T03:23:17.303Z","updated":"2021-08-10T15:50:12.116Z","comments":true,"path":"post/3140326379.html","link":"","permalink":"https://dd-code.site/post/3140326379.html","excerpt":"","text":"连接 mongo之后 第一步：切换到 admin 库，mongo 默认库用来保存操作用户信息： 1use admin 第二步：创建一个用户名是root，密码是root123的管理员身份用户 1db.createUser(&#123;user:&#x27;root&#x27;,pwd:&#x27;root123&#x27;,roles:[&#x27;userAdminAnyDatabase&#x27;]&#125;) 第三步：切换到业务库 1use TestDemo 第四步：赋予新创建的用户TestDemo业务库的读写权限 1db.createUser(&#123;user:&#x27;root&#x27;,pwd:&#x27;root123&#x27;,roles:[&#x27;readWrite&#x27;]&#125;) 创建超极用户root 12345678use admindb.createUser( &#123; user: &quot;root&quot;, pwd: &quot;root&quot;, roles: [ &#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125; ] &#125;); 删除用户 1db.removeUser(&#39;XXX&#39;)","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Mongo","slug":"技术学习/Mongo","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Mongo/"}],"tags":[]},{"title":"MyISAM和InnoDB的区别","slug":"技术学习/MySQL/MyISAM和InnoDB的区别","date":"2021-07-26T03:23:17.303Z","updated":"2021-08-10T15:50:26.793Z","comments":true,"path":"post/4025057969.html","link":"","permalink":"https://dd-code.site/post/4025057969.html","excerpt":"","text":"MyISAM 强调的是性能，查询速度快，支持表锁，支持全文索引，并发较小，不支持事务型操作，不支持外键，崩溃后不可自动恢复 InnoDB 适合频繁修改以及设计安全性较高的应用，支持行锁，不支持全文索引，并发较大，支持事务型操作，支持外键，奔溃可恢复 对于 select count(*) from table 语句，MyISAM 比 InnoDB 快，因为 MyISAM 直接会保存表行数，在查询的时候直接取出，但是InnoDB 会遍历整个表来计算行 对于加了where条件，select count(*) from table where 条件，两者都会进行遍历计算行数","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"MySQL","slug":"技术学习/MySQL","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/MySQL/"}],"tags":[]},{"title":"mongo常用命令","slug":"技术学习/Mongo/mongo常用命令","date":"2021-07-26T03:23:17.302Z","updated":"2021-08-10T15:50:02.537Z","comments":true,"path":"post/1691421171.html","link":"","permalink":"https://dd-code.site/post/1691421171.html","excerpt":"","text":"1234567891011121314151617show dbs #显示数据库列表 show collections #显示当前数据库中的集合（类似关系数据库中的表）show users #显示用户use &lt;db name&gt; #切换当前数据库，如果数据库不存在则创建数据库。 db.help() #显示数据库操作命令，里面有很多的命令 db.foo.help() #显示集合操作命令，同样有很多的命令，foo指的是当前数据库下，一个叫foo的集合，并非真正意义上的命令 db.foo.find() #对于当前数据库中的foo集合进行数据查找（由于没有条件，会列出所有数据） db.foo.find( &#123; a : 1 &#125; ) #对于当前数据库中的foo集合进行查找，条件是数据中有一个属性叫a，且a的值为1db.dropDatabase() #删除当前使用数据库db.cloneDatabase(&quot;127.0.0.1&quot;) #将指定机器上的数据库的数据克隆到当前数据库db.copyDatabase(&quot;mydb&quot;, &quot;temp&quot;, &quot;127.0.0.1&quot;) #将本机的mydb的数据复制到temp数据库中db.repairDatabase() #修复当前数据库db.getName() #查看当前使用的数据库，也可以直接用dbdb.stats() #显示当前db状态db.version() #当前db版本db.getMongo() ＃查看当前db的链接机器地址db.serverStatus() #查看数据库服务器的状态","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Mongo","slug":"技术学习/Mongo","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Mongo/"}],"tags":[]},{"title":"mongo数据库角色","slug":"技术学习/Mongo/mongo数据库角色","date":"2021-07-26T03:23:17.302Z","updated":"2021-08-10T15:50:08.228Z","comments":true,"path":"post/1323723771.html","link":"","permalink":"https://dd-code.site/post/1323723771.html","excerpt":"","text":"内建的角色数据库用户角色：read、readWrite;数据库管理角色：dbAdmin、dbOwner、userAdmin；集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；备份恢复角色：backup、restore；所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase超级用户角色：root // 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）内部角色：__system 角色说明：Read：允许用户读取指定数据库readWrite：允许用户读写指定数据库dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profileuserAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。root：只在admin数据库中可用。超级账号，超级权限 参考资料： 官方详情角色说明：https://docs.mongodb.com/manual/reference/built-in-roles/ 官方配置文件实例：https://docs.mongodb.com/manual/reference/configuration-options/ MongoDB学习笔记—权限管理：https://www.cnblogs.com/hanyinglong/p/5704320.html","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Mongo","slug":"技术学习/Mongo","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Mongo/"}],"tags":[]},{"title":"一个很好地leetcode项目","slug":"技术学习/LeetCode/一个很好的leetcode项目","date":"2021-07-26T03:23:17.301Z","updated":"2021-08-10T15:49:54.522Z","comments":true,"path":"post/3220316175.html","link":"","permalink":"https://dd-code.site/post/3220316175.html","excerpt":"","text":"项目地址https://github.com/doocs/leetcode","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"LeetCode","slug":"技术学习/LeetCode","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/LeetCode/"}],"tags":[]},{"title":"Docker相关命令","slug":"技术学习/Docker/Docker相关命令","date":"2021-07-26T03:23:17.301Z","updated":"2021-08-10T15:49:37.278Z","comments":true,"path":"post/564644262.html","link":"","permalink":"https://dd-code.site/post/564644262.html","excerpt":"","text":"查看 docker 的所有命令 1docker 更深入查看 docker 命令的使用方法和作用 1docker command --help 获取镜像（载入 ubuntu 镜像） 1docker pull ubuntu 使用 ubuntu 镜像启动容器，并且参数以命令模式进入该容器 1docker run it ubuntu /bin/bash 参数说明： -i：交互时操作 -t：终端 ubuntu：ubuntu 镜像 /bin/bash：放在镜像后边是命令，交互式的 shell 进入容器后，退出容器 1exit 查看所有容器 1docker ps -a 查看正在运行的容器 1docker ps 启动一个停止的容器 1docker start 容器id 后台运行 docker 容器 1docker run -itd -name 容器自定义名字 镜像名称 /bin/bsah 停止一个容器 1docker stop 容器id 重启一个容器 1docker restart 容器id 进入一个容器 1docker attach 容器id 退出容器（推荐使用 docker exec ，因为这个命令退出容器，不会导致容器停止） 12docker exexdocker exec -it 容器id /bin/bash 导出容器 1docker export 容器id &gt; 名称.tar 导入容器快照 以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1: 1cat docker/名称.tar | docker import - test/ubuntu:v1 通过指定 URL 或者 目录导入 1docker import http://example.com/exampleimage.tgz example/imagerepo 删除容器 1docker rm -f 容器id 强制删除无法删除的容器 1docker rmi -f 容器id 参考文章： https://www.runoob.com/docker/docker-container-usage.html ​","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Docker","slug":"技术学习/Docker","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Docker/"}],"tags":[]},{"title":"Docker命令详解（run篇）","slug":"技术学习/Docker/Docker命令详解（run篇）","date":"2021-07-26T03:23:17.300Z","updated":"2021-08-10T15:49:33.806Z","comments":true,"path":"post/2104589309.html","link":"","permalink":"https://dd-code.site/post/2104589309.html","excerpt":"","text":"命令格式：docker run [OPTIONS] IMAGE [COMMAND] [ARG...]Usage: Run a command in a new container中文意思为：通过run命令创建一个新的容器（container） 常用选项说明 -d, --detach=false， 指定容器运行于前台还是后台，默认为false -i, --interactive=false， 打开STDIN，用于控制台交互 -t, --tty=false， 分配tty设备，该可以支持终端登录，默认为false -u, --user=&quot;&quot;， 指定容器的用户 -a, --attach=[]， 登录容器（必须是以docker run -d启动的容器） -w, --workdir=&quot;&quot;， 指定容器的工作目录 -c, --cpu-shares=0， 设置容器CPU权重，在CPU共享场景使用 -e, --env=[]， 指定环境变量，容器中可以使用该环境变量 -m, --memory=&quot;&quot;， 指定容器的内存上限 -P, --publish-all=false， 指定容器暴露的端口 -p, --publish=[]， 指定容器暴露的端口 -h, --hostname=&quot;&quot;， 指定容器的主机名 -v, --volume=[]， 给容器挂载存储卷，挂载到容器的某个目录 --volumes-from=[]， 给容器挂载其他容器上的卷，挂载到容器的某个目录 --cap-add=[]， 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities --cap-drop=[]， 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities --cidfile=&quot;&quot;， 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法 --cpuset=&quot;&quot;， 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU --device=[]， 添加主机设备给容器，相当于设备直通 --dns=[]， 指定容器的dns服务器 --dns-search=[]， 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件 --entrypoint=&quot;&quot;， 覆盖image的入口点 --env-file=[]， 指定环境变量文件，文件格式为每行一个环境变量 --expose=[]， 指定容器暴露的端口，即修改镜像的暴露端口 --link=[]， 指定容器间的关联，使用其他容器的IP、env等信息 --lxc-conf=[]， 指定容器的配置文件，只有在指定–exec-driver=lxc时使用 --name=&quot;&quot;， 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字 --net=&quot;bridge&quot;， 容器网络设置: bridge 使用docker daemon指定的网桥 host //容器使用主机的网络 container:NAME_or_ID &gt;//使用其他容器的网路，共享IP和PORT等网络资源 none 容器使用自己的网络（类似–net=bridge），但是不进行配置 --privileged=false， 指定容器是否为特权容器，特权容器拥有所有的capabilities --restart=&quot;no&quot;， 指定容器停止后的重启策略: no：容器退出时不重启 on-failure：容器故障退出（返回值非零）时重启 always：容器退出时总是重启 --rm=false， 指定容器停止后自动删除容器(不支持以docker run -d启动的容器) --sig-proxy=true， 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理 示例 运行一个在后台执行的容器，同时，还能用控制台管理： 1docker run -i -t -d ubuntu:latest 运行一个带命令在后台不断执行的容器，不直接展示容器内部信息： 1docker run -d ubuntu:latest ping www.docker.com 运行一个在后台不断执行的容器，同时带有命令，程序被终止后还能重启继续跑，还能用控制台管理： 1docker run -d --restart=always ubuntu:latest ping www.docker.com 为容器指定一个名字： 1docker run -d --name=ubuntu_server ubuntu:latest 容器暴露80端口，并指定宿主机80端口与其通信(: 之前是宿主机端口，之后是容器需暴露的端口)： 1docker run -d --name=ubuntu_server -p 80:80 ubuntu:latest 指定容器内目录与宿主机目录共享(: 之前是宿主机文件夹，之后是容器需共享的文件夹) 1docker run -d --name=ubuntu_server -v /etc/www:/var/www ubuntu:latest","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Docker","slug":"技术学习/Docker","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Docker/"}],"tags":[]},{"title":"优秀的博主站点","slug":"分享收藏/优秀的博主站点","date":"2021-07-26T03:23:17.295Z","updated":"2021-07-26T03:23:17.295Z","comments":true,"path":"post/1628566266.html","link":"","permalink":"https://dd-code.site/post/1628566266.html","excerpt":"","text":"风雪之隅-左手代码右手诗 作者：Laruence，人称 “鸟哥” 简介：PHP开发组核心成员, Zend顾问, PHP7及PHP8 JIT核心作者. Yaf等开源项目作者 飞雪无情的博客 作者：飞雪无情 简介：专注于Android、Java、Go语言(golang)、移动互联网、项目管理、软件架构，《Go 实战笔记》系列作者，《Golang Gin 实战》系列作者，《Android Gradle权威指南》作者，现负责技术管理。 公众号：飞雪无情 煎鱼 作者：煎鱼 简介：沉迷于 Go、Kubernetes、Prometheus ，在工作中，目前主要负责公司的基础架构/组件的建设和业务团队推广 公众号：脑子进煎鱼了 信春哥，系统稳，闭眼上线不回滚！ 作者：宋春风 简介：BI168社区ORACLE管理版版主(http://www.bi168.cn)，拥有ORACLE 10g、11g OCP，10g OCM，Golden Gate 10g OCS等证书，现就职某大型电商，担任ORACLE DBA职务； 前端杂货铺 后端进阶 – 每一步成长都想与你分享 作者：zhangchenghui 简介：微信公众号「后端进阶」，专注后端技术分享：Java、Golang、WEB框架、分布式中间件、服务治理等等，老司机倾囊相授，带你一路进阶，来不及解释了快上车！ https://stitcher.io 姓名：布伦特（Brent） 简介：一个老外技术，博客质量还可以 https://www.bruceeckel.com 姓名：布鲁斯·埃克尔（Bruce Eckel）的编程博客 简介：一个老外技术的编程博客，涉及 Java，基本知识 https://www.itsolutionstuff.com 姓名：itsolutionstuff 简介：一个老外技术，涉及 PHP，Laravel，Angular https://jessequinn.info/ 姓名：杰西·奎因的个人网站 简介：一个老外的博客，涉及Java，大数据，k8s，值得一看 XXX XXX XXX","categories":[{"name":"分享收藏","slug":"分享收藏","permalink":"https://dd-code.site/categories/%E5%88%86%E4%BA%AB%E6%94%B6%E8%97%8F/"}],"tags":[]},{"title":"架构图模板","slug":"分享收藏/系统架构图模板","date":"2021-07-26T03:23:17.295Z","updated":"2021-07-26T03:23:17.295Z","comments":true,"path":"post/651811465.html","link":"","permalink":"https://dd-code.site/post/651811465.html","excerpt":"","text":"系统架构图系统架构图2.0 通用项目分层结构项目分层结构图 针对某某支付公司产品线，再结合自身所在的支付公司梳理的系统架构图。FYI、支付公司技术产品线 阿里巴巴数据中台全景图阿里巴巴数据中台全景图 网络架构图网络拓扑图","categories":[{"name":"分享收藏","slug":"分享收藏","permalink":"https://dd-code.site/categories/%E5%88%86%E4%BA%AB%E6%94%B6%E8%97%8F/"}],"tags":[]},{"title":"不错的在线学习平台","slug":"分享收藏/不错的在线学习平台","date":"2021-07-26T03:23:17.294Z","updated":"2021-07-26T03:23:17.294Z","comments":true,"path":"post/2127643338.html","link":"","permalink":"https://dd-code.site/post/2127643338.html","excerpt":"","text":"Udemy 简介：全球最多的课程选择，任选 130000 门在线视频课程，每月都有新内容发布，涉及Python、Excel、网页开发、JavaScript、数据科学、AWS认证、绘图。具体类别有：开发、商务、财务会计、IT与软件、工作效率、个人发展、涉及、市场营销、生活习俗、摄影与录像、健康与健身、音乐、数学和艺术。 coursera 简介：借助来自世界级大学和公司的在线课程、证书与学位，培养卓越技能。涉及数据科学、商务、计算机科学、信息技术、语言学习、健康、个人发展、物理科学与工程、社会科学、艺术与人文、数学和逻辑。有部分免费课程可供学习。 XXX XXX","categories":[{"name":"分享收藏","slug":"分享收藏","permalink":"https://dd-code.site/categories/%E5%88%86%E4%BA%AB%E6%94%B6%E8%97%8F/"}],"tags":[]},{"title":"在Mac上使用Homebrew升级到PHP7.4","slug":"编程语言/PHP/在Mac上使用Homebrew升级到PHP7.4","date":"2021-07-26T03:23:17.290Z","updated":"2021-08-10T15:52:24.659Z","comments":true,"path":"post/2844724790.html","link":"","permalink":"https://dd-code.site/post/2844724790.html","excerpt":"","text":"用brew升级首先要确保 Brew 是最新的： 1brew update 接下来，升级 PHP： 1brew upgrade php 通过运行php -v以下命令检查当前版本： 1php -v 重新启动 Nginx 或 Apache： 12sudo nginx -s reloadsudo apachectl restart 并通过访问以下脚本确保本地 Web 服务器也使用 PHP 7.4： 12# index.php, accessible to your web serverphpinfo(); die(); 版本应显示7.4.x。 注意：如果您使用的是 Laravel Valet，请继续阅读，您需要一些额外的步骤才能使Web服务器正常工作。 ＃Valet如果您使用的是 Laravel Valet，则应执行以下步骤对其进行升级： 1composer global update 现在运行valet install： 1valet install ＃peclHomebrew 不再支持 PHP 扩展的安装，您应该使用 pecl 代替。我个人使用 Imagick，Redis 和 Xdebug。 它们可以像这样安装： 123pecl install imagickpecl install redispecl install xdebug 您可以运行pecl list以查看安装了哪些扩展： 1234567pecl list# Installed packages, channel pecl.php.net:# =========================================# Package Version State# imagick 3.4.4 stable# redis 5.1.1 stable# xdebug 2.8.0 stable 您可以使用来搜索其他扩展名pecl search： 1234567pecl search pdf# Retrieving data...0%# ..# Matched packages, channel pecl.php.net:# =======================================# Package Stable/(Latest) Local# pdflib 4.1.2 (stable) Creating PDF on the fly with the PDFlib library 安装新软件包后，请确保重新启动Web服务器： 12sudo nginx -s reloadsudo apachectl restart 如果您使用的是 Laravel Valet，则也应重新启动它。 1valet restart 通过检查 PHP Web 服务器和 CLI 安装，确保正确安装和加载了所有扩展： 12php -i | grep redisvar_dump(extension_loaded(&#x27;redis&#x27;)); 如果扩展未正确加载，则有两个简单的修复程序。 首先，请确保将扩展名添加到正确的 ini 文件中。您可以运行php --ini以了解加载了哪个文件： 12345Configuration File (php.ini) Path: /usr/local/etc/php/7.4Loaded Configuration File: /usr/local/etc/php/7.4/php.iniScan for additional .ini files in: /usr/local/etc/php/7.4/conf.dAdditional .ini files parsed: /usr/local/etc/php/7.4/conf.d/ext-opcache.ini,/usr/local/etc/php/7.4/conf.d/php-memory-limits.ini 现在检查 ini 文件： 123extension=&quot;redis.so&quot;extension=&quot;imagick.so&quot;extension=&quot;xdebug.so&quot; 请注意，如果您正在通过 CLI 测试已安装的扩展，则无需重新启动 nginx，apache 或 Valet。 如果要从也使用 pecl 安装扩展程序的旧 PHP 版本进行更新，则可以做第二件事。是分别重新安装每个扩展。 12pecl uninstall imagickpecl install imagick ＃最后一步最后，您应该测试和升级项目以实现 PHP 7.4兼容性。 本文摘录自：https://stitcher.io/blog/php-74-upgrade-mac ​","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"如何使用brew安装多个PHP版本","slug":"编程语言/PHP/如何使用brew安装多个PHP版本","date":"2021-07-26T03:23:17.290Z","updated":"2021-08-10T15:52:24.656Z","comments":true,"path":"post/3712615104.html","link":"","permalink":"https://dd-code.site/post/3712615104.html","excerpt":"","text":"一 安装7.1 安装PHP7.1 1brew install php@7.1 修改配置 php-fpm.conf,一般在/usr/local/etc/php下(如果php-fpm.conf中不存在，则查找php-fpm.d目录) 1vim php-fpm.conf&#96; &#96;listen &#x3D; 127.0.0.1:9000 启动PHP7.1 1brew services start php@7.1 这时php-fpm会监听9000端口，修改nginx的配置文件改为端口为9000(一般在/usr/local/etc/nginx/下面) 1vim nginx.conf&#96; &#96;fastcgi_pass 127.0.0.1:9000 启动nginx服务 1#启动 brew services start nginx&#96; &#96;#重启 brew services restart nginx 查看当前版本 1php -v 二 安装并切换7.2 清除PHP7.1的软链 1brew unlink php@7.1 安装PHP7.2 1brew install php@7.2 添加PHP7.2的软链 1brew link php@7.2 修改配置 php-fpm.conf 1vim php-fpm.conf&#96; &#96;listen &#x3D; 127.0.0.1:9001 启动PHP7.2 1brew services start php@7.2 修改nginx配置 1vim nginx.conf&#96; &#96;fastcgi_pass 127.0.0.1:9001 重启nginx服务 1brew services restart nginx 查看当前版本 1php -v 9.修改环境变量 1vi ~&#x2F;.bash_profile 10.重新刷新环境变量 1source ~&#x2F;.bash_profile 以上就是这次的全部内容 ！ ​","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP的垃圾回收机制","slug":"编程语言/PHP/PHP的垃圾回收机制","date":"2021-07-26T03:23:17.289Z","updated":"2021-08-10T15:52:24.851Z","comments":true,"path":"post/512206887.html","link":"","permalink":"https://dd-code.site/post/512206887.html","excerpt":"","text":"资料： 引用计数基本知识 回收周期(Collecting Cycles) 性能方面考虑的因素 官方文档：https://www.php.net/manual/zh/features.gc.php","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP自动加载机制","slug":"编程语言/PHP/PHP自动加载机制","date":"2021-07-26T03:23:17.289Z","updated":"2021-08-10T15:52:24.656Z","comments":true,"path":"post/3981571320.html","link":"","permalink":"https://dd-code.site/post/3981571320.html","excerpt":"","text":"类的载入共经历了三个阶段： 第一阶段是面向过程式的做法，整个项目里到处都是include或require 第二阶段是魔术方法 __autoload ，当new一个类的时候，如果类不存在，则会调用此方法传入类名。autoload机制可以使得PHP程序在使用类时才自动包含文件，而不是一开始就将所有的类文件全部包含，这就是自动加载， ​ 问题：如今的项目越做越大，多人开发最终整合，甚至一个项目使用多个框架，这样就导致出现多个 __autoload 函数，函数名报错，函数内容不兼容。 第三阶段是目前的做法，PHP推出了spl_autoload_register方法，该方法可以注册一个autoload，并且可以多次注册 详细参考：https://www.cnblogs.com/fengyumeng/p/7749988.html","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"self和$this的区别","slug":"编程语言/PHP/self和$this的区别","date":"2021-07-26T03:23:17.289Z","updated":"2021-08-10T15:52:24.856Z","comments":true,"path":"post/137484498.html","link":"","permalink":"https://dd-code.site/post/137484498.html","excerpt":"","text":"最主要的区别是self代表的是类, $this代表的是对象 静态成员是给类调用的, 不是给 $this 调用的 类外部：访问const(常量)或static(静态)修饰的成员, 必须使用 :: 操作符, 除此之外的成员必须使用操作符 -&gt; 类内部：访问const(常量)或static(静态)修饰的成员, 必须使用 self:: 操作符, 除此之外的成员必须使用操作符 $this-&gt; 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Animal&#123; public $name = &#x27;Animal&#x27;; public static $age = 10; public function myPrint() &#123;// Animal echo $this-&gt;name;// 10 echo self::$age;// 10 特殊用法, 允许使用 $this::$age 替代 self::$age echo $this::$age; &#125;&#125;// 类的外部访问// 10echo Animal::$age;$animal = new Animal;// Animalecho $animal-&gt;name;// 类的内部访问// Animal 10 10$animal-&gt;myPrint();","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP的垃圾回收机制-引用计数","slug":"编程语言/PHP/PHP的垃圾回收机制-引用计数","date":"2021-07-26T03:23:17.288Z","updated":"2021-08-10T15:52:24.851Z","comments":true,"path":"post/2776614029.html","link":"","permalink":"https://dd-code.site/post/2776614029.html","excerpt":"","text":"引用计数基本知识每个php变量存在一个叫”zval”的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。第一个是”is_ref”，是个bool值，用来标识这个变量是否是属于引用集合(reference set)。通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于php允许用户通过使用&amp;来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。第二个额外字节是”refcount”，用以表示指向这个zval变量容器的变量(也称符号即symbol)个数。所有的符号存在一个符号表中，其中每个符号都有作用域(scope)，那些主脚本(比如：通过浏览器请求的的脚本)和每个函数或者方法也都有作用域。 当一个变量被赋常量值时，就会生成一个zval变量容器，如下例这样： Example #1 生成一个新的zval容器 1&lt;?php$a = &quot;new string&quot;;?&gt; 在上例中，新的变量a，是在当前作用域中生成的。并且生成了类型为 string 和值为new string的变量容器。在额外的两个字节信息中，”is_ref”被默认设置为 FALSE，因为没有任何自定义的引用生成。”refcount” 被设定为 1，因为这里只有一个变量使用这个变量容器. 注意到当”refcount”的值是1时，”is_ref”的值总是FALSE. 如果你已经安装了» Xdebug，你能通过调用函数 **xdebug_debug_zval()**显示”refcount”和”is_ref”的值。 Example #2 显示zval信息 1&lt;?phpxdebug_debug_zval(&#x27;a&#x27;);?&gt; 以上例程会输出： 1a: (refcount=1, is_ref=0)=&#x27;new string&#x27; 把一个变量赋值给另一变量将增加引用次数(refcount). Example #3 增加一个zval的引用计数 1&lt;?php$a = &quot;new string&quot;;$b = $a;xdebug_debug_zval( &#x27;a&#x27; );?&gt; 以上例程会输出： 1a: (refcount=2, is_ref=0)=&#x27;new string&#x27; 这时，引用次数是2，因为同一个变量容器被变量 a 和变量 b关联.当没必要时，php不会去复制已生成的变量容器。变量容器在”refcount“变成0时就被销毁. 当任何关联到某个变量容器的变量离开它的作用域(比如：函数执行结束)，或者对变量调用了函数 unset()时，”refcount“就会减1，下面的例子就能说明: Example #4 减少引用计数 1&lt;?php$a = &quot;new string&quot;;$c = $b = $a;xdebug_debug_zval( &#x27;a&#x27; );unset( $b, $c );xdebug_debug_zval( &#x27;a&#x27; );?&gt; 以上例程会输出： 12a: (refcount=3, is_ref=0)=&#x27;new string&#x27;a: (refcount=1, is_ref=0)=&#x27;new string&#x27; 如果我们现在执行 unset($a);，包含类型和值的这个变量容器就会从内存中删除。 复合类型(Compound Types)当考虑像 array和object这样的复合类型时，事情就稍微有点复杂. 与 标量(scalar)类型的值不同，array和 object类型的变量把它们的成员或属性存在自己的符号表中。这意味着下面的例子将生成三个zval变量容器。 Example #5 Creating a array zval 1&lt;?php$a = array( &#x27;meaning&#x27; =&gt; &#x27;life&#x27;, &#x27;number&#x27; =&gt; 42 );xdebug_debug_zval( &#x27;a&#x27; );?&gt; 以上例程的输出类似于： 1234a: (refcount=1, is_ref=0)=array ( &#x27;meaning&#x27; =&gt; (refcount=1, is_ref=0)=&#x27;life&#x27;, &#x27;number&#x27; =&gt; (refcount=1, is_ref=0)=42) 图示: 这三个zval变量容器是: a，meaning和 number。增加和减少”refcount”的规则和上面提到的一样. 下面, 我们在数组中再添加一个元素,并且把它的值设为数组中已存在元素的值: Example #6 添加一个已经存在的元素到数组中 1&lt;?php$a = array( &#x27;meaning&#x27; =&gt; &#x27;life&#x27;, &#x27;number&#x27; =&gt; 42 );$a[&#x27;life&#x27;] = $a[&#x27;meaning&#x27;];xdebug_debug_zval( &#x27;a&#x27; );?&gt; 以上例程的输出类似于： 12345a: (refcount=1, is_ref=0)=array ( &#x27;meaning&#x27; =&gt; (refcount=2, is_ref=0)=&#x27;life&#x27;, &#x27;number&#x27; =&gt; (refcount=1, is_ref=0)=42, &#x27;life&#x27; =&gt; (refcount=2, is_ref=0)=&#x27;life&#x27;) 图示： 从以上的xdebug输出信息，我们看到原有的数组元素和新添加的数组元素关联到同一个”refcount”2的zval变量容器. 尽管 Xdebug的输出显示两个值为&#39;life&#39;的 zval 变量容器，其实是同一个。 函数**xdebug_debug_zval()**不显示这个信息，但是你能通过显示内存指针信息来看到。 删除数组中的一个元素，就是类似于从作用域中删除一个变量. 删除后,数组中的这个元素所在的容器的“refcount”值减少，同样，当“refcount”为0时，这个变量容器就从内存中被删除，下面又一个例子可以说明： Example #7 从数组中删除一个元素 1&lt;?php$a = array( &#x27;meaning&#x27; =&gt; &#x27;life&#x27;, &#x27;number&#x27; =&gt; 42 );$a[&#x27;life&#x27;] = $a[&#x27;meaning&#x27;];unset( $a[&#x27;meaning&#x27;], $a[&#x27;number&#x27;] );xdebug_debug_zval( &#x27;a&#x27; );?&gt; 以上例程的输出类似于： 123a: (refcount=1, is_ref=0)=array ( &#x27;life&#x27; =&gt; (refcount=1, is_ref=0)=&#x27;life&#x27;) 现在，当我们添加一个数组本身作为这个数组的元素时，事情就变得有趣，下个例子将说明这个。例中我们加入了引用操作符，否则php将生成一个复制。 Example #8 把数组作为一个元素添加到自己 1&lt;?php$a = array( &#x27;one&#x27; );$a[] =&amp; $a;xdebug_debug_zval( &#x27;a&#x27; );?&gt; 以上例程的输出类似于： 1234a: (refcount=2, is_ref=1)=array ( 0 =&gt; (refcount=1, is_ref=0)=&#x27;one&#x27;, 1 =&gt; (refcount=2, is_ref=1)=...) 图示： 能看到数组变量 (a) 同时也是这个数组的第二个元素(1) 指向的变量容器中“refcount”为 2。上面的输出结果中的”…”说明发生了递归操作, 显然在这种情况下意味着”…”指向原始数组。 跟刚刚一样，对一个变量调用unset，将删除这个符号，且它指向的变量容器中的引用次数也减1。所以，如果我们在执行完上面的代码后，对变量$a调用unset, 那么变量 $a 和数组元素 “1” 所指向的变量容器的引用次数减1, 从”2”变成”1”. 下例可以说明: Example #9 Unsetting $a 1234(refcount=1, is_ref=1)=array ( 0 =&gt; (refcount=1, is_ref=0)=&#x27;one&#x27;, 1 =&gt; (refcount=1, is_ref=1)=...) 图示： 清理变量容器的问题(Cleanup Problems)尽管不再有某个作用域中的任何符号指向这个结构(就是变量容器)，由于数组元素“1”仍然指向数组本身，所以这个容器不能被清除 。因为没有另外的符号指向它，用户没有办法清除这个结构，结果就会导致内存泄漏。庆幸的是，php将在脚本执行结束时清除这个数据结构，但是在php清除之前，将耗费不少内存。如果你要实现分析算法，或者要做其他像一个子元素指向它的父元素这样的事情，这种情况就会经常发生。当然，同样的情况也会发生在对象上，实际上对象更有可能出现这种情况，因为对象总是隐式的被引用。 如果上面的情况发生仅仅一两次倒没什么，但是如果出现几千次，甚至几十万次的内存泄漏，这显然是个大问题。这样的问题往往发生在长时间运行的脚本中，比如请求基本上不会结束的守护进程(deamons)或者单元测试中的大的套件(sets)中。后者的例子：在给巨大的eZ(一个知名的PHP Library) 组件库的模板组件做单元测试时，就可能会出现问题。有时测试可能需要耗用2GB的内存，而测试服务器很可能没有这么大的内存。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP的垃圾回收机制-性能方面考虑的因素","slug":"编程语言/PHP/PHP的垃圾回收机制-性能方面考虑的因素","date":"2021-07-26T03:23:17.288Z","updated":"2021-08-10T15:52:24.851Z","comments":true,"path":"post/2943915566.html","link":"","permalink":"https://dd-code.site/post/2943915566.html","excerpt":"","text":"性能方面考虑的因素在上一节我们已经简单的提到：回收可能根有细微的性能上影响，但这是把PHP 5.2与PHP 5.3比较时才有的。尽管在PHP 5.2中，记录可能根相对于完全不记录可能根要慢些，而PHP 5.3中对 PHP run-time 的其他修改减少了这个性能损失。 这里主要有两个领域对性能有影响。第一个是内存占用空间的节省，另一个是垃圾回收机制执行内存清理时的执行时间增加(run-time delay)。我们将研究这两个领域。 内存占用空间的节省首先，实现垃圾回收机制的整个原因是为了，一旦先决条件满足，通过清理循环引用的变量来节省内存占用。在PHP执行中，一旦根缓冲区满了或者调用gc_collect_cycles() 函数时，就会执行垃圾回收。在下图中，显示了下面脚本分别在PHP 5.2 和 PHP 5.3环境下的内存占用情况，其中排除了脚本启动时PHP本身占用的基本内存。 Example #1 Memory usage example 123456789101112131415161718&lt;?phpclass Foo&#123; public $var = &#x27;3.1415962654&#x27;;&#125;$baseMemory = memory_get_usage();for ( $i = 0; $i &lt;= 100000; $i++ )&#123; $a = new Foo; $a-&gt;self = $a; if ( $i % 500 === 0 ) &#123; echo sprintf( &#x27;%8d: &#x27;, $i ), memory_get_usage() - $baseMemory, &quot;\\n&quot;; &#125;&#125;?&gt; 在这个很理论性的例子中，我们创建了一个对象，这个对象中的一个属性被设置为指回对象本身。在循环的下一个重复(iteration)中，当脚本中的变量被重新复制时，就会发生典型性的内存泄漏。在这个例子中，两个变量容器是泄漏的(对象容器和属性容器)，但是仅仅能找到一个可能根：就是被unset的那个变量。在10,000次重复后(也就产生总共10,000个可能根)，当根缓冲区满时，就执行垃圾回收机制，并且释放那些关联的可能根的内存。这从PHP 5.3的锯齿型内存占用图中很容易就能看到。每次执行完10,000次重复后，执行垃圾回收，并释放相关的重复使用的引用变量。在这个例子中由于泄漏的数据结构非常简单，所以垃圾回收机制本身不必做太多工作。从这个图表中，你能看到 PHP 5.3的最大内存占用大概是9 Mb，而PHP 5.2的内存占用一直增加。 执行时间增加(Run-Time Slowdowns)垃圾回收影响性能的第二个领域是它释放已泄漏的内存耗费的时间。为了看到这个耗时时多少，我们稍微改变了上面的脚本，有更多次数的重复并且删除了循环中的内存占用计算，第二个脚本代码如下： Example #2 GC性能影响 123456789101112131415&lt;?phpclass Foo&#123; public $var = &#x27;3.1415962654&#x27;;&#125;for ( $i = 0; $i &lt;= 1000000; $i++ )&#123; $a = new Foo; $a-&gt;self = $a;&#125;echo memory_get_peak_usage(), &quot;\\n&quot;;?&gt; 我们将运行这个脚本两次，一次通过配置zend.enable_gc打开垃圾回收机制时，另一次是它关闭时。 Example #3 执行以上脚本 123time php -dzend.enable_gc=0 -dmemory_limit=-1 -n example2.php# andtime php -dzend.enable_gc=1 -dmemory_limit=-1 -n example2.php 在我的机器上，第一个命令持续执行时间大概为10.7秒，而第二个命令耗费11.4秒。时间上增加了7%。然而，执行这个脚本时内存占用的峰值降低了98%，从931Mb 降到 10Mb。这个基准不是很科学，或者并不能代表真实应用程序的数据，但是它的确显示了垃圾回收机制在内存占用方面的好处。好消息就是，对这个脚本而言，在执行中出现更多的循环引用变量时，内存节省的更多的情况下，每次时间增加的百分比都是7%。 PHP内部 GC 统计信息在PHP内部，可以显示更多的关于垃圾回收机制如何运行的信息。但是要显示这些信息，你需要先重新编译PHP使benchmark和data-collecting code可用。你需要在按照你的意愿运行./configure前，把环境变量CFLAGS设置成-DGC_BENCH=1。下面的命令串就是做这个事： Example #4 重新编译PHP以启用GC benchmarking 1234export CFLAGS=-DGC_BENCH=1./config.nicemake cleanmake 当你用新编译的PHP二进制文件来重新执行上面的例子代码，在PHP执行结束后，你将看到下面的信息： Example #5 GC 统计数据 123456789101112GC Statistics-------------Runs: 110Collected: 2072204Root buffer length: 0Root buffer peak: 10000 Possible Remove from Marked Root Buffered buffer grey -------- -------- ----------- ------ZVAL 7175487 1491291 1241690 3611871ZOBJ 28506264 1527980 677581 1025731 主要的信息统计在第一个块。你能看到垃圾回收机制运行了110次，而且在这110次运行中，总共有超过两百万的内存分配被释放。只要垃圾回收机制运行了至少一次，根缓冲区峰值(Root buffer peak)总是10000. 结论通常，PHP中的垃圾回收机制，仅仅在循环回收算法确实运行时会有时间消耗上的增加。但是在平常的(更小的)脚本中应根本就没有性能影响。 然而，在平常脚本中有循环回收机制运行的情况下，内存的节省将允许更多这种脚本同时运行在你的服务器上。因为总共使用的内存没达到上限。 这种好处在长时间运行脚本中尤其明显，诸如长时间的测试套件或者daemon脚本此类。同时，对通常比Web脚本运行时间长的» PHP-GTK应用程序，新的垃圾回收机制，应该会大大改变一直以来认为内存泄漏问题难以解决的看法。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP控制反转（IOC）和依赖注入（DI）","slug":"编程语言/PHP/PHP控制反转(IOC)和依赖注入(DI)","date":"2021-07-26T03:23:17.287Z","updated":"2021-08-10T15:52:24.856Z","comments":true,"path":"post/2916108243.html","link":"","permalink":"https://dd-code.site/post/2916108243.html","excerpt":"","text":"对于“控制反转（IOC）”和“依赖注入（DI）”两个概念，首先要明白以下概念： 控制反转（IOC）是一种思想，依赖注入（DI）是实施这种思想的方法； IOC 意味着将你设计好的对象交给容器控制，而不是传统的在对象内部控制； 依赖注入（DI）实现了控制反转（IOC）； 依赖注入的实现一：接口注入1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?php/** * 定义一个消息接口 * Interface Message */interface Message&#123; public function send();&#125;/** * 发送邮件的消息类 * Class SendEmail */class SendEmail implements Message&#123; public function send() &#123; echo &quot;email 发送成功！&quot;; &#125;&#125;/** * 发送短信的消息类 * Class SendSms */class SendSms implements Message&#123; public function send() &#123; echo &quot;sms 发送成功！&quot;; &#125;&#125;/** * 模拟购买流程 * Class Order */class Order&#123; //TODO::下单 //TODO::购买 //发送消息 /** * @var String 消息内容 */ protected String $message; function __construct(Message $message) &#123; $this-&gt;message = $message; &#125; public function send_msg() &#123; return $this-&gt;message-&gt;send(); &#125;&#125;//TODO::比如购买成功了，这里开始发送消息$message = new SendEmail();//发送邮件//$message = new SendEmail();//发送短信$order = new Order($message);$order-&gt;send_msg(); 分析Order 类依赖消息类的 Message 接口 1$order = new Order($message); 具体的消息类实例化交给外部处理，不论你是发送短信还是邮件，你自己实例化就好，不要影响我的 Order 类，你只需要把 Message 的接口实现类给我就好 1234$message = new SendEmail();//发送邮件//$message = new SendEmail();//发送短信$order = new Order($message); $order-&gt;send_msg(); 二：构造器注入1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php/** * 构造器注入 * 定义一个有构造函数的类 * Class IocB */class iocAA&#123; public $b; public $c; public function __construct($iocB, $iocC) &#123; $this-&gt;b = $iocB; $this-&gt;c = $iocC; &#125; public function Method() &#123; $this-&gt;b-&gt;Method(); $this-&gt;c-&gt;Method(); &#125;&#125;class IocB&#123; public function Method() &#123; echo &#x27;我是 IocB 的 Method 方法&#x27;; &#125;&#125;class IocC&#123; public function Method() &#123; echo &#x27;我是 IocC 的 Method 方法&#x27;; &#125;&#125;$a = new iocAA(new IocB(), new IocC());$a-&gt;Method(); 分析进行实例化类的时候，对构造函数的两个参数进行实例化赋值（将实例化后的对象赋值给 iocAA 类 的两个属性） 1$a = new iocAA(new IocB(), new IocC()); 然后调用对象的方法即可 1$a-&gt;Method(); 三：setter 方法注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpclass IocC&#123; private $db; private $file; function setDb($db) &#123; $this-&gt;db = $db; &#125; function setFile($file) &#123; $this-&gt;file = $file; &#125;&#125;class file&#123; public function __construct() &#123; echo &quot;file 的 构造函数执行了&quot; . &quot;\\n&quot;; &#125; public function run() &#123; echo &quot;file 的 run&quot; . &quot;\\n&quot;; &#125;&#125;class db&#123; public function __construct() &#123; echo &quot;db 的 构造函数执行了&quot; . &quot;\\n&quot;; &#125; public function run() &#123; echo &quot;db 的 run&quot; . &quot;\\n&quot;; &#125;&#125;$iocC = new IocC();$iocC-&gt;setdb(new db());$iocC-&gt;setfile(new file()); 分析先实例化 IocC 类 1$iocC = new IocC(); 接着调用 IocC 类的方法使用，调用 IocC 的方法 setDb 和 setFile 的时候，需要把实例化的对象当做参数传进去 12$iocC-&gt;setdb(new db());$iocC-&gt;setfile(new file());","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP的垃圾回收机制-回收周期","slug":"编程语言/PHP/PHP的垃圾回收机制-回收周期","date":"2021-07-26T03:23:17.287Z","updated":"2021-08-10T15:52:24.659Z","comments":true,"path":"post/1247192045.html","link":"","permalink":"https://dd-code.site/post/1247192045.html","excerpt":"","text":"回收周期(Collecting Cycles)传统上，像以前的 php 用到的引用计数内存机制，无法处理循环的引用内存泄漏。然而 5.3.0 PHP 使用文章» 引用计数系统中的同步周期回收(Concurrent Cycle Collection in Reference Counted Systems)中的同步算法，来处理这个内存泄漏问题。 对算法的完全说明有点超出这部分内容的范围，将只介绍其中基础部分。首先，我们先要建立一些基本规则，如果一个引用计数增加，它将继续被使用，当然就不再在垃圾中。如果引用计数减少到零，所在变量容器将被清除(free)。就是说，仅仅在引用计数减少到非零值时，才会产生垃圾周期(garbage cycle)。其次，在一个垃圾周期中，通过检查引用计数是否减1，并且检查哪些变量容器的引用次数是零，来发现哪部分是垃圾。 为避免不得不检查所有引用计数可能减少的垃圾周期，这个算法把所有可能根(possible roots 都是zval变量容器),放在根缓冲区(root buffer)中(用紫色来标记，称为疑似垃圾)，这样可以同时确保每个可能的垃圾根(possible garbage root)在缓冲区中只出现一次。仅仅在根缓冲区满了时，才对缓冲区内部所有不同的变量容器执行垃圾回收操作。看上图的步骤 A。 在步骤 B 中，模拟删除每个紫色变量。模拟删除时可能将不是紫色的普通变量引用数减”1”，如果某个普通变量引用计数变成0了，就对这个普通变量再做一次模拟删除。每个变量只能被模拟删除一次，模拟删除后标记为灰（原文说确保不会对同一个变量容器减两次”1”,不对的吧）。 在步骤 C 中，模拟恢复每个紫色变量。恢复是有条件的，当变量的引用计数大于0时才对其做模拟恢复。同样每个变量只能恢复一次，恢复后标记为黑，基本就是步骤 B 的逆运算。这样剩下的一堆没能恢复的就是该删除的蓝色节点了，在步骤 D 中遍历出来真的删除掉。 算法中都是模拟删除、模拟恢复、真的删除，都使用简单的遍历即可（最典型的深搜遍历）。复杂度为执行模拟操作的节点数正相关，不只是紫色的那些疑似垃圾变量。 现在，你已经对这个算法有了基本了解，我们回头来看这个如何与PHP集成。默认的，PHP的垃圾回收机制是打开的，然后有个 php.ini 设置允许你修改它：zend.enable_gc。 当垃圾回收机制打开时，每当根缓存区存满时，就会执行上面描述的循环查找算法。根缓存区有固定的大小，可存10,000个可能根,当然你可以通过修改PHP源码文件Zend/zend_gc.c中的常量GC_ROOT_BUFFER_MAX_ENTRIES，然后重新编译PHP，来修改这个10,000值。当垃圾回收机制关闭时，循环查找算法永不执行，然而，可能根将一直存在根缓冲区中，不管在配置中垃圾回收机制是否激活。 当垃圾回收机制关闭时，如果根缓冲区存满了可能根，更多的可能根显然不会被记录。那些没被记录的可能根，将不会被这个算法来分析处理。如果他们是循环引用周期的一部分，将永不能被清除进而导致内存泄漏。 即使在垃圾回收机制不可用时，可能根也被记录的原因是，相对于每次找到可能根后检查垃圾回收机制是否打开而言，记录可能根的操作更快。不过垃圾回收和分析机制本身要耗不少时间。 除了修改配置zend.enable_gc，也能通过分别调用gc_enable() 和 gc_disable()函数来打开和关闭垃圾回收机制。调用这些函数，与修改配置项来打开或关闭垃圾回收机制的效果是一样的。即使在可能根缓冲区还没满时，也能强制执行周期回收。你能调用gc_collect_cycles()函数达到这个目的。这个函数将返回使用这个算法回收的周期数。 允许打开和关闭垃圾回收机制并且允许自主的初始化的原因，是由于你的应用程序的某部分可能是高时效性的。在这种情况下，你可能不想使用垃圾回收机制。当然，对你的应用程序的某部分关闭垃圾回收机制，是在冒着可能内存泄漏的风险，因为一些可能根也许存不进有限的根缓冲区。因此，就在你调用gc_disable()函数释放内存之前，先调用gc_collect_cycles()函数可能比较明智。因为这将清除已存放在根缓冲区中的所有可能根，然后在垃圾回收机制被关闭时，可留下空缓冲区以有更多空间存储可能根。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP基础-数据类型-string和int比较","slug":"编程语言/PHP/PHP基础-数据类型-string和int比较","date":"2021-07-26T03:23:17.286Z","updated":"2021-08-10T15:52:24.656Z","comments":true,"path":"post/740536292.html","link":"","permalink":"https://dd-code.site/post/740536292.html","excerpt":"","text":"在php中，string 类型和 int 类型相比较，string 类型的值会被转为 int 类型，实质上是两个 int 类型的数值相互比较。 代码：12345678910&lt;?php$a = &#x27;c&#x27;;$b = 0;var_dump($a == $b);//输出true$c = 1;var_dump($a == $c);//输出false$d = true;var_dump($a == $d);//输出true$c = false;var_dump($a == $c);//输出false 从以上结果发现： string 类型的值和 int 类型的值比较，会被转为 int 类型的 0，也就是 true string 类型的值和 bool 类型的值比较，会被转为 bool 类型的 true","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP基础-数据类型","slug":"编程语言/PHP/PHP基础-数据类型","date":"2021-07-26T03:23:17.286Z","updated":"2021-08-10T15:52:24.656Z","comments":true,"path":"post/2518559853.html","link":"","permalink":"https://dd-code.site/post/2518559853.html","excerpt":"","text":"PHP支持10中原始数据类型四种标量类型： boolean（布尔型） integer（整型） float（浮点型，也称作 double） string（字符串） 四种复合型： array（数组） object（对象） callable（可调用） iterable（可迭代） 两种特殊类型： resource（资源） NULL（无类型） 为了确保代码的易读性，还有伪类型： mixed（混合类型） number（数字类型） array|object（数组|对象类型） void（无类型） 特殊的类型有 double（双精度），实际上 double 和 float 是相同的，由于历史原因，这两个名称同时存在。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP字符串函数","slug":"编程语言/PHP/PHP字符串函数","date":"2021-07-26T03:23:17.286Z","updated":"2021-08-10T15:52:24.851Z","comments":true,"path":"post/1503101483.html","link":"","permalink":"https://dd-code.site/post/1503101483.html","excerpt":"","text":"打印字符串的第一个字符12345$a=&#x27;abcdr&#x27;;//截取echo substr($a,0,1);//字符串还有类数组的特性，可以用索引下标echo $a[0]; 如何实现字符串反转1234567891011$str=&#x27;abcde&#x27;;function reu($str)&#123; $len=-strlen($str);//-5 for($new=&#x27;&#x27;,$start=-1;$start&gt;=$len;$start--)&#123; $new.=substr($str,$start,1); &#125; return $new;&#125;echo reu($str),&#x27;&lt;br&gt;&#x27;;//系统自带的字符串函数echo strrev($str); 将 1234567 转成 1，234，5671234567891011121314151617181920$str=1234567;//第一种思路：首先反转字符串-&gt;将字符串长度和符号进行分割-&gt;反转回原样function t1($str)&#123; //反转 $str=strrev($str); $res=strrev(chunk_split($str,3,&#x27;,&#x27;)); return $res;&#125;var_dump(t1($str));//,1,234,567//第二种思路：反转-&gt;按三个分成数组-&gt;再将数组，转换为字符串-&gt;再反转回原样function t2($str)&#123; $str=str_split(strrev($str),3); $res=strrev(implode(&#x27;,&#x27;,$str)); return $res;&#125;var_dump(t2($str));//string(9) &quot;1,234,567&quot;//第三种echo number_format($str);//1,234,567 获取文件的后缀名12345678910$file=&#x27;abc.exce.jpg&#x27;;//第一种：使用系统函数，查找的文件名echo strchr($file,&#x27;.&#x27;).&#x27;&lt;br&gt;&#x27;;//.jpg//第二种：strstr()返回的是字符串首次出现，加上true表示返回的是. 之前的字符串echo strrev(strstr(strrev($file),&#x27;.&#x27;,true));//jpg//第三种：strrpos()返回的是最后一次.出现的位置,然后在进行截取echo substr($file,strrops($file,&#x27;.&#x27;));//第四种：pathinfo()函数返回的是文件的路径的信息echo pathinfo($file,PATHINFO_EXTENSION);//jpg","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP基础-数据类型-string","slug":"编程语言/PHP/PHP基础-数据类型-string","date":"2021-07-26T03:23:17.285Z","updated":"2021-08-10T15:52:24.656Z","comments":true,"path":"post/3247369179.html","link":"","permalink":"https://dd-code.site/post/3247369179.html","excerpt":"","text":"一个字符串 string 就是由一系列的字符组成，其中每个字符等同于一个字节。 这意味着 PHP 只能支持 256 的字符集，因此不支持 Unicode。 string 最大可以达到 2GB。 语法一个字符串可以用4种方式表达： 单引号 双引号 heredoc 语法结构 nowdoc 语法结构（自 php5.5.0 起） 单引号定义给个字符串的最简单的方法是用单引号把它包围起来。 要表达一个单引号自身，需要在它的前边加个反斜线（\\）来转义。 要表达一个反斜线自身，则用两个反斜线（\\）。 其他任何方式的反斜线都会被当成反斜线本身；也就是说如果想使用其他转义序列，例如 \\r 或者 \\n，并不代表任何特殊含义，就单纯是这两个字符本身。 不像 双引号 和 heredoc 语法结构，在单引号字符串中的 变量 和特殊字符的转义序列将不会被替换。 1234567891011121314151617181920212223&lt;?phpecho &#x27;this is a simple string&#x27;;// 可以录入多行echo &#x27;You can also have embedded newlines in strings this way as it isokay to do&#x27;;// 输出： Arnold once said: &quot;I&#x27;ll be back&quot;echo &#x27;Arnold once said: &quot;I\\&#x27;ll be back&quot;&#x27;;// 输出： You deleted C:\\*.*?echo &#x27;You deleted C:\\\\*.*?&#x27;;// 输出： You deleted C:\\*.*?echo &#x27;You deleted C:\\*.*?&#x27;;// 输出： This will not expand: \\n a newlineecho &#x27;This will not expand: \\n a newline&#x27;;// 输出： Variables do not $expand $eitherecho &#x27;Variables do not $expand $either&#x27;;?&gt; 双引号如果字符串是包围在双引号（””）中，PHP 将对一些特殊的字符进行解析。 序列 含义 \\n 换行（ASCII 字符集中的 LF 或 0x0A (10)） \\r 回车（ASCII 字符集中的 CR 或 0x0D (13)） \\t 水平制表符（ASCII 字符集中的 HT 或 0x09 (9)） \\v 垂直制表符（ASCII 字符集中的 VT 或 0x0B (11)）（自 PHP 5.2.5 起） \\e Escape（ASCII 字符集中的 ESC 或 0x1B (27)）（自 PHP 5.4.0 起） \\f 换页（ASCII 字符集中的 FF 或 0x0C (12)）（自 PHP 5.2.5 起） \\\\ 反斜线 \\$ 美元标记 \\&quot; 双引号 \\[0-7]&#123;1,3&#125; 符合该正则表达式序列的是一个以八进制方式来表达的字符 \\x[0-9A-Fa-f]&#123;1,2&#125; 符合该正则表达式序列的是一个以十六进制方式来表达的字符 和单引号字符串一样，转义任何其他字符串都会导致反斜线被显示出来。php5.1.1以前，\\&#123;$var&#125; 中的反斜线还不会被显示出来。 用双引号定义的字符串最重要的特征是就是变量会被解析。 Heredoc 结构第三种表达字符串的方法是用 heredoc 句法结构：&lt;&lt;&lt;。在该运算符之后要提供一个标识符，然后换行。接下来是字符串 string 本身，最后要用前面定义的标识符作为结束标志。 结束时所引用的标识符必须在该行的第一列，而且，标识符的命名也要像其它标签一样遵守 PHP 的规则：只能包含字母、数字和下划线，并且必须以字母和下划线作为开头。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP基础-数据类型-integet","slug":"编程语言/PHP/PHP基础-数据类型-integet","date":"2021-07-26T03:23:17.285Z","updated":"2021-08-10T15:52:24.851Z","comments":true,"path":"post/221785719.html","link":"","permalink":"https://dd-code.site/post/221785719.html","excerpt":"","text":"integer 是集合 ℤ = {…, -2, -1, 0, 1, 2, …} 中的某个数。 语法整型值可以使用十进制，十六进制，八进制或二进制表示，前面可以加上可选的符号（- 或者 +）。 可以用 负运算符 来表示一个负的integer。 二进制表达的 integer 自 PHP 5.4.0 起可用。 要使用八进制表达，数字前必须加上 0（零）。要使用十六进制表达，数字前必须加上 0x。要使用二进制表达，数字前必须加上 0b。 从 PHP 7.4.0 开始，整型数值可能会包含下划线 (_)，为了更好的阅读体验，这些下划线在展示的时候，会被 PHP 过滤掉。 Example #1 整数文字表达1234567&lt;?php$a = 1234; // 十进制数$a = 0123; // 八进制数 (等于十进制 83)$a = 0x1A; // 十六进制数 (等于十进制 26)$a = 0b11111111; // 二进制数字 (等于十进制 255)$a = 1_234_567; // 整型数值 (PHP 7.4.0 以后)?&gt; 整数溢出如果给定的一个数超出了 integer 的范围，将会被解释为 float。同样如果执行的运算结果超出了 integer 范围，也会返回 float。 Example #2 32 位系统下的整数溢出1234567891011&lt;?php$large_number = 2147483647;var_dump($large_number); // int(2147483647)$large_number = 2147483648;var_dump($large_number); // float(2147483648)$million = 1000000;$large_number = 50000 * $million;var_dump($large_number); // float(50000000000)?&gt; Example #3 64 位系统下的整数溢出 1234567891011&lt;?php$large_number = 9223372036854775807;var_dump($large_number); // int(9223372036854775807)$large_number = 9223372036854775808;var_dump($large_number); // float(9.2233720368548E+18)$million = 1000000;$large_number = 50000000000000 * $million;var_dump($large_number); // float(5.0E+19)?&gt; PHP 中没有整除的运算符。1/2 产生出 float 0.5。 值可以舍弃小数部分，强制转换为 integer，或者使用 round() 函数可以更好地进行四舍五入。 从 PHP 7.0.0 开始，函数 intdiv() 可以用于整数除法。 12345&lt;?phpvar_dump(25/7); // float(3.5714285714286) var_dump((int) (25/7)); // int(3)var_dump(round(25/7)); // float(4) ?&gt; 转换为整形要明确地将一个值转换为 integer，用 (int) 或 (integer) 强制转换。不过大多数情况下都不需要强制转换，因为当运算符，函数或流程控制需要一个 integer 参数时，值会自动转换。还可以通过函数 intval() 来将一个值转换成整型。 将 resource 转换成 integer 时， 结果会是 PHP 运行时为 resource 分配的唯一资源号。 从布尔值转换FALSE 将产生出 0（零），**TRUE** 将产生出 1（壹）。 从浮点型转换当从浮点数转换成整数时，将向下取整。 PHP 7.0.0 起，NaN 和 Infinity 在转换成 integer 时，不再是 undefined 或者依赖于平台，而是都会变成零。 绝不要将未知的分数强制转换为 integer，这样有时会导致不可预料的结果，比如： 123&lt;?phpecho (int) ( (0.1+0.7) * 10 ); // 显示 7!?&gt; 从字符串转换当一个字符串被当作一个数值来取值，其结果和类型如下： 如果该字符串没有包含 ‘.’，’e’ 或 ‘E’ 并且其数字值在整型的范围之内（由 PHP_INT_MAX 所定义），该字符串将被当成 integer 来取值。其它所有情况下都被作为 float 来取值。 该字符串的开始部分决定了它的值。如果该字符串以合法的数值开始，则使用该数值。否则其值为 0（零）。合法数值由可选的正负号，后面跟着一个或多个数字（可能有小数点），再跟着可选的指数部分。指数部分由 ‘e’ 或 ‘E’ 后面跟着一个或多个数字构成。 12345678910&lt;?php$foo = 1 + &quot;10.5&quot;; // $foo is float (11.5)$foo = 1 + &quot;-1.3e3&quot;; // $foo is float (-1299)$foo = 1 + &quot;bob-1.3e3&quot;; // $foo is integer (1)$foo = 1 + &quot;bob3&quot;; // $foo is integer (1)$foo = 1 + &quot;10 Small Pigs&quot;; // $foo is integer (11)$foo = 4 + &quot;10.2 Little Piggies&quot;; // $foo is float (14.2)$foo = &quot;10.0 pigs &quot; + 1; // $foo is float (11)$foo = &quot;10.0 pigs &quot; + 1.0; // $foo is float (11) ?&gt; 从NULL转换NULL 会转换为零 (0) 从其它类型转换Caution 没有定义从其它类型转换为整型的行为。不要依赖任何现有的行为，因为它会未加通知地改变","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP基础-数据类型-boolean","slug":"编程语言/PHP/PHP基础-数据类型-boolean","date":"2021-07-26T03:23:17.284Z","updated":"2021-08-10T15:52:24.851Z","comments":true,"path":"post/886155297.html","link":"","permalink":"https://dd-code.site/post/886155297.html","excerpt":"","text":"这是最简单的类型，boolean 表达了真值，可以为 true 或者 false 语法要指定一个布尔值，使用常量 true 或 false 。两个都不区分大小写。 123&lt;?php$foo = True; // 设置 $foo 为 TRUE?&gt; 通常运算符所返回的 boolean 值结果会被传递给控制流程。 123456789101112131415&lt;?php// == 是一个操作符，它检测两个变量是否相等，并返回一个布尔值if ($action == &quot;show_version&quot;) &#123; echo &quot;The version is 1.23&quot;;&#125;// 这样做是不必要的...if ($show_separators == TRUE) &#123; echo &quot;&lt;hr&gt;\\n&quot;;&#125;// ...因为可以使用下面这种简单的方式：if ($show_separators) &#123; echo &quot;&lt;hr&gt;\\n&quot;;&#125; 转换为布尔值要明确的将一个值转换为 boolean ，用 （bool）或者 （boolean）来强制转换。但是很多情况下不需要用强制转换，因为当运算符，函数或者流程控制结构需要一个 boolean 参数时，该值会被自动转换。 当转换为 boolean 时，以下值被认为是 FALSE 布尔值 false 本身 整型值 0（零）及 -0（零） 浮点型值 0.0（零）-0.0（零） 空字符串，以及字符串 “0” 不包括任何元素的数组 特殊类型 NULL（包括尚未赋值的变量） 从空标记生成的 SimpleXML 对象 所有其他值都被认为是 TRUE （包括任何资源和nan） Warning ：-1 和其它非零值（不论正负）一样，被认为是 TRUE。 12345678910&lt;?phpvar_dump((bool) &quot;&quot;); // bool(false)var_dump((bool) 1); // bool(true)var_dump((bool) -2); // bool(true)var_dump((bool) &quot;foo&quot;); // bool(true)var_dump((bool) 2.3e5); // bool(true)var_dump((bool) array(12)); // bool(true)var_dump((bool) array()); // bool(false)var_dump((bool) &quot;false&quot;); // bool(true)?&gt;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP基础-数据类型-float","slug":"编程语言/PHP/PHP基础-数据类型-float","date":"2021-07-26T03:23:17.284Z","updated":"2021-08-10T15:52:24.851Z","comments":true,"path":"post/4235469996.html","link":"","permalink":"https://dd-code.site/post/4235469996.html","excerpt":"","text":"浮点型（也叫浮点数，双精度数 double 或实数 real）可以用以下任一语法定义： 123456&lt;?php$a = 1.234; $b = 1.2e3; $c = 7E-10;$d = 1_234.567; // 从 PHP 7.4.0 开始支持?&gt; 浮点数的形式表示（PHP7.4.0之前不支持下划线）： 123LNUM [0-9]+(_[0-9]+)*DNUM ([0-9]*(_[0-9]+)*[\\.]&#123;LNUM&#125;) | (&#123;LNUM&#125;[\\.][0-9]*(_[0-9]+)*)EXPONENT_DNUM ((&#123;LNUM&#125; | &#123;DNUM&#125;) [eE][+-]? &#123;LNUM&#125;) 浮点数的精度 浮点数的精度有限，也取决于系统 远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP-FPM的三种运行模式","slug":"编程语言/PHP/PHP-FPM的三种运行模式的三种运行模式","date":"2021-07-26T03:23:17.283Z","updated":"2021-08-10T15:52:24.851Z","comments":true,"path":"post/4276646924.html","link":"","permalink":"https://dd-code.site/post/4276646924.html","excerpt":"","text":"1：static 模式（静态模式）static 模式始终会保持一个固定数量的子进程，这个数量由pm.max_children 的配置决定 2：dynamic 模式（动态模式）子进程的数量是动态变化的，启动时，会生成固定数量的子进程，可以理解为最小子进程数，通过 pm.statr_servers 配置决定，而最大子进程数则由pm.max_children 控制，子进程数会在pm.start_servers ~ pm.max_children 范围内波动，另外，闲置的子进程数还可以由 pm.min_spare_servers和 pm.max_spare_servers两个配置参数控制。总结：闲置的子进程也可以有最小数目和最大数目，而如果闲置的子进程超过pm.max_spare_servers,则会别杀死。 3：ondemand 模式（动态需求模式）这种模式和 dynamic 模式相反。因为这种模式把内存放在第一位，每个闲置进程在持续闲置了pm.process_idle_timeout 秒后就会被杀死，因为这种模式，到了服务器低峰期的时候，内存就会降下来，如果服务器长时间没有请求，就只有一个主进程。其弊端是，遇到高峰期或者pm.process_idle_timeout 设置太小，无法避免服务器频繁创建进程的问题。 涉及到的参数配置： pm.max_children ：静态方式下开启 php-fpm 进程数量 pm.start_servers：动态方式下的起始 php-fpm 进程数量 pm.min_spare_servers：动态方式下的最小 php-fpm 进程数量 pm.max_spare_servers：动态方式下的最大 php-fpm 进程数量 PHP-FPM 慢日志配置配置文件：php-fpm.conf 开启慢日志查询： 12slowlog = /usr/local/log/php-fpm.log.slowrequest_slowlog_timeout = 5s 意思是当某个请求时间超过了5秒，就写进慢日志，注意是5s，别忘了单位。其他单位还有m分，h时，php-fpm会记录对应的进程号，脚本名称，具体执行慢的代码行好等。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP 中self、static、$this的区别&后期静态绑定详解","slug":"编程语言/PHP/PHP中self、static、$this的区别&后期静态绑定详解","date":"2021-07-26T03:23:17.283Z","updated":"2021-08-10T15:52:24.856Z","comments":true,"path":"post/2140386669.html","link":"","permalink":"https://dd-code.site/post/2140386669.html","excerpt":"","text":"为了更好地理解 self、static 和 $this 的区别，先来看一个示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?phpclass A &#123; protected $name = &#x27;A&#x27;; static $alias = &#x27;a&#x27;; const HASH = &#x27;md5&#x27;; public function dd() &#123; echo $this-&gt;name; echo &#x27;--&#x27;; echo static::$alias; echo &#x27;--&#x27;; // 后期静态绑定 echo static::HASH; echo &#x27;--&#x27;; // 后期静态绑定 echo self::$alias; echo &#x27;--&#x27;; echo self::HASH; echo &#x27;--&#x27;; var_dump(new self); echo &#x27;--&#x27;; var_dump($this); echo &#x27;--&#x27;; var_dump(new static); echo &#x27;&lt;br&gt;&#x27;; // 后期静态绑定 &#125; public static function who() &#123; echo __CLASS__; echo &#x27; [ This is A ]&#x27;; echo &#x27;&lt;br&gt;&#x27;; &#125; public static function test() &#123; self::who(); &#125; public static function test2() &#123; static::who(); // 后期静态绑定 &#125; public static function getInstance() &#123; var_dump(new self); echo &#x27;--&#x27;; var_dump(new static); echo &#x27;&lt;br&gt;&#x27;; // 后期静态绑定 &#125;&#125;class B extends A &#123; protected $name = &#x27;B&#x27;; static $alias = &#x27;b&#x27;; const HASH = &#x27;sha1&#x27;; public static function who() &#123; echo __CLASS__; echo &#x27; [ This is B ]&#x27;; echo &#x27;&lt;br&gt;&#x27;; &#125;&#125;class C extends B &#123; public static function who() &#123; echo __CLASS__; echo &#x27; [ This is C]&#x27;; echo &#x27;&lt;br&gt;&#x27;; &#125;&#125;(new A)-&gt;dd(); // A--a--md5--a--md5--object(A)#2 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125; --object(A)#1 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125; --object(A)#2 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125;(new B)-&gt;dd(); // B--b--sha1--a--md5--object(A)#2 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125; --object(B)#1 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;B&quot; &#125; --object(B)#2 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;B&quot; &#125;A::who(); // A [ This is A ]B::who(); // B [ This is B ]A::test(); // A [ This is A ]B::test(); // A [ This is A ]A::test2(); // A [ This is A ]B::test2(); // B [ This is B ]C::test2(); // C [ This is C]A::getInstance(); //object(A)#1 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125; --object(A)#1 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125;B::getInstance(); //object(A)#1 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125; --object(B)#1 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;B&quot; &#125; 总结说明 self 和 __CLASS__，都是对当前类的静态引用，取决于定义当前方法所在的类。也就是说，self 写在哪个类里面， 它引用的就是谁。 $this 指向的是实际调用时的对象，也就是说，实际运行过程中，谁调用了类的属性或方法，$this 指向的就是哪个对象。但 $this 不能访问类的静态属性和常量，且 $this 不能存在于静态方法中。 static 关键字除了可以声明类的静态成员（属性和方法）外，还有一个非常重要的作用就是后期静态绑定。 self 可以用于访问类的静态属性、静态方法和常量，但 self 指向的是当前定义所在的类，这是 self 的限制。 $this 指向的对象所属的类和 static 指向的类相同。 static 可以用于静态或非静态方法中，也可以访问类的静态属性、静态方法、常量和非静态方法，但不能访问非静态属性。 静态调用时，static 指向的是实际调用时的类；非静态调用时，static 指向的是实际调用时的对象所属的类。 后期静态绑定后期静态绑定（也叫延迟静态绑定），可用于在继承范围内引用静态调用的类，也就是代码运行时最初调用的类。 后期静态绑定本想通过引入一个新的关键字来表示，但最终还是沿用了 static 关键字。 工作原理确切地说，static 后期静态绑定的工作原理是存储了上一个非转发调用（non-forwarding call）的类名。 当进行静态方法调用时，该类名（static指向的类名）为明确指定的那个（通常是 :: 运算符的左侧部分），即实际调用时的类。 如上述示例中的： 12A::test2(); B::test2(); static 和 self 的区别： self 可以用于访问类的静态属性、静态方法和常量，但 self 指向的是当前定义所在的类，这是 self 的限制。 static 也可以用于访问类的静态属性、静态方法和常量，static 指向的是实际调用时的类。 当进行非静态方法调用时，该类名（static指向的类名）为该对象所属的类，即实际调用时的对象所属的类。 如上述示例中的： 12(new A)-&gt;dd(); (new B)-&gt;dd(); static 和 $this 有点类似，但又有区别： $this 指向的对象所属的类和 static 指向的类相同 $this 不能用于静态方法中，也不能访问类的静态属性和常量 $this 指向的是实际调用的对象 static 可以用于静态或非静态方法中，也可以访问类的静态属性、静态方法、常量和非静态方法，但不能访问非静态属性 static 指向的是实际调用时的对象所属的类 转发调用（forwarding call）所谓的转发调用（forwarding call）指的是通过以下几种方式进行的静态调用：self::，parent::，static:: 以及 forward_static_call() 。 可用 get_called_class() 函数来获取被调用的方法所在的类名。 以下四种形式的调用，都是转发调用： 1234self::parent::static::forward_static_call() 除此之外的调用，就是非转发调用。 非转发调用（non-forwarding call）后期静态绑定的工作原理是存储了上一个非转发调用（non-forwarding call）的类名。 通过具体的类名或具体的对象进行的调用都是非转发调用。 比如： 12345A::test2(); B::test2(); (new A)-&gt;dd(); (new B)-&gt;dd(); 注意事项非静态环境下的私有方法的查找顺序。在非静态环境下，在类的非静态方法中，使用 $this 和 static 调用类的私有方法时，执行方式有所不同。 $this 会优先寻找所在定义范围（父类）中的私有方法，如果存在就调用 static 是先到它指向的类（子类）中寻找私有方法，如果找到了就会报错，因为私有方法只能在它所定义的类内部调用；如果没找到，再去所在定义范围（父类）中寻找该私有方法，如果存在就调用 具体来说，$this 会先到所在定义范围内寻找私有方法，再到它指向的对象所属的类中寻找私有方法，然后寻找公有方法，最后到所在定义范围内寻找公共方法。只要找到了匹配的方法，就调用，并停止查找。 而 static 则是先到它指向的类中寻找私有方法，再寻找共有方法；然后到所在定义范围内寻找私有方法，再寻找共有方法。只要找到了匹配的方法，就调用，并停止查找。 下面是一个例子： 12345678910111213141516171819202122232425262728&lt;?php class A &#123; private function foo () &#123; var_dump($this); echo &#x27;--&#x27;; var_dump(new static); echo &#x27;--&#x27;; echo __CLASS__; echo &#x27;--&#x27;; echo get_called_class(); echo &#x27;&lt;br&gt;&#x27;; &#125; public function test () &#123; $this -&gt; foo (); static:: foo (); echo &#x27;&lt;br&gt;&#x27;; &#125;&#125;class B extends A &#123; &#125;class C extends A &#123; private function foo () &#123; echo &#x27;this is C&#x27;; &#125;&#125;(new B())-&gt;test();(new C())-&gt;test(); 输出结果为： 123456object(B)#1 (0) &#123; &#125; --object(B)#2 (0) &#123; &#125; --A--Bobject(B)#1 (0) &#123; &#125; --object(B)#2 (0) &#123; &#125; --A--Bobject(C)#1 (0) &#123; &#125; --object(C)#2 (0) &#123; &#125; --A--CFatal error: Uncaught Error: Call to private method C::foo() from context &#x27;A&#x27; 关于后期静态绑定的解析后期静态绑定的解析会一直到取得一个完全解析了的静态调用为止。如果静态调用使用了 parent:: 或者 self:: 等转发调用的形式，将会转发调用信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpclass A &#123; public static function foo () &#123; static:: who (); &#125; public static function who () &#123; echo __CLASS__ . &quot;\\n&quot; ; &#125;&#125;class B extends A &#123; public static function test () &#123; A :: foo (); parent :: foo (); self :: foo (); static::foo(); forward_static_call([&#x27;A&#x27;, &#x27;foo&#x27;]); echo &#x27;&lt;br&gt;&#x27;; &#125; public static function who () &#123; echo __CLASS__ . &quot;\\n&quot; ; &#125;&#125;class C extends B &#123; public static function who () &#123; echo __CLASS__ . &quot;\\n&quot; ; &#125; public static function test2() &#123; self::test(); &#125;&#125;class D extends C &#123; public static function who () &#123; echo __CLASS__ . &quot;\\n&quot; ; &#125;&#125;B::foo();B::test();C::foo();C::test();D::foo();D::test2(); 以上的输出结果为： 123B A B B B B C A C C C C D A D D D D static 后期静态绑定的工作原理是存储了上一个非转发调用（non-forwarding call）的类名。请记住这句话。 下面的例子是非转发调用。 12345A::foo(); // 输出 AB::foo(); // 输出 BC::foo(); // 输出 C 后期静态绑定 static ，是定义在了 foo() 方法中，哪个类通过非转发调用的形式调用 foo() 方法， foo() 方法中的 static 指向的就是哪个类。 但是，如果通过转发调用的形式，调用 foo() 方法，如： 1234parent :: foo ();self :: foo ();static::foo();forward_static_call([&#x27;A&#x27;, &#x27;foo&#x27;]); 那么，就以转发调用代码所在的方法 test() 为准，哪个类通过非转发调用的形式调用 test() 方法， foo() 方法中的 static 指向的就是哪个类。 假如调用 test() 方法时，也采用了转发调用的形式，如： 123public static function test2() &#123; self::test();&#125; 那么，就以 test2() 方法为准 … 依次类推。 也就是说，在使用了后期静态绑定的基类中，后期静态绑定所在的方法如果被转发调用，则 static 的指向，会一直向上追溯，直到遇到非转发调用的形式。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"PHP-FPM是什么","slug":"编程语言/PHP/PHP-FPM是什么","date":"2021-07-26T03:23:17.282Z","updated":"2021-08-10T15:52:24.656Z","comments":true,"path":"post/1171510126.html","link":"","permalink":"https://dd-code.site/post/1171510126.html","excerpt":"","text":"PHP-FPM 即 PHP FastCGI的进程管理器。 CGI 的意思是 ==通用网关接口== ，是 Web 服务器调用外部程序时使用的一种服务端应用的规范。 CGI 针对每个 HTTP 请求都会 fork 一个新的进程来进行处理（解析配置文件、初始化执行环境、处理请求），然后把这个进程处理完的结果通过 Web 服务转发给用户，刚刚 fork 的新进程也随之退出，如果下次用户再请求动态资源，Web 服务器又再次 fork 一个新的进程，如此周而复始循环往复。 FastCGI 是 CGI 的升级版本，为提升 CGI 的性能而生。FastCGI 会先 fork 一个新的 master 进程，解析配置文件，初始化执行环境，然后再 fork 多个 worker 进程（类似于 nginx），当 HTTP 请求过来时，master 会将请求传递给一个 worker 进程，然后再接收下一个请求，这样的话只需要解析一次配置文件，初始化一次执行环境，每次请求不会阻塞，导不会致请求停滞。这样大大提高了请求效率，可以处理高并发环境下的业务场景。Master 还会更根据配置预先启动几个 Worker 进程进行等待，当Worker 进程过多，Master 也会根据配置文件设置销毁掉多余的 Worker，这样提高了性能，也节约了系统资源。 PHP-FPM 负责管理一个进程池来处理来自 Web 服务器的 HTTP 动态请求，在PHP-FPM 中，Master 进程负责与 Web 服务器进行通信，接收 HTTP 请求，再将请求转发给 worker 进程处理。Worker 进程主要负责动态执行 PHP 代码，处理完成后，将处理结果返回给 Web 服务器，再由 Web 服务器将结果发送给客户端，这就是 PHP-FPM 的工作原理。 资料： https://www.php.net/manual/zh/install.fpm.php https://www.jianshu.com/p/6b8511e0bd88 https://zhuanlan.zhihu.com/p/110540192","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"05|数组类型","slug":"课程学习/廖雪峰的Java教程/03-运算/ch4-5","date":"2021-07-26T03:23:17.282Z","updated":"2021-08-10T16:01:11.240Z","comments":true,"path":"post/3940022775.html","link":"","permalink":"https://dd-code.site/post/3940022775.html","excerpt":"","text":"","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"03-运算","slug":"课程学习/廖雪峰的Java教程/03-运算","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/03-%E8%BF%90%E7%AE%97/"}],"tags":[]},{"title":"02|浮点数运算","slug":"课程学习/廖雪峰的Java教程/03-运算/ch4-2","date":"2021-07-26T03:23:17.281Z","updated":"2021-08-10T16:01:11.240Z","comments":true,"path":"post/2719730562.html","link":"","permalink":"https://dd-code.site/post/2719730562.html","excerpt":"","text":"","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"03-运算","slug":"课程学习/廖雪峰的Java教程/03-运算","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/03-%E8%BF%90%E7%AE%97/"}],"tags":[]},{"title":"03|布尔运算","slug":"课程学习/廖雪峰的Java教程/03-运算/ch4-3","date":"2021-07-26T03:23:17.281Z","updated":"2021-08-10T16:01:11.240Z","comments":true,"path":"post/1318299933.html","link":"","permalink":"https://dd-code.site/post/1318299933.html","excerpt":"","text":"","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"03-运算","slug":"课程学习/廖雪峰的Java教程/03-运算","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/03-%E8%BF%90%E7%AE%97/"}],"tags":[]},{"title":"04|字符和字符串","slug":"课程学习/廖雪峰的Java教程/03-运算/ch4-4","date":"2021-07-26T03:23:17.281Z","updated":"2021-08-10T16:01:11.240Z","comments":true,"path":"post/709319275.html","link":"","permalink":"https://dd-code.site/post/709319275.html","excerpt":"","text":"","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"03-运算","slug":"课程学习/廖雪峰的Java教程/03-运算","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/03-%E8%BF%90%E7%AE%97/"}],"tags":[]},{"title":"01|整数运算","slug":"课程学习/廖雪峰的Java教程/03-运算/ch4-1","date":"2021-07-26T03:23:17.280Z","updated":"2021-08-10T16:01:11.240Z","comments":true,"path":"post/2897062313.html","link":"","permalink":"https://dd-code.site/post/2897062313.html","excerpt":"","text":"四则运算Java的整数运算遵循四则运算规则，可以使用任意嵌套的小括号。四则运算规则和初等数学一致。例如： 1234567891011121314151617package com.study.basics.liaoxuefeng;/** * 运算 * * @author liudandan */public class Operation &#123; public static void main(String[] args) &#123; // 3300 int i = (100 + 200) * (99 - 88); // 23072 int n = 7 * (5 + (i - 9)); System.out.println(i); System.out.println(n); &#125;&#125; 整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分： 1int x = 12345 / 67; // 184 正常结果：12345 ÷ 67 = 184.2537313432836 求余求余运算使用%： 1int y = 12345 % 67; // 12345÷67的余数是17 特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错。 溢出要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果： 123456789101112/** * 运算溢出 */class YiChu &#123; public static void main(String[] args) &#123; int x = 2147483640; int y = 15; int sum = x + y; // -2147483641 System.out.println(sum); &#125;&#125; 要解释上述结果，我们把整数2147483640和15换成二进制做加法： 1234 0111 1111 1111 1111 1111 1111 1111 1000+ 0000 0000 0000 0000 0000 0000 0000 1111----------------------------------------- 1000 0000 0000 0000 0000 0000 0000 0111 由于最高位计算结果为1，因此，加法结果变成了一个负数。 要解决上面的问题，可以把int换成long类型，由于long可表示的整型范围更大，所以结果就不会溢出： 123456789101112/** * 运算溢出 */class YiChu &#123; public static void main(String[] args) &#123; long x = 2147483640; long y = 15; long sum = x + y; // 2147483655 System.out.println(sum); &#125;&#125; 简写运算符还有一种简写的运算符，即+=，-=，*=，/=，它们的使用方法如下： 12n += 100; // 3409, 相当于 n = n + 100;n -= 100; // 3309, 相当于 n = n - 100; 自增/自减Java还提供了++运算和--运算，它们可以对一个整数进行加1和减1的操作： 1234567891011class ZiAdd &#123; public static void main(String[] args) &#123; int n = 3300; // 3301, 相当于 n = n + 1; n++; System.out.println(n); // 3300, 相当于 n = n - 1; n--; System.out.println(n); &#125;&#125; 注意：++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1。不建议把++运算混入到常规运算中，容易自己把自己搞懵了。 移位运算在计算机中，整数总是以二进制的形式表示。例如，int类型的整数7使用4字节表示的二进制如下： 100000000 0000000 0000000 00000111 可以对整数进行移位运算。对整数7左移1位将得到整数14，左移两位将得到整数28： 12345int n = 7; // 00000000 00000000 00000000 00000111 = 7int a = n &lt;&lt; 1; // 00000000 00000000 00000000 00001110 = 14int b = n &lt;&lt; 2; // 00000000 00000000 00000000 00011100 = 28int c = n &lt;&lt; 28; // 01110000 00000000 00000000 00000000 = 1879048192int d = n &lt;&lt; 29; // 11100000 00000000 00000000 00000000 = -536870912 左移29位时，由于最高位变成1，因此结果变成了负数。 类似的，对整数28进行右移，结果如下： 1234int n = 7; // 00000000 00000000 00000000 00000111 = 7int a = n &gt;&gt; 1; // 00000000 00000000 00000000 00000011 = 3int b = n &gt;&gt; 2; // 00000000 00000000 00000000 00000001 = 1int c = n &gt;&gt; 3; // 00000000 00000000 00000000 00000000 = 0 如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数： 12345int n = -536870912;int a = n &gt;&gt; 1; // 11110000 00000000 00000000 00000000 = -268435456int b = n &gt;&gt; 2; // 11111000 00000000 00000000 00000000 = -134217728int c = n &gt;&gt; 28; // 11111111 11111111 11111111 11111110 = -2int d = n &gt;&gt; 29; // 11111111 11111111 11111111 11111111 = -1 还有一种无符号的右移运算，使用&gt;&gt;&gt;，它的特点是不管符号位，右移后高位总是补0，因此，对一个负数进行&gt;&gt;&gt;右移，它会变成正数，原因是最高位的1变成了0： 12345int n = -536870912;int a = n &gt;&gt;&gt; 1; // 01110000 00000000 00000000 00000000 = 1879048192int b = n &gt;&gt;&gt; 2; // 00111000 00000000 00000000 00000000 = 939524096int c = n &gt;&gt;&gt; 29; // 00000000 00000000 00000000 00000111 = 7int d = n &gt;&gt;&gt; 31; // 00000000 00000000 00000000 00000001 = 1 对byte和short类型进行移位时，会首先转换为int再进行位移。 仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。 位运算位运算是按位进行与、或、非和异或的运算。 与运算的规则是，必须两个数同时为1，结果才为1： 1234n = 0 &amp; 0; // 0n = 0 &amp; 1; // 0n = 1 &amp; 0; // 0n = 1 &amp; 1; // 1 或运算的规则是，只要任意一个为1，结果就为1： 1234n = 0 | 0; // 0n = 0 | 1; // 1n = 1 | 0; // 1n = 1 | 1; // 1 非运算的规则是，0和1互换： 12n = ~0; // 1n = ~1; // 0 异或运算的规则是，如果两个数不同，结果为1，否则为0： 1234n = 0 ^ 0; // 0n = 0 ^ 1; // 1n = 1 ^ 0; // 1n = 1 ^ 1; // 0 对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如： 1234567public class Main &#123; public static void main(String[] args) &#123; int i = 167776589; // 00001010 00000000 00010001 01001101 int n = 167776512; // 00001010 00000000 00010001 00000000 System.out.println(i &amp; n); // 167776512 &#125;&#125; 上述按位与运算实际上可以看作两个整数表示的IP地址10.0.17.77和10.0.17.0，通过与运算，可以快速判断一个IP是否在给定的网段内。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"03-运算","slug":"课程学习/廖雪峰的Java教程/03-运算","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/03-%E8%BF%90%E7%AE%97/"}],"tags":[]},{"title":"编码-快排算法","slug":"技术学习/算法/编码-快排算法","date":"2021-07-26T03:23:17.272Z","updated":"2021-08-10T15:48:33.559Z","comments":true,"path":"post/570953535.html","link":"","permalink":"https://dd-code.site/post/570953535.html","excerpt":"","text":"代码12345678910111213141516171819202122232425&lt;?phpfunction kuaisu($arr)&#123; $len = count($arr); if ($len &lt;= 1) &#123; return $arr; &#125; $key = $arr[0]; $left_arr = array(); $right_arr = array(); for ($i = 1; $i &lt; $len; $i++) &#123; if ($arr[$i] &lt;= $key) &#123; $left_arr[] = $arr[$i]; &#125; else &#123; $right_arr[] = $arr[$i]; &#125; &#125; $left_arr = kuaisu($left_arr); $right_arr = kuaisu($right_arr); return array_merge($left_arr, array($key), $right_arr);&#125;$arr = array(23, 98, 54, 2, 9, 62, 34);print_r(kuaisu($arr)); 输出12345678910Array( [0] =&gt; 2 [1] =&gt; 9 [2] =&gt; 23 [3] =&gt; 34 [4] =&gt; 54 [5] =&gt; 62 [6] =&gt; 98)","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"技术学习/算法","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://dd-code.site/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"编码-冒泡排序","slug":"技术学习/算法/编码-冒泡排序","date":"2021-07-26T03:23:17.271Z","updated":"2021-08-10T15:48:55.171Z","comments":true,"path":"post/1898961614.html","link":"","permalink":"https://dd-code.site/post/1898961614.html","excerpt":"","text":"代码123456789101112131415161718192021&lt;?phpfunction bubbleSort(array $arr)&#123; $counts = count($arr); if ($counts &lt;= 0) return; for ($i = 0; $i &lt; $counts; $i++) &#123; for ($j = $counts - 1; $j &gt; $i; $j--) &#123; if ($arr[$j] &lt; $arr[$j - 1]) &#123; $tmp = $arr[$j]; $arr[$j] = $arr[$j - 1]; $arr[$j - 1] = $tmp; &#125; &#125; &#125; return $arr;&#125;echo &quot;冒泡排序-正序&quot; . &quot;\\n&quot;;$arr = array(1, 12, 16, 7, 9);$results = bubbleSort($arr);print_r($results); 输出123456789冒泡排序-正序Array( [0] =&gt; 1 [1] =&gt; 7 [2] =&gt; 9 [3] =&gt; 12 [4] =&gt; 16)","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"技术学习/算法","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://dd-code.site/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"检查给定数组是否成对排序","slug":"技术学习/算法/检查给定数组是否成对排序","date":"2021-07-26T03:23:17.271Z","updated":"2021-08-10T15:49:02.632Z","comments":true,"path":"post/73634619.html","link":"","permalink":"https://dd-code.site/post/73634619.html","excerpt":"","text":"https://www.geeksforgeeks.org/check-given-array-pairwise-sorted-not/","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"技术学习/算法","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://dd-code.site/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"快速排序解析","slug":"技术学习/算法/快速排序解析","date":"2021-07-26T03:23:17.271Z","updated":"2021-08-10T15:49:06.699Z","comments":true,"path":"post/2412115213.html","link":"","permalink":"https://dd-code.site/post/2412115213.html","excerpt":"","text":"快速排序原理快速排序使用分治法策略把一个串行（List）分成两个子串行（sub_Lists）。 快速排序思路从数列中挑出一个元素，称为“基准”。 重新排列数列，所有元素比基准值小的摆放在基准前边，所有元素比基准大的摆在基准后边（相同数可以到任一边）。 在这个分组退出之后，该基准就处于数列的中间位置，这个称为分区操作。 递归的把小于基准元素的子数列和大于基准元素的子数列排序。 代码12345678910111213141516171819202122/** * 快速排序 * @param $arr=[2, 3, 5, 1] * @return array */public function quickSort($arr)&#123; $len = count($arr); if ($len &lt;= 1) return $arr; $key = $arr[0]; $left_arr = array(); $right_arr = array(); for ($i = 1; $i &lt; count($arr); $i++) &#123; if ($arr[$i] &lt;= $key) $left_arr[] = $arr[$i]; else $right_arr[] = $arr[$i]; &#125; $left_arr = $this-&gt;quickSort($left_arr); $right_arr = $this-&gt;quickSort($right_arr); return array_merge($left_arr, array($key), $right_arr);&#125; 结果12345678最终结果：Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 5) ①：第一次循环的时候，原始数组：[2, 3, 5, 1]，因为取了第一个值作为基准值，所以开始从第二个元素进行对比，和第一个基准对比 3 和 2 比较，3 大于 2，不满足条件（$arr[$i] &lt;= $key），把大的数给到右边 $right_arr ②：第二次循环的时候 5 和 2 比较，5 大于 2，不满足条件（$arr[$i] &lt;= $key），依旧把大的数给到右边 $right_arr ③：第三次循环的时候 1 和 2 比较，1 小于 2，满足条件（$arr[$i] &lt;= $key），把小的数给到左边 $left_arr ④：第四次循环的时候，数组依旧循环完毕，现在将 $left_arr 和 $left_arr再次进行遍历 1$left_arr = $this-&gt;quickSort($left_arr); 因为 $left_arr 只有一个值，直接输出了，不会进行循环 1$right_arr=[3,5]; ⑤：第五次循环的时候，$right_arr 数组进行循环遍历 5 和 3 比较，5 大于 3，把大的数给到右边 $right_arr 解析首先把数组的第一个元素设为 “基准”。 1$key = $arr[0]; 定义两个临时数组 12$left_arr = array();$right_arr = array(); 然后对数组进行常规 for 循环 123for ($i = 1; $i &lt; count($arr); $i++) &#123; ......&#125; 按照 基准值 得大小把串行分成两个子串行（也就是把长数组分成两个小数组） 1234if ($arr[$i] &lt;= $key) $left_arr[] = $arr[$i];else $right_arr[] = $arr[$i]; 这样的话再次对两个小数组进行分治法 12 $left_arr = $this-&gt;quickSort($left_arr);$right_arr = $this-&gt;quickSort($right_arr); 最后把这几个小数组合按照顺序并起来，就分好了，记住，一定要按照顺序 1return array_merge($left_arr, array($key), $right_arr); 动画演示 ​","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"技术学习/算法","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://dd-code.site/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"国外一个学习算法很好的网站","slug":"技术学习/算法/国外一个学习算法很好的网站","date":"2021-07-26T03:23:17.270Z","updated":"2021-08-10T15:48:58.796Z","comments":true,"path":"post/3516134866.html","link":"","permalink":"https://dd-code.site/post/3516134866.html","excerpt":"","text":"https://www.geeksforgeeks.org/","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"技术学习/算法","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"优秀网站","slug":"优秀网站","permalink":"https://dd-code.site/tags/%E4%BC%98%E7%A7%80%E7%BD%91%E7%AB%99/"}]},{"title":"两两对比算法","slug":"技术学习/算法/两两对比算法","date":"2021-07-26T03:23:17.270Z","updated":"2021-08-10T15:49:09.995Z","comments":true,"path":"post/1991213779.html","link":"","permalink":"https://dd-code.site/post/1991213779.html","excerpt":"","text":"PHP两两对比算法123456789101112131415161718/** * PHP两两对比算法 */function Combination($arr)&#123; $counts = count($arr); for ($i = 0; $i &lt; $counts - 1; $i++) &#123; for ($j = 0; $j &lt; $counts - 1; $j++) &#123; if ($i &gt; $j) &#123; continue; &#125; print $arr[$i] . &quot;-&quot; . $arr[$j + 1] . PHP_EOL; &#125; &#125;&#125;$arr = [1, 2, 3, 4, 5];Combination($arr); 输出123456789101-21-31-41-52-32-42-53-43-54-5 在线运行地址http://www.dooccn.com/php7/#id/f1e779eb03e30e7492a4c5d43ff41201","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"技术学习/算法","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"冒泡排序解析","slug":"技术学习/算法/冒泡排序解析","date":"2021-07-26T03:23:17.270Z","updated":"2021-08-10T15:49:13.751Z","comments":true,"path":"post/2235748871.html","link":"","permalink":"https://dd-code.site/post/2235748871.html","excerpt":"","text":"冒泡排序原理比较两个相邻的元素，将值大的元素换到右边。 冒泡排序思路依次比较相邻的两个数，将比较小的数放在前边，比较大的数放在后边。 代码123456789101112131415161718192021/** * 冒泡正序排序 * @param $arr=[2, 3, 5, 1] */public function sort($arr)&#123; $counts = count($arr); if ($counts &lt;= 1) return; for ($i = 0; $i &lt; $counts - 1; $i++) &#123; for ($j = 0; $j &lt; $counts - $i - 1; $j++) &#123; if ($arr[$j] &gt; $arr[$j + 1]) &#123; $tmp = $arr[$j]; $arr[$j] = $arr[$j + 1]; $arr[$j + 1] = $tmp; &#125; &#125; print_r(&quot;第&quot; . $i . &quot;比较后的值：&quot;); print_r($arr); &#125; return $arr;&#125; 结果12345678910111213141516171819202122232425262728293031冒泡正序排序第0比较后的值：Array( [0] =&gt; 2 [1] =&gt; 3 [2] =&gt; 1 [3] =&gt; 5)第1比较后的值：Array( [0] =&gt; 2 [1] =&gt; 1 [2] =&gt; 3 [3] =&gt; 5)第2比较后的值：Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 5)最终结果：Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 5) 12342 3 5 1 #要比较的数组2 3 1 5 #①：第一次比较，比较三次2 1 3 5 #②：第二次比较，比较两次1 2 3 5 #③：第三次比较，比较一次 ①：第一次比较的时候，比较三次，选出最大的数值放到最后一位： 2 和 3 比较，2 小于 3，不动 3 和 5 比较，3 小于 5，不动 5 和 1比较，5 不小于 1，交换位置 结果：2 3 1 5 ②：第二次比较的时候，比较两次，依旧选出最大的数值放到最后一位 2 和 3 比较，2 小于 3，不动 3 和 1 比较，3 不小于 1，交换位置 结果：2 1 3 5 ③：第三次比较的时候，比较一次，依旧选出最大的数值放到最后一位 2 和 1 比较，2 不小于 1，交换位置 结果：1 2 3 5 解析第一个 for 循环指的是外部循环的次数，也就是一共需要比较多少次，比较的次数是数组元素的 count-1 次，所以第一个 for 循环永远是 123for ($i = 0; $i &lt; $counts - 1; $i++) &#123; ......&#125; 第二个 for 循环指的是元素内部比较多少次，元素之间的比较，每次都会选出一个最大值放在最后边，这样的话，每次比较都是 counts-$i-1次，所以第二个循环是： 123for ($j = 0; $j &lt; $counts - $i - 1; $j++) &#123; ......&#125; 进行元素之间比较的时候，如果第一个元素大于第二个元素，就需要交换位置，也就是满足此条件 123if ($arr[$j] &gt; $arr[$j + 1]) &#123; ......&#125; 满足这个条件后，就开始互换位置 123$tmp = $arr[$j];$arr[$j] = $arr[$j + 1];$arr[$j + 1] = $tmp; 最后输出的数组就是经过每次比较交换后的排序数组， 如果需要正序排列，只需要改变条件即可 123if ($arr[$j] &lt; $arr[$j + 1]) &#123; ......&#125; 动画演示 ​","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"技术学习/算法","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://dd-code.site/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"c1","slug":"技术学习/算法/Untitled","date":"2021-07-26T03:23:17.269Z","updated":"2021-08-10T15:49:21.657Z","comments":true,"path":"post/1591159457.html","link":"","permalink":"https://dd-code.site/post/1591159457.html","excerpt":"","text":"大知识点 小知识点 题目 链接 程序逻辑 JavaScript 基础语法 JavaScript基础语法 https://blog.csdn.net/weixin_43232955/article/details/103996930 Javascript基础语法（一） https://blog.csdn.net/fuziwang/article/details/84203289 1.JavaScript基础语法 https://blog.csdn.net/xuehangongzi/article/details/80302175 javascript基础语法 https://blog.csdn.net/m0_37402140/article/details/78695641 JavaScript基础语法知识（一） https://blog.csdn.net/qq_43293778/article/details/106316100 JavaScript(基础语法) https://blog.csdn.net/Amber_Young/article/details/78706442 JavaScript基础语法练习题 https://blog.csdn.net/XH_jing/article/details/104526803 Javascript基础语法总结 https://blog.csdn.net/dreams_deng/article/details/106959736 JavaScript语法基础思维导图 https://blog.csdn.net/qq_39331257/article/details/100057352 JavaScript 的基础语法 使用 https://blog.csdn.net/Sico2Sico/article/details/52998672 JavaScript基础介绍 https://blog.csdn.net/miao_9/article/details/70182958 十、JavaScript 基础 https://blog.csdn.net/qq_52916408/article/details/115681245 JS：JavaScript编程语言基础语法总结 https://blog.csdn.net/qq_42229253/article/details/83855630 JavaScript基础（一） https://blog.csdn.net/hhhhhhhhhhwwwwwwwwww/article/details/106500167 JavaScript基础精讲 https://blog.csdn.net/sdksdk0/article/details/51596213 项目实例 简单的JavaScript项目 https://blog.csdn.net/wjfckx/article/details/109017063 javaScript项目案例 https://blog.csdn.net/xgy123xx/article/details/81089787 面向初学者的21个最佳JavaScript项目创意 https://blog.csdn.net/weixin_26750481/article/details/108132050 适合 JS 新手学习的开源项目——在 GitHub 学编程 https://blog.csdn.net/a419240016/article/details/110618020 20 个前端练手项目合集，个个都“吊炸天”！ https://blog.csdn.net/MOY37RQW1JarN33BgZk/article/details/106152351 JavaScript简单实例 https://blog.csdn.net/lindamtd/article/details/76014599 JavaScript 基础— (经典案例) https://blog.csdn.net/jianghao233/article/details/81319324 JavaScript实例1 https://blog.csdn.net/xiantouxu/article/details/77324138 JavaScript基础知识及实例(一) https://blog.csdn.net/qq_35208312/article/details/74917585 基础 JavaScript 实例 https://blog.csdn.net/suyimin2010/article/details/80467180 面试题 史上最全的Javascript面试题总结（内附答案） https://blog.csdn.net/u011277123/article/details/70208768 25个最基本的JavaScript面试题 https://blog.csdn.net/qq_25186543/article/details/78456984 JavaScript面试 https://blog.csdn.net/weixin_40802058/article/details/88740083 一个JavaScript面试题 https://blog.csdn.net/qq_44997147/article/details/105001213 经典的javascript面试题 https://blog.csdn.net/u014651643/article/details/50684297 javascript面试题 https://blog.csdn.net/weixin_45407236/article/details/114936403 2018最新Web前端经典面试试题及答案 JavaScript面试题 https://blog.csdn.net/bifuguo/article/details/81415699 javascript 面试题 https://blog.csdn.net/weixin_46328144/article/details/108133376 2021前端JavaScript面试题及答案 https://blog.csdn.net/ZS74520/article/details/114991647 JavaScript面试题 https://blog.csdn.net/qq_41999819/article/details/100007234 100个最常问的JavaScript面试问答-第4部分（共10部分） https://blog.csdn.net/qq_44273429/article/details/114240168 javascript经典面试题目 https://blog.csdn.net/lh842824672/article/details/40654509 JavaScript面试题三千问—上篇 https://blog.csdn.net/m0_49993061/article/details/108130154 前端程序员经常忽视的一个JavaScript面试题 https://blog.csdn.net/xsj_blog/article/details/51690490 10道典型的JavaScript面试题+5道JavaScript基础面试题 https://blog.csdn.net/jasonzds/article/details/78366743 笔记总结 javascript 实战总结 https://blog.csdn.net/lishehe/article/details/9253829 JavaScript学习总结 https://blog.csdn.net/IMBA123456789/article/details/47107727 JavaScript学习总结（思维导图篇） https://blog.csdn.net/weixin_41937552/article/details/113854517 JavaScript学习总结1 https://blog.csdn.net/ZGhekuiwu/article/details/53573302 javascript笔记总结篇(全集合) https://blog.csdn.net/lingkeyu/article/details/81515429 JavaScript基础知识总结笔记 https://blog.csdn.net/weixin_41651627/article/details/79106164 javaScript学习笔记总结(一) https://blog.csdn.net/weixin_41937552/article/details/108991120 javascript笔记总结篇 https://blog.csdn.net/sinat_17775997/article/details/84591352 javascript学习笔记-知识点总结-基础知识 (1) https://blog.csdn.net/mfuuty/article/details/112193024 javaScript学习笔记（一）js基础 https://blog.csdn.net/sswqzx/article/details/82796026 web基础 CSS 基础语法 CSS学习之基础语法 https://blog.csdn.net/amrenyu/article/details/80880961 CSS基础语法知识 https://blog.csdn.net/qq_38333529/article/details/82020571 CSS基础语法 https://blog.csdn.net/GY_java0819/article/details/109224236 CSS基础语法讲解 https://blog.csdn.net/changeie/article/details/79123350 CSS基本语法 和 样式规则 https://blog.csdn.net/qq_34283987/article/details/77882184 HTML CSS基本语法 https://blog.csdn.net/Rozol/article/details/69941527 Css基础语法 https://blog.csdn.net/Reoger/article/details/53069949 前端爱好者的小白学习之路-3 CSS学习笔记-用CSS来提升网页开发的效率 学扎实CSS基础语法 麻麻再也不用担心… https://blog.csdn.net/qq_45704942/article/details/113306742 css https://blog.csdn.net/wqeqwr/article/details/100897783 CSS基础学习三：CSS语法 https://blog.csdn.net/erlian1992/article/details/49511559 css3基础知识第一章语法 https://blog.csdn.net/qq_19558705/article/details/49835965 CSS学习笔记（1）CSS基础语法/字体/文本 https://blog.csdn.net/LostPub/article/details/7197978 CSS基础：Flex基本属性 https://blog.csdn.net/jbj6568839z/article/details/114285620 CSS语法与规则 — 重学CS https://blog.csdn.net/TriDiamond6/article/details/108416122 CSS基本语法、查找属性、设置属性等介绍 https://blog.csdn.net/weixin_49114058/article/details/108759685 面试题 面试中css常见的几种问题 https://blog.csdn.net/o_xiaopingguo/article/details/80323046 50道 CSS 经典面试题（包含答案） https://blog.csdn.net/u014697639/article/details/80311559 2019 CSS经典面试题（史上最全，持续更新中…） https://blog.csdn.net/weixin_33691817/article/details/91392503 CSS基本面试题(45道) https://blog.csdn.net/missrl/article/details/106608126 CSS面试题 https://blog.csdn.net/weixin_46232841/article/details/111354318 htmlCSS面试题 https://blog.csdn.net/iocncc/article/details/107050342 CSS面试常见知识点 https://blog.csdn.net/ST_Pace/article/details/78268222 HTML和CSS面试题及答案总结一 https://blog.csdn.net/weixin_42614080/article/details/89046577 css面试题之Flex布局 https://blog.csdn.net/zhangying1996/article/details/110138989 浏览器、html、css面试题（一） https://blog.csdn.net/hrj970808/article/details/109639269 CSS面试题集 https://blog.csdn.net/LongIvan/article/details/83832049 CSS面试之—什么是BFC？ https://blog.csdn.net/qq_41257129/article/details/89641726 HTML/CSS 常见面试题汇总 https://blog.csdn.net/p445098355/article/details/105347920 前端常见html和css面试题（1） https://blog.csdn.net/meikaied/article/details/85160646 50道 CSS 经典面试题（包含答案） https://blog.csdn.net/u014697639/article/details/80311559 轮播图 使用CSS实现简单的图片切换（轮播图） https://blog.csdn.net/qq_43452286/article/details/105185613 纯 CSS 实现图片轮播 https://blog.csdn.net/u011848617/article/details/80468463 纯css实现轮播图 https://blog.csdn.net/tianxintiandisheng/article/details/80375037 如何用纯css3实现轮播图 https://blog.csdn.net/weixin_42276859/article/details/80648944 html+css+JavaScript实现轮播图(新手教程) https://blog.csdn.net/qq_43799743/article/details/89071549 使用HTML+CSS实现轮播图 https://blog.csdn.net/damo01/article/details/95581807 HTML+CSS实现轮播图 https://blog.csdn.net/insist100/article/details/108325595 如何在CSS中实现轮播图 https://blog.csdn.net/zbzuikeai/article/details/107863041 利用css制作简单的轮播图 https://blog.csdn.net/weixin_44929171/article/details/90048075 HTML + CSS 实现轮播图效果 https://blog.csdn.net/qq_43520814/article/details/104681812 动画效果 css动画让文字一行一行逐渐显示 https://blog.csdn.net/Yana5mu/article/details/103684919 CSS动画效果 https://blog.csdn.net/dayexiaofan/article/details/90646354 超好看的css动画特效实现 https://blog.csdn.net/Beryl2580/article/details/105684696 9种常用CSS动画 https://blog.csdn.net/weixin_48871924/article/details/109340535 css 动画 https://blog.csdn.net/melovemingming/article/details/81565262 css3 动画属性详解 https://blog.csdn.net/clmmei_123/article/details/81910157 超详细 CSS动画-animation https://blog.csdn.net/weixin_43742708/article/details/114926809 CSS动画入门：一分钟实现球体上下跳动动画效果 https://blog.csdn.net/ChenXvYuan_001/article/details/86546429 常见 CSS 动画库 https://blog.csdn.net/Abudula__/article/details/81706111 css动画和js动画比较！ https://blog.csdn.net/qq_34986769/article/details/52142430 计算机通识 TCP/IP TCP TCP首部 https://blog.csdn.net/Wu000999/article/details/88623240 TCP 详解 https://blog.csdn.net/sinat_36629696/article/details/80740678 TCP协议详解（一）：TCP头部结构 https://blog.csdn.net/baidu_17611285/article/details/80171239 TCP协议详解 https://blog.csdn.net/qq_37884273/article/details/82188586 五分钟读懂TCP 协议——TCP协议简介 https://blog.csdn.net/Ningdaxing1994/article/details/73076795 TCP是什么？看完你就知道了 https://blog.csdn.net/hayre/article/details/103041478 TCP报文段格式 https://blog.csdn.net/weixin_38497513/article/details/80846679 到底要不要走TCP隧道，要不要TCP over TCP？ https://blog.csdn.net/dog250/article/details/106955747 Modbus TCP协议解析 https://blog.csdn.net/DBLLLLLLLL/article/details/94998674 TCP报文格式详解 https://blog.csdn.net/greywolf0824/article/details/85106197 TCP协议三次握手和四次握手机制-动画详解 https://blog.csdn.net/qq_35860138/article/details/82054793 TCP三次握手原理 https://blog.csdn.net/magic_1024/article/details/102676075 TCP三次握手详解-深入浅出(有图实例演示) https://blog.csdn.net/jun2016425/article/details/81506353 我终于搞懂了TCP的三次握手和四次挥手（图片案例超详解） https://blog.csdn.net/weixin_45393094/article/details/104965561 TCP三次握手和四次挥手详解(面试常见问题) https://blog.csdn.net/wwl012345/article/details/90261423 TCP三次握手详解-深入浅出(有图实例演示) https://blog.csdn.net/jun2016425/article/details/81506353 动画：用动画给面试官解释 TCP 三次握手过程 https://blog.csdn.net/qq_36903042/article/details/102513465 一文彻底搞懂 TCP三次握手、四次挥手过程及原理 https://blog.csdn.net/a519640026/article/details/104448480 TCP三次握手 https://blog.csdn.net/qq_25235807/article/details/103444661 TCP的三次握手(建立连接）和四次挥手(关闭连接） https://blog.csdn.net/weixin_34102807/article/details/85604663 TCP的拥塞控制（详解） https://blog.csdn.net/qq_41431406/article/details/97926927 TCP拥塞控制机制 https://blog.csdn.net/qq_41386300/article/details/90764828 TCP的拥塞控制 https://blog.csdn.net/sicofield/article/details/9708383 TCP的拥塞控制简介 https://blog.csdn.net/sinat_38816924/article/details/111720882 TCP的拥塞控制策略 https://blog.csdn.net/fengqiaojiangshui/article/details/45176847 TCP拥塞控制机制（附面试题） https://blog.csdn.net/shuxnhs/article/details/80644531 详解TCP中的拥塞控制 https://blog.csdn.net/m0_37962600/article/details/79993310 TCP拥塞控制-慢启动、拥塞避免、快重传、快启动 https://blog.csdn.net/jtracydy/article/details/52366461 tcp拥塞控制机制 https://blog.csdn.net/ding283595861/article/details/102793729 TCP拥塞控制 https://blog.csdn.net/Lonelyooacz/article/details/102986921 TCP端口大全 https://blog.csdn.net/willsun2017/article/details/82878690 常见tcp端口 https://blog.csdn.net/weixin_33971130/article/details/85814884 TCP端口协议大全 https://blog.csdn.net/u010164190/article/details/94234295 各种TCP端口详细说明中文版 https://blog.csdn.net/hiyavip/article/details/675162 TCP端口号范围及分类 https://blog.csdn.net/My_heart_/article/details/52601924 笔记：常见TCP端口号 https://blog.csdn.net/CC1770374/article/details/85318869 TCP端口复用 https://blog.csdn.net/baidu_39486224/article/details/83574806 TCP端口号 https://blog.csdn.net/zengfenliang/article/details/79702849 如果希望监听TCP端口9000，应该怎样创建socket? https://blog.csdn.net/sinat_35512245/article/details/54889689 关于TCP协议的端口（port） https://blog.csdn.net/Xiaotongbiji/article/details/81196184 TCP常见面试题 https://blog.csdn.net/mulinsen77/article/details/88925672 TCP面试要点大全 https://blog.csdn.net/guanghuichenshao/article/details/81916277 好教程推荐系列：TCP面试常见题-张小方的知乎Live-轻松搞定技术面试中常见的网络通信问题 https://blog.csdn.net/libaineu2004/article/details/78850227 TCP/IP面试必备 https://blog.csdn.net/m493096871/article/details/88642219 面试必备的TCP知识，都在这里了！ https://blog.csdn.net/qq_42046105/article/details/89078286 TCP协议常见面试题总结 https://blog.csdn.net/Gaodes/article/details/102641166 最全的TCP面试知识点 https://blog.csdn.net/u_nravel/article/details/108641746 TCP面试题(三)之粘包问题 https://blog.csdn.net/Vivid_110/article/details/51001381 TCP总结及常见面试题 https://blog.csdn.net/qq_38211852/article/details/80774434 TCP相关面试题 https://blog.csdn.net/qq_19525389/article/details/81516616 IP 什么是IP地址、IP协议？ https://blog.csdn.net/weixin_43876206/article/details/93021363 IP协议 https://blog.csdn.net/qq_42002936/article/details/99703907 IP协议详解（一） https://blog.csdn.net/qq_42058590/article/details/82918678 IP协议详解 https://blog.csdn.net/qq_41727218/article/details/82461089 IP协议基础 https://blog.csdn.net/niuyuce/article/details/84893891 网络层：IP协议详解（IP协议真的得看这篇） https://blog.csdn.net/Sharp_UP/article/details/78149706 IP协议基础 https://blog.csdn.net/niuyuce/article/details/84893891 什么是IP地址、IP协议？ https://blog.csdn.net/weixin_43876206/article/details/93021363 IP协议基础知识 https://blog.csdn.net/zy010101/article/details/86911774 IP协议的主要特点与格式 https://blog.csdn.net/baidu_33604078/article/details/78135974 IP报文格式详解 https://blog.csdn.net/jack_bro/article/details/106319794 IP协议报文详解 https://blog.csdn.net/gg_ios/article/details/96977623 IP报文格式和实例分析 https://blog.csdn.net/deramer1/article/details/73410019 IP报文头详解以及定义 https://blog.csdn.net/gwb281386172/article/details/90510654 IP数据报文格式 https://blog.csdn.net/capecape/article/details/77882266 IP报文格式学习笔记 https://blog.csdn.net/shinezhang86/article/details/47145907 TCP/IP报文详解 https://blog.csdn.net/Camille66/article/details/90168076 IP报文头部详解 https://blog.csdn.net/weixin_43142797/article/details/105648168 IP报文头详解以及定义 https://blog.csdn.net/gwb281386172/article/details/90510654 IP报文头详解以及定义 https://blog.csdn.net/chenhong53/article/details/48286921 IP协议协议–IP路由 https://blog.csdn.net/qq_29344757/article/details/78585296 通俗理解IP路由 https://blog.csdn.net/chenmo187J3X1/article/details/101163535 一步一步学习IP路由流程 https://blog.csdn.net/lnboxue/article/details/52220928 IP路由原理 https://blog.csdn.net/chaizhong1993/article/details/100965387 浅谈网络层IP路由原理 https://blog.csdn.net/ZP_icenow/article/details/81080184 IP路由和路由表 https://blog.csdn.net/qq_34127958/article/details/70136991 IP路由选择与路由汇聚的基础概念 https://blog.csdn.net/chengoes/article/details/79438295 IP路由选择过程（36步超详细解读） https://blog.csdn.net/weixin_44059188/article/details/99628775 路由优化 https://blog.csdn.net/weixin_42442713/article/details/88981396 IP数据包的路由转发 https://blog.csdn.net/yc1515707718/article/details/103008597 IP和端口号的关系 https://blog.csdn.net/u011630575/article/details/46636851 ip和端口基础知识 https://blog.csdn.net/qq_36171645/article/details/88843122 IP地址和端口号详细解析 https://blog.csdn.net/u013164357/article/details/46363517 IP地址与端口概念 https://blog.csdn.net/wo_shi_LTB/article/details/79041774 IP和端口号 https://blog.csdn.net/weixin_33950757/article/details/90441617 网络通信ip和端口 https://blog.csdn.net/qq_29286967/article/details/81026677 ip端口重定向 https://blog.csdn.net/gdfsbingfeng/article/details/8538685 IP端口号可以最大到多少个？ https://blog.csdn.net/weixin_45418665/article/details/106100007 IP、域名和端口号之间的联系 https://blog.csdn.net/fightsyj/article/details/86482820 IP和端口号 https://blog.csdn.net/weixin_33950757/article/details/90441617 TCP/IP面试必备 https://blog.csdn.net/m493096871/article/details/88642219 TCP/IP常见面试题 https://blog.csdn.net/hyp1977/article/details/52150182 TCP/IP常见面试问题 https://blog.csdn.net/qq_41932224/article/details/107041242 TCP/IP面试 https://blog.csdn.net/z19890613/article/details/98759772 HTTP、TCP、IP协议常见面试题 https://blog.csdn.net/weixin_42716620/article/details/82888576 TCP/IP面试题 https://blog.csdn.net/sunsfan/article/details/52953262 TCP/IP 面试题整理 https://blog.csdn.net/qq_40086556/article/details/82017916 常见TCP/IP面试题（边学边补充） https://blog.csdn.net/E_kunt/article/details/52623614 TCP/IP协议简述+常见面试题 https://blog.csdn.net/Summer_Lyf/article/details/84024072 TCP/IP面试题（一） https://blog.csdn.net/zhanghaotian2011/article/details/9331629 计算机通识 HTTP 基础 HTTP协议分析 https://blog.csdn.net/qq_38265137/article/details/93379922 HTTP协议——HyperText Transfer Protocol（超文本传输协议） https://blog.csdn.net/huangwwu11/article/details/23531111 HyperText Transfer protocol https://blog.csdn.net/zengibm/article/details/79440328 HTTP是什么 https://blog.csdn.net/NoodleDD/article/details/108362246 HTTP常用方法 https://blog.csdn.net/wuyoudeyuer/article/details/80509901 HTTP协议其实就是这么简单 https://blog.csdn.net/cai784921129/article/details/80177753 http概述（相关详解） https://blog.csdn.net/weixin_41229588/article/details/106786984 HTTP1.0和HTTP1.1和HTTP2.0的区别 https://blog.csdn.net/ailunlee/article/details/97831912 HTTP协议详解 https://blog.csdn.net/aliujiujiang/article/details/81088317 HTTP协议简单解释 https://blog.csdn.net/u010710458/article/details/79636625 99%的人都理解错了HTTP中GET与POST的区别 https://blog.csdn.net/eson_15/article/details/88083280 HTTP 结构详解 https://blog.csdn.net/qq_40193787/article/details/108662132 http协议各个版本 https://blog.csdn.net/qq_22238021/article/details/81197157 HTTP协议由哪些部分组成？ https://blog.csdn.net/qq_37189082/article/details/98642450 一文搞懂HTTP协议（带图文） https://blog.csdn.net/weixin_42709563/article/details/106433654 HTTP协议 https://blog.csdn.net/weixin_41483934/article/details/111657924 HTTP协议简单介绍以及常用协议端口 https://blog.csdn.net/weixin_41551445/article/details/98313097 HTTP协议不同版本的区别 https://blog.csdn.net/moge19/article/details/90050030 快速理解 HTTP协议 https://blog.csdn.net/guhong888/article/details/89400916 HTTP协议：无状态协议 https://blog.csdn.net/wd2014610/article/details/78116791 方法 HTTP协议——HTTP方法 https://blog.csdn.net/vikeyyyy/article/details/80655115 HTTP的危险方法（不安全的HTTP方法） https://blog.csdn.net/weixin_45116657/article/details/102865810 HTTP常用方法 https://blog.csdn.net/wuyoudeyuer/article/details/80509901 HTTP请求方式中8种请求方法（简单介绍） https://blog.csdn.net/weixin_42981419/article/details/86162244 不安全的http方法 https://blog.csdn.net/qq_35569814/article/details/100570029 此URL不支持Http方法POST &gt;&gt;&gt; 解决方法 https://blog.csdn.net/caomei_rat/article/details/101124786 禁用不安全的http方法 https://blog.csdn.net/qq_31225293/article/details/79386272 启用了不安全的HTTP方法 https://blog.csdn.net/github_37216944/article/details/79570630 HTTP请求方法 https://blog.csdn.net/xinyan233/article/details/79986720 HTTP最常用的6种请求方法 https://blog.csdn.net/sc179/article/details/111316800 请求过程 http会话的四个过程 https://blog.csdn.net/xieliang0717/article/details/77722497 HTTP请求的完全过程 https://blog.csdn.net/ailunlee/article/details/90600174 一个完整的HTTP请求过程详细 https://blog.csdn.net/u013777975/article/details/80496121 HTTP的请求过程 https://blog.csdn.net/hanziang1996/article/details/78982009 一个http请求的详细过程 https://blog.csdn.net/winder1997/article/details/75093184 浏览器发送http请求过程分析 https://blog.csdn.net/hyy147/article/details/90403042 一次完整的Http请求过程（非常详细 https://blog.csdn.net/zjkC050818/article/details/78345819 http一次请求和响应的全过程 https://blog.csdn.net/weixin_41047704/article/details/82591760 一次完整的HTTP请求所经历的7个步骤 https://blog.csdn.net/skyxmstar/article/details/68059927 一次完整的HTTP过程请求步骤（输入一个URL回车，到返回页面） https://blog.csdn.net/seebetpro/article/details/51326260 报文 HTTP协议报文结构 https://blog.csdn.net/u022812849/article/details/109448389 HTTP报文格式详解 https://blog.csdn.net/zx_emily/article/details/83024065 HTTP报文的结构 https://blog.csdn.net/kongmin_123/article/details/82154780 http请求报文和响应报文 https://blog.csdn.net/lyn_00/article/details/84953763 HTTP协议之报文详解 https://blog.csdn.net/yipiankongbai/article/details/24176693 HTTP报文的结构 https://blog.csdn.net/kongmin_123/article/details/82154780 HTTP报文分析 https://blog.csdn.net/qq_26565861/article/details/80969960 HTTP报文 https://blog.csdn.net/zhll3377/article/details/7748086 HTTP协议报文格式 https://blog.csdn.net/xyx107/article/details/80436261 HTTP协议报文解析 https://blog.csdn.net/yutiab69/article/details/82869239 详解http报文 https://blog.csdn.net/FS1360472174/article/details/101794045 HTTP协议——HTTP报文组成 https://blog.csdn.net/vikeyyyy/article/details/80612178 HTTP报文组成结构 https://blog.csdn.net/weixin_44339224/article/details/88430382 HTTP报文查询 https://blog.csdn.net/weixin_45798017/article/details/105001795 HTTP报文实例分析 https://blog.csdn.net/windyf2013/article/details/77835853 状态码 HTTP状态码（超详细） https://blog.csdn.net/weixin_41948075/article/details/89046934 HTTP状态码 https://blog.csdn.net/u013286948/article/details/105997951 http状态码大全（最全整理） https://blog.csdn.net/xiaohuihui501/article/details/99710590 常见HTTP状态码大全 https://blog.csdn.net/hliq5399/article/details/51351706 http状态码总结 https://blog.csdn.net/wzx19840423/article/details/79073087 常见的HTTP状态码(HTTP Status Code)说明 https://blog.csdn.net/dufufd/article/details/53112184 HTTP状态码（报错/200/301/404/500 ） https://blog.csdn.net/qq_36908872/article/details/94157930 HTTP常见状态码（14种） https://blog.csdn.net/banana960531/article/details/85621865 巧记HTTP状态码 https://blog.csdn.net/guhong888/article/details/89410283 HTTP状态码全部说明 https://blog.csdn.net/weixin_41229588/article/details/105683958 HTTP状态码详解 https://blog.csdn.net/qiaqia609/article/details/45741149 常见的HTTP状态码有哪些 https://blog.csdn.net/laishaohe/article/details/79052085 HTTP状态码一览表 https://blog.csdn.net/zml_2015/article/details/51051217 服务器返回的14种常见HTTP状态码 https://blog.csdn.net/q1056843325/article/details/53147180 http状态码401 https://blog.csdn.net/liukai6/article/details/80375412 HTTPS HTTP和HTTPS协议，看一篇就够了 https://blog.csdn.net/xiaoming100001/article/details/81109617 HTTP与HTTPS的区别 https://blog.csdn.net/JAck_chen0309/article/details/105020259 HTTP与HTTPS的区别，详细介绍 https://blog.csdn.net/qq_35642036/article/details/82788421 一文就让你搞懂http和https的通信过程及区别 https://blog.csdn.net/weixin_41635750/article/details/109069891 HTTP和HTTPS详解 https://blog.csdn.net/mingli198611/article/details/8055261 HTTP与HTTPS的概念和区别 https://blog.csdn.net/shenhaiwen/article/details/73289087 HTTP和HTTPS的区别 https://blog.csdn.net/qq_36908872/article/details/80602437 http协议与https协议 https://blog.csdn.net/qq_36522306/article/details/81053689 HTTP 和 HTTPS 的区别（面试常考题） https://blog.csdn.net/qq_38289815/article/details/80969419 http与https的差别 https://blog.csdn.net/qq_40679091/article/details/109170697 关于HTTP和HTTPS的区别 https://blog.csdn.net/web_yzm/article/details/81128132 前端面试总结 – 网络基础之 HTTP 和 HTTPS https://blog.csdn.net/zgh0711/article/details/81567818 关于HTTP和HTTPS的安全问题 https://blog.csdn.net/f2652349894/article/details/77748753 HTTP和HTTPS协议 https://blog.csdn.net/imaginehero/article/details/102559214 面试常考点：http和https的区别与联系 https://blog.csdn.net/xionghuixionghui/article/details/68569282 面试题 看完这篇HTTP，跟面试官扯皮就没问题了 https://blog.csdn.net/qq_36894974/article/details/103930478 HTTP协议经典面试题整理及答案详解 https://blog.csdn.net/heihaozi/article/details/104843595 HTTP常见面试题 https://blog.csdn.net/boke_fengwei/article/details/95257483 HTTP面试题(简单总结一下) https://blog.csdn.net/qq_35433716/article/details/87891553 面试重点http面试题 https://blog.csdn.net/weixin_41406727/article/details/106939690 Web前端面试——HTTP部分 https://blog.csdn.net/u012194956/article/details/79110212 HTTP面试题汇总 https://blog.csdn.net/qq_39519224/article/details/100192037 Http协议面试题小结 https://blog.csdn.net/weixin_38051694/article/details/77777010 必看之浅谈HTTP与HTTPS区别 https://blog.csdn.net/a1034996/article/details/105952634 Http协议常见面试题 https://blog.csdn.net/weixin_34380948/article/details/88715623 HTTP协议经典面试题 https://blog.csdn.net/qq_40714902/article/details/78777688 HTTP必知必会——常见面试题总结 https://blog.csdn.net/zhangliangzi/article/details/51336564 面试官问你HTTP状态码，你敢答吗？ https://blog.csdn.net/weixin_42292229/article/details/105240877 经典面试题：HTTP协议理解 https://blog.csdn.net/qq_31617637/article/details/87932791 常见面试题：简单说下对HTTP协议的了解 https://blog.csdn.net/t8116189520/article/details/80037276 计算机通识 数据编码 数据编码 计算机数值数据编码（原码，反码，补码，移码） https://blog.csdn.net/dai_ma_dong/article/details/88853006 原码, 反码, 补码 详解(转载) https://blog.csdn.net/qq_35386002/article/details/89178939 什么是原码？ https://blog.csdn.net/qq_46023700/article/details/113097510 原码-反码-补码 –数学公式分析 https://blog.csdn.net/qq_34771697/article/details/77972501 原码、补码、反码 https://blog.csdn.net/q1606464914/article/details/106788937 计算机中的原码，反码，补码 https://blog.csdn.net/m0_51262868/article/details/114501184 原码, 反码, 补码 https://blog.csdn.net/pipisorry/article/details/71157146 原码, 反码, 补码 详解 https://blog.csdn.net/plyzz/article/details/106648718 2、原码 https://blog.csdn.net/xiebs/article/details/100133487 原创什么是原码、反码、补码？ https://blog.csdn.net/boyzhaotian/article/details/83790193 转—原码，反码，补码的深入理解与原理。 https://blog.csdn.net/zhiwen_a/article/details/81192087 原码表示 https://blog.csdn.net/xiebs/article/details/103938120 任意位宽的补码转原码，原码转补码 https://blog.csdn.net/cainiaofu/article/details/108601943 原码的定义公式怎么理解_原码、补码、反码详细总结 https://blog.csdn.net/weixin_32306771/article/details/112773291 原码补码反码转换器_计算机组成原理原码、反码、补码 https://blog.csdn.net/weixin_34282589/article/details/113411888 分数的原码、反码、补码如何求 https://blog.csdn.net/weixin_42670775/article/details/102920912 原码 反码 换算工具 补码_原码和补码的换算(原码反码补码转换工具) https://blog.csdn.net/weixin_39980347/article/details/114014756 原码乘法运算 https://blog.csdn.net/David_Morgan/article/details/114926740 原码的定义公式怎么理解_原码、反码、补码……这回终于明白了！ https://blog.csdn.net/weixin_30977095/article/details/113033982 原码、补码、反码的关系 https://blog.csdn.net/a549654065/article/details/108555925 详解原码反码与补码 https://blog.csdn.net/zjxxyz123/article/details/79122487 java 原码 补码 反码 https://blog.csdn.net/weixin_43599377/article/details/98050416 快速求补码和原码 https://blog.csdn.net/qq_34022601/article/details/88601297 原码除法 https://blog.csdn.net/brokenkay/article/details/108683374 一位原码的乘法规则_原码一位乘法的实现算法 https://blog.csdn.net/weixin_39637614/article/details/111846237 进制基础 二进制基础 https://blog.csdn.net/weixin_46088439/article/details/112302039 二进制 https://blog.csdn.net/lyb2518/article/details/90348111 （二进制） https://blog.csdn.net/m0_50855211/article/details/111750195 二进制详解 https://blog.csdn.net/u014535295/article/details/80804777 什么是二进制,进制之间是如何转换的,浅显易懂的,一看就会 https://blog.csdn.net/l284969634/article/details/104774044 八进制 https://blog.csdn.net/kongsanjin/article/details/79534953 十六进制 https://blog.csdn.net/xueguchen/article/details/108981148 十六进制&amp;运算 https://blog.csdn.net/onOneLight/article/details/89630436 16进制数的表示方法及转换 https://blog.csdn.net/qq_41536539/article/details/99648958 什么是十六进制法_十六进制的定义 十六进制的转换介绍详解 https://blog.csdn.net/weixin_39853843/article/details/112049210 十六进制的转换 https://blog.csdn.net/weixin_45577185/article/details/103291994 彻底弄明白十六进制 https://blog.csdn.net/fengjssy/article/details/7692070 二进制和十六进制 https://blog.csdn.net/langhonglin/article/details/81734959 十六进制整数 https://blog.csdn.net/Javaxuxuexi/article/details/93136508 什么是十六进制法_十六进制的定义 十六进制的转换介绍详解 https://blog.csdn.net/weixin_39853843/article/details/112049210 进制转换 二进制、八进制、十进制、十六进制之间的转换 https://blog.csdn.net/baiofchao/article/details/112250086 二进制&amp;&amp;十六进制转换表 https://blog.csdn.net/Lucis_tomato/article/details/115463257 （十进制转换二进制、八进制、十六进制 ）&amp;&amp;（二进制转八进制、十进制、十六进制 https://blog.csdn.net/qq_38587650/article/details/101803087 [参考]ASCII对照表 及 字符与二进制、十进制、16进制之间的转化（C/C++） https://blog.csdn.net/JD13514611076/article/details/101621221 二进制、十六进制和十进制的转换算法 https://blog.csdn.net/weixin_30340745/article/details/98028816 二进制、八进制、十进制与十六进制，最全，没有之一 https://blog.csdn.net/hcmony/article/details/75530067 二、八、十、十六进制转换（图解篇） https://blog.csdn.net/liangxw1/article/details/78535545 计算机基础进制转换（二进制、八进制、十进制、十六进制） https://blog.csdn.net/yuanxiang01/article/details/82503568 2进制 , 8进制 , 10进制 , 16进制 , 介绍 及 相互转换 及 快速转换的方法 https://blog.csdn.net/diyu122222/article/details/80692904 八进制换算成二进制、十进制、十六进制 https://blog.csdn.net/weixin_44566320/article/details/89513114 进制转换：二进制、八进制、十六进制、十进制之间的转换 https://blog.csdn.net/liubing8609/article/details/82695059 二进制、八进制、十进制、十六进制关系及转换 https://blog.csdn.net/ruidianbaihuo/article/details/87797979 十六进制转八进制（浅显易懂） https://blog.csdn.net/qq_39378657/article/details/88074742 二进制转换八进制图解_一文帮你详细图解二进制、八进制、十进制、十六进制之间的转换… https://blog.csdn.net/weixin_42365170/article/details/113004904 二进制转换八进制图解_二、八、十、十六进制转换（图解篇） https://blog.csdn.net/weixin_34587189/article/details/111954439 二进制、八进制、十六进制的转换 https://blog.csdn.net/qq_42194657/article/details/101703101 十六进制小数_二进制，十进制（包含小数）相互转换 https://blog.csdn.net/weixin_39640221/article/details/111383639 各种进制转换（二，八，十，十六进制间转换）详解附代码 https://blog.csdn.net/qq_41785863/article/details/84101711 二进制、十进制、十六进制数值对照表 https://blog.csdn.net/jack_bob/article/details/80593766 浮点数与十六进制互相转换 https://blog.csdn.net/nicai_xiaoqinxi/article/details/100021218 进制计算 十六进制的加、减、乘、除、左移、右移计算 https://blog.csdn.net/weixin_42108484/article/details/101380530 进制的计算方法 https://blog.csdn.net/YL970302/article/details/79596799 计算机2进制、4进制、8进制、10进制、16进制、32进制计算规则 https://blog.csdn.net/loongshawn/article/details/81269761 进制计算问题 https://blog.csdn.net/zhanxiao5287/article/details/80001279 进制的计算 -汇编 https://blog.csdn.net/haibin8473/article/details/78883710 进制计算与转换 https://blog.csdn.net/alex1997222/article/details/82768231 二进制 计算 https://blog.csdn.net/wu15010861923/article/details/89949107 计算机二进制计算过程 https://blog.csdn.net/weixin_40845192/article/details/110878450 二进制转十进制计算方法 https://blog.csdn.net/qq_43640414/article/details/84335429 16进制计算方法 https://blog.csdn.net/weixin_30385925/article/details/97390321 base64 Base64 四种方式的编码和解码 https://blog.csdn.net/qq_38080370/article/details/102552009 base64编码和解码 https://blog.csdn.net/u013008795/article/details/89576973 js实现基于Base64的编码及解码 https://blog.csdn.net/weixin_42420703/article/details/81384901 Base64编码与解码 https://blog.csdn.net/u010839382/article/details/40748887 C语言实现Base64编码/解码 https://blog.csdn.net/qq_26093511/article/details/78836087 Python中Base64编码与解码 https://blog.csdn.net/pengjunlee/article/details/91127222 base64解码详解 https://blog.csdn.net/xbk123123/article/details/53513957 关于Base64编码(Encode)与解码(Decode)的几种方式，这里面有道道 https://blog.csdn.net/weixin_44259720/article/details/109784917 Base64编码解码原理详解 https://blog.csdn.net/u013412497/article/details/51552335 Base64加密解密 https://blog.csdn.net/huangxiaoguo1/article/details/78042715 base64解码是什么 https://blog.csdn.net/qq_14989227/article/details/79470110 使用base64解码url掉的坑 https://blog.csdn.net/weixin_44704285/article/details/88898269 BASE64解码之中文乱码问题 https://blog.csdn.net/yangdiao127/article/details/62421195 //BASE64解码成File文件 https://blog.csdn.net/qq_45317823/article/details/104395901 Flutter base64解码中文乱码 https://blog.csdn.net/u011050129/article/details/107111594 javaScript中使用base64解码与编码 https://blog.csdn.net/tqy19921202/article/details/80814099 解码Base64并展示图片 https://blog.csdn.net/Android_xue/article/details/78259943 Java中Base64解码中文的深坑 https://blog.csdn.net/qq_34458791/article/details/86690599 Base64编解码工具类 https://blog.csdn.net/tanhongwei1994/article/details/83659252 Base64–图片base64解码简说 https://blog.csdn.net/szzt_lingpeng/article/details/82494913 二进制炸弹 作业_二进制炸弹_手把手教学讲解 https://blog.csdn.net/cena1001/article/details/109570188 二进制炸弹攻略 https://blog.csdn.net/weixin_44175879/article/details/102860872 二进制炸弹 https://blog.csdn.net/weixin_45820190/article/details/104349315 二进制炸弹及gdb调试分析 https://blog.csdn.net/m0_46107987/article/details/108395069 二进制炸弹实验binarybomb 拆弹 https://blog.csdn.net/neverever01/article/details/78403412 二进制炸弹——拆弹实验 https://blog.csdn.net/weixin_43074474/article/details/88902228 二进制炸弹实验 https://blog.csdn.net/dl970220/article/details/78200149 拆解二进制炸弹 https://blog.csdn.net/yulin_huangzhe/article/details/103203674 Binary Bomb 二进制炸弹 https://blog.csdn.net/weixin_43821874/article/details/86481120 CSAPP的二进制炸弹实验 https://blog.csdn.net/qq_29612117/article/details/50725531 常用数据结构和算法 1 收集51种经典算法 初学者必备 https://blog.csdn.net/Helloyongwei/article/details/80178301 2 十大经典算法 https://blog.csdn.net/M_Jack/article/details/112858375 3 2020最新-精选基础算法100题（面试必备） https://blog.csdn.net/ATFWUS/article/details/106193067 4 算法设计——五大算法总结 https://blog.csdn.net/yuanmartin/article/details/108600242 5 为有机会进大厂，程序员必须掌握的核心算法有哪些？ https://blog.csdn.net/m0_37907797/article/details/102661778 6 蓝桥杯知识点汇总：基础知识和常用算法 https://blog.csdn.net/GD_ONE/article/details/104061907 7 五大常用算法最全面总结 https://blog.csdn.net/wei2019_/article/details/108129814 8 算法#16–B树完整代码Java实现 https://blog.csdn.net/tclxspy/article/details/52535605 9 B树详细图解与Java完整实现 https://blog.csdn.net/jimo_lonely/article/details/82716142 10 经典算法（5）杨辉三角 https://blog.csdn.net/weixin_43570367/article/details/102900775 11 通俗易懂的字符串匹配KMP算法及求next值算法 https://blog.csdn.net/qq_37969433/article/details/82947411 12 简单易懂——Dijkstra算法讲解 https://blog.csdn.net/qq_39521554/article/details/79333690 13 BF算法 https://blog.csdn.net/free377096858/article/details/88783339 14 粒子群算法及其改进算法 https://blog.csdn.net/weixin_45307421/article/details/94043473 15 推荐算法概述（基于用户的协同过滤算法、基于物品的协同过滤算法、基于内容的推荐算法） https://blog.csdn.net/u011630575/article/details/80171597 16 防劝退！数据结构和算法难理解？可视化动画带你轻松透彻理解！ https://blog.csdn.net/u013486414/article/details/103199260 17 图像识别算法 https://blog.csdn.net/dongshizhishui/article/details/99646512 18 最优化算法之粒子群算法（PSO） https://blog.csdn.net/daaikuaichuan/article/details/81382794 19 简述灰狼优化算法（GWO）原理 https://blog.csdn.net/haha0332/article/details/88805910 20 数据结构（严蔚敏版）与算法的实现（含全部代码） https://blog.csdn.net/lady_killer9/article/details/82695895 21 KMP算法—终于全部弄懂了 https://blog.csdn.net/dark_cy/article/details/88698736 22 页面置换算法-CLOCK置换算法及其改进版算法 https://blog.csdn.net/zhuixun_/article/details/85336417 23 经典蝙蝠算法MATLAB实现 https://blog.csdn.net/xyisv/article/details/87907964 24 十大经典算法 https://blog.csdn.net/qq_42495360/article/details/80746548 25 人工智能常见算法简介 https://blog.csdn.net/weixin_42137700/article/details/87355812 26 机器学习算法 综述（入门） https://blog.csdn.net/qq_41204464/article/details/92431679 27 银行家算法 https://blog.csdn.net/qq_34649947/article/details/70224868 28 免疫算法 https://blog.csdn.net/zuochao_2013/article/details/71698418 29 快速排序算法 https://blog.csdn.net/elma_tww/article/details/86164674 30 算法基础知识 https://blog.csdn.net/MingXi__HeXi/article/details/56672793 31 计算机10大经典算法 https://blog.csdn.net/kiss__soul/article/details/80622053 32 C++ 秦九韶算法 https://blog.csdn.net/qq_34907362/article/details/80066465 33 基于遗传算法的BP神经网络的股票预测模型 https://blog.csdn.net/zxm_jimin/article/details/87936920 34 遗传算法 https://blog.csdn.net/foreverling/article/details/44652463 35 遗传算法python实现（适合初学者） https://blog.csdn.net/m0_38101326/article/details/90642193 36 枚举算法 https://blog.csdn.net/qq_38265137/article/details/84980549 37 数据结构与算法中的经典算法 https://blog.csdn.net/yph001/article/details/81123414 38 哈希算法 https://blog.csdn.net/liushengxi_root/article/details/86571193 39 RRT路径规划算法 https://blog.csdn.net/aoyousihaiqiuqihuang/article/details/100147478 40 OI算法图谱 https://blog.csdn.net/justidle/article/details/103378749 41 萤火虫算法（Firefly Algorithm） https://blog.csdn.net/weixin_42320872/article/details/102995404 42 图像去雾算法 https://blog.csdn.net/l641208111/article/details/113832322 43 五大常用算法总结 https://blog.csdn.net/changyuanchn/article/details/51476281 44 典型推荐算法总结 https://blog.csdn.net/u011095110/article/details/84403564 45 五种基本算法思想 https://blog.csdn.net/qq_25740691/article/details/78894177 46 Dijkstra算法图文详解 https://blog.csdn.net/lbperfect123/article/details/84281300 47 DES算法详细设计 https://blog.csdn.net/mingyf/article/details/78168106 48 抖音推荐算法总结 https://blog.csdn.net/sinat_26811377/article/details/103217551 49 数据挖掘算法——常用分类算法总结 https://blog.csdn.net/songguangfan/article/details/92581643 50 怎样成为一名优秀的算法工程师 https://blog.csdn.net/SIGAI_CSDN/article/details/81012167 51 52 为有机会进大厂，程序员必须掌握的核心算法有哪些？ https://blog.csdn.net/m0_37907797/article/details/102661778 53 基础知识和常用算法 https://blog.csdn.net/GD_ONE/article/details/104061907 54 经典中的经典算法:动态规划(详细解释,从入门到实践,逐步讲解) https://blog.csdn.net/ailaojie/article/details/83014821 55 数据结构与算法——从零开始学习（一）基础概念篇 https://blog.csdn.net/csdn_aiyang/article/details/84837553 56 Java笔试面试-算法常用面试题 https://blog.csdn.net/huanglei305/article/details/103149074 57 一份简短又全面的数学建模技能图谱：常用模型&amp;算法总结 https://blog.csdn.net/qq_29831163/article/details/89788999 58 五大常用算法总结 https://blog.csdn.net/changyuanchn/article/details/51476281 59 c语言常用算法整理 https://blog.csdn.net/mhhyoucom/article/details/87929783 60 人工智能 之 机器学习常用算法总结 及 各个常用分类算法精确率对比 https://blog.csdn.net/u014597198/article/details/85309295 61 TF-IDF算法介绍及实现 https://blog.csdn.net/asialee_bird/article/details/81486700 62 超详细十大经典排序算法总结（java代码）c或者cpp的也可以明白 https://blog.csdn.net/weixin_41190227/article/details/86600821 63 96道前端面试题+前端常用算法 https://blog.csdn.net/QXXXD/article/details/113113311 64 (java)五大常用算法 https://blog.csdn.net/qq_39147389/article/details/82252924 65 各种聚类算法的介绍和比较 https://blog.csdn.net/abc200941410128/article/details/78541273 66 数据挖掘算法——常用分类算法总结 https://blog.csdn.net/songguangfan/article/details/92581643 67 算法系列之九：计算几何与图形学有关的几种常用算法（一） https://blog.csdn.net/orbit/article/details/7082678 68 五大常用算法入门（一）——贪心算法 https://blog.csdn.net/Africa_South/article/details/87924966 69 图解十大经典机器学习算法入门 https://blog.csdn.net/jrunw/article/details/79205322 70 五大常用算法 https://blog.csdn.net/caizongxu/article/details/82941968 71 JS常见算法小总结 https://blog.csdn.net/weixin_43606158/article/details/90209343 72 算法工程师必须要知道的8种常用算法思想 https://blog.csdn.net/weixin_42137700/article/details/86777003 73 五大常用算法学习笔记 https://blog.csdn.net/shijinghan1126/article/details/87951372 74 五大常用算法——贪心算法详解及经典例子 https://blog.csdn.net/qq_37763204/article/details/79289532 75 Java常用排序算法/程序员必须掌握的8大排序算法 https://blog.csdn.net/qy1387/article/details/7752973 76 常用数据结构与常用算法， https://blog.csdn.net/zzh8578741/article/details/81515000 77 推荐系统的几种常用算法总结 https://blog.csdn.net/Vensmallzeng/article/details/101343117 78 C语言常用算法题 （嵌入式算法题） 28道 https://blog.csdn.net/i2blue/article/details/81213484 79 ACM 常用算法合集 https://blog.csdn.net/u011815404/article/details/79919616 80 java常用算法整理 https://blog.csdn.net/mhhyoucom/article/details/79425830 81 人脸识别各算法详解 https://blog.csdn.net/weixin_42713739/article/details/89214716 82 MATLAB语言常用算法程序集 https://blog.csdn.net/zhangkaihang/article/details/7958201 83 图像处理常用算法(基础) https://blog.csdn.net/echo_1994/article/details/81612598 84 五大常用算法总结 https://blog.csdn.net/qq_40788630/article/details/79503946 85 轻松看懂机器学习十大常用算法 https://blog.csdn.net/aliceyangxi1987/article/details/71079440 86 图论常用算法 https://blog.csdn.net/weixin_38686780/article/details/77244247 87 五大常用算法 https://blog.csdn.net/qq_36068521/article/details/81132934 88 控制算法之PID算法 | 从入门到理解到应用 （一发入魂） https://blog.csdn.net/weixin_42881419/article/details/86551249 89 数据结构和常用算法 https://blog.csdn.net/miracle_gu/article/details/48860121 信息/编码 信息分类编码】 https://blog.csdn.net/qiuhaifeng_csu/article/details/8636384 计算机基础进制转换（二进制、八进制、十进制、十六进制）】 https://blog.csdn.net/yuanxiang01/article/details/82503568 c语言中16进制转换为十进制】 https://blog.csdn.net/zhangjianjun521/article/details/79081435 二进制,十进制,八进制,十六进制转换】 https://blog.csdn.net/csweldn520/article/details/86035910 二进制、八进制、十进制、十六进制关系及转换】 https://blog.csdn.net/ruidianbaihuo/article/details/87797979 2进制 , 8进制 , 10进制 , 16进制 , 介绍 及 相互转换 及 快速转换的方法】 https://blog.csdn.net/diyu122222/article/details/80692904 C语言实现任意进制数之间的转换】 https://blog.csdn.net/qq_36454961/article/details/79174645 C++中的各种进制转换函数汇总】 https://blog.csdn.net/vir_lee/article/details/80645066 C语言算法之将十进制数转换成二进制数】 https://blog.csdn.net/weixin_41676881/article/details/80745177 进制之间的转换（二进制、八进制、十进制、十六进制）】 https://blog.csdn.net/mez_Blog/article/details/91354750 JAVA 进制转换的几个方法】 https://blog.csdn.net/m0_37961948/article/details/80438113 进制转换方法总结——摘自百度】 https://blog.csdn.net/final__static/article/details/89405945 各种进制转换（二，八，十，十六进制间转换）详解附代码】 https://blog.csdn.net/qq_41785863/article/details/84101711 进制转换：二进制、八进制、十六进制、十进制之间的转换】 https://blog.csdn.net/liubing8609/article/details/82695059 PCM音频采样数据编码为AAC的压缩编码数据】 https://blog.csdn.net/ZH952016281/article/details/52768415 三种常用的数字数据编码方式】 https://blog.csdn.net/qq_34902437/article/details/89515451 数据结构(15)–哈夫曼树以及哈夫曼编码的实现】 https://blog.csdn.net/u010366748/article/details/50773903 数据预处理：独热编码（One-Hot Encoding）】 https://blog.csdn.net/pipisorry/article/details/61193868 IP/组网 网关和网段区别】 https://blog.csdn.net/ARCH_Yang/article/details/82626717 IP地址，子网掩码、默认网关，DNS服务器之间的联系与区别】 https://blog.csdn.net/hexf9632/article/details/93469788 IP地址，子网掩码、默认网关，DNS服务器是什么意思?】 https://blog.csdn.net/bilter/article/details/6999511 192.168.和10.0.开头的IP、内网IP段、IP简介、分类——（IP观止）】 https://blog.csdn.net/superit401/article/details/78246298 太厉害了，终于有人能把TCP/IP 协议讲的明明白白了】 https://blog.csdn.net/wuzhiwei549/article/details/105965493 TCP/IP协议详解】 https://blog.csdn.net/weixin_44198965/article/details/90083126 计算机网络 | 一文搞懂什么是TCP/IP协议】 https://blog.csdn.net/petterp/article/details/102779131 实现基于 TCP/IP 协议简单的客户端、服务器通信程序实例】 https://blog.csdn.net/shenjie12345678/article/details/28321969 网络协议、socket、webSocket】 https://blog.csdn.net/yjclsx/article/details/80922951 Windows设置本地DNS域名解析Hosts】 https://blog.csdn.net/sgs595595/article/details/78779870 Linux中搭建DNS服务器】 https://blog.csdn.net/qq_36119192/article/details/82752515 防火墙访问控制Access Control】 https://blog.csdn.net/wenze123/article/details/87940776 防火墙按照访问控制方式分类】 https://blog.csdn.net/weixin_43915762/article/details/86155009 防火墙原理与定义】 https://blog.csdn.net/weixin_44309905/article/details/111304868 程序逻辑 《使用java理解程序逻辑》第一章总结】 https://blog.csdn.net/qq_41060007/article/details/79842658 程序逻辑问题–实验吧】 https://blog.csdn.net/dongyanwen6036/article/details/77768345 javaScript学习笔记（一）js基础】 https://blog.csdn.net/sswqzx/article/details/82796026 HTML-JavaScript基础（非常详细）】 https://blog.csdn.net/nanjinzhu/article/details/82717753 JS基础重点知识实验总结(全)】 https://blog.csdn.net/lvanboy/article/details/88542746 JS基础篇1：数据类型（8种）】 https://blog.csdn.net/u013592575/article/details/95087953 JavaScript基础内功系列，这十篇文章里一定有你感兴趣的】 https://blog.csdn.net/jbj6568839z/article/details/107402963 js基础知识总结（一）】 https://blog.csdn.net/xuehu837769474/article/details/81811010 JavaScript基础题、练习题、考试题、面试题（一）】 https://blog.csdn.net/ZHANGJIN9546/article/details/93670094 JavaScript 基础笔记】 https://blog.csdn.net/qq_43645678/article/details/93380462 JavaScript基础知识总结笔记】 https://blog.csdn.net/weixin_41651627/article/details/79106164 最通俗易懂的JavaScript入门教程】 https://blog.csdn.net/jiahuan_/article/details/105895421 JavaScript 基础— (经典案例)】 https://blog.csdn.net/jianghao233/article/details/81319324 JavaScript学习笔记（一）——JS基础知识介绍】 https://blog.csdn.net/ithomer/article/details/5784005 JS基础小案例】 https://blog.csdn.net/xlecho/article/details/79721606 JavaScript基础知识全总结】 https://blog.csdn.net/qq_39043923/article/details/89204263 为有机会进大厂，程序员必须掌握的核心算法有哪些？】 https://blog.csdn.net/m0_37907797/article/details/102661778 蓝桥杯知识点汇总：基础知识和常用算法】 https://blog.csdn.net/GD_ONE/article/details/104061907 Java笔试面试-算法常用面试题】 https://blog.csdn.net/huanglei305/article/details/103149074 五大常用算法总结】 https://blog.csdn.net/changyuanchn/article/details/51476281 c语言常用算法整理】 https://blog.csdn.net/mhhyoucom/article/details/87929783 (java)五大常用算法】 https://blog.csdn.net/qq_39147389/article/details/82252924 96道前端面试题+前端常用算法】 https://blog.csdn.net/QXXXD/article/details/113113311 10大经典排序算法动画解析-收藏】 https://blog.csdn.net/qq_35860138/article/details/84987429 五大常用算法：分治、动态规划、贪心、回溯和分支界定】 https://blog.csdn.net/yake827/article/details/52119469 Web基础 Web基础（三）Python Web】 https://blog.csdn.net/yingshukun/article/details/84072008 web 前端入坑第一篇：web前端到底是什么？有前途吗】 https://blog.csdn.net/xllily_11/article/details/52084476 Web基础-Uri跟Url的区别】 https://blog.csdn.net/simplebam/article/details/72644094 web基础知识梳理（思维导图）】 https://blog.csdn.net/u011435776/article/details/82055322 Go Web编程一: Go Web 基础】 https://blog.csdn.net/sanxiaxugang/article/details/69055457 1.web基础知识】 https://blog.csdn.net/weixin_41889503/article/details/80548141 一些被忽略的html小知识（持续更新）】 https://blog.csdn.net/qq_42698608/article/details/105918816 HTML+CSS 登录页面】 https://blog.csdn.net/sakenc/article/details/91465144 HTML入门学习笔记+案例】 https://blog.csdn.net/weixin_43331963/article/details/104428697 HTML4到HTML5的新增内容，你知道吗？】 https://blog.csdn.net/lzyws739307453/article/details/104116571 css鼠标点击的五种状态】 https://blog.csdn.net/leng0920/article/details/77413042 CSS 元素垂直居中的 6种方法】 https://blog.csdn.net/wolinxuebin/article/details/7615098 CSS控制文字，超出部分显示省略号】 https://blog.csdn.net/zhumengzj/article/details/80801556 CSS设置背景透明度】 https://blog.csdn.net/qq15577969/article/details/79898708 CSS各种对齐代码，左对齐、右对齐、中间对齐、底部对齐、两端对齐等，代码简单】 https://blog.csdn.net/ck3345143/article/details/61930731 纯 CSS 实现图片轮播】 https://blog.csdn.net/u011848617/article/details/80468463 最全CSS基础知识图片形式整理】 https://blog.csdn.net/weixin_43606158/article/details/95873063 css常用代码大全,html+css代码】 https://blog.csdn.net/xujiuba/article/details/78926554 css的两种盒模型】 https://blog.csdn.net/zwkkkk1/article/details/79678177 css设置div铺满全屏幕】 https://blog.csdn.net/update7/article/details/80616742 Javascript之BOM与DOM讲解】 https://blog.csdn.net/qq877507054/article/details/51395830 前端最全面试题】 https://blog.csdn.net/weixin_43606158/article/details/89811189 BOM与DOM解释与分析】 https://blog.csdn.net/qq_41908550/article/details/83060780 javascript的三个部分ECMAScript、DOM 和 BOM】 https://blog.csdn.net/weiyong1999/article/details/7916691 js中BOM和DOM之间的详解】 https://blog.csdn.net/tiny_wei/article/details/79829310 主机与DNS VMware安装Centos7超详细过程（图文） https://blog.csdn.net/babyxue/article/details/80970526 IP地址，子网掩码、默认网关，DNS服务器是什么意思? https://blog.csdn.net/bilter/article/details/6999511 Ping 命令详解 https://blog.csdn.net/hebbely/article/details/54965989 Windows设置本地DNS域名解析Hosts https://blog.csdn.net/sgs595595/article/details/78779870 利用dnscmd在DNS服务器上实现远程加载Dll https://blog.csdn.net/qq_41874930/article/details/109672428 IP地址，子网掩码、默认网关，DNS服务器之间的联系与区别 https://blog.csdn.net/hexf9632/article/details/93469788 Linux中搭建DNS服务器 https://blog.csdn.net/qq_36119192/article/details/82752515 终于有人把域名和DNS服务器给写明白了 https://blog.csdn.net/qq_17623363/article/details/106037921 C/C++实现DNS劫持 https://blog.csdn.net/qq_27180763/article/details/82556807 如何查看主机ip网关DNS https://blog.csdn.net/weixin_44359909/article/details/107173344 搭建Kubernetes集群踩坑日志之coreDNS 组件出现CrashLoopBackOff问题的解决 https://blog.csdn.net/u011663005/article/details/87937800 Linux kali内网渗透之DNS劫持+SET社会工程学进行内网钓鱼攻击 https://blog.csdn.net/Pythonicc/article/details/104984301 查看DNS主机名解析的主机IP并向DNS服务器进行DNS域名解析 https://blog.csdn.net/siyanyanyanyai/article/details/25790239 【TCP/IP】详解DNS具体作用过程 https://blog.csdn.net/l_ppp/article/details/109128967 Apache的配置，DNS解析，虚拟主机 https://blog.csdn.net/u012887301/article/details/52260217 vmware虚拟机三种网卡 https://blog.csdn.net/lyf_ldh/article/details/78695357 linux下DNS配置及域名解析服务 https://blog.csdn.net/chao199512/article/details/80436722 IP解析异常” DNS_PROBE_FINISHED_NXDOMAIN https://blog.csdn.net/qq_35603476/article/details/100977725 计算机网络基础知识点总结 https://blog.csdn.net/cdlwhm1217096231/article/details/90760282 VMware虚拟机下Centos7 桥接方式网络配置完整步骤 https://blog.csdn.net/u013626215/article/details/88645003 运维之道 | DNS 服务搭建及主从配置、配置宿主机DNS解析及验证httpd域名 https://blog.csdn.net/VillianTsang/article/details/104165591 8、解决Linux无法上网的各种问题 https://blog.csdn.net/u013181595/article/details/71845156 华为三层交换机自动获取地址指定dns https://blog.csdn.net/qq_42259469/article/details/104940889 网关与网段 IP地址，子网掩码、默认网关，DNS服务器是什么意思? https://blog.csdn.net/bilter/article/details/6999511 IP地址，子网掩码、默认网关，DNS服务器之间的联系与区别 https://blog.csdn.net/hexf9632/article/details/93469788 VLAN基础知识 https://blog.csdn.net/qq_38265137/article/details/80390759 网关和网段区别 https://blog.csdn.net/ARCH_Yang/article/details/82626717 VMware选择VMnet8模式连接外网的方法 https://blog.csdn.net/qq_45069279/article/details/105838205 192.168.和10.0.开头的IP、内网IP段、IP简介、分类——（IP观止） https://blog.csdn.net/superit401/article/details/78246298 IP地址、子网掩码、网段、网关的关系 https://blog.csdn.net/qq_41324483/article/details/100179816 计算机网络: IP地址，子网掩码，网段表示法，默认网关，DNS服务器详解 https://blog.csdn.net/weixin_40645305/article/details/80699307 指定网段走指定网卡网关方法 https://blog.csdn.net/qq_33611327/article/details/78271289 Vmware设置静态ip连网 （ 使用自定义Vmnet8 net ） https://blog.csdn.net/qq_45069279/article/details/104824954 计算机网络——不同网段下的主机通信 https://blog.csdn.net/qq2539879928/article/details/106867253 轻松为Windows配置多个网关 https://blog.csdn.net/qhdliqiang/article/details/585711 Linux无法ping通网关也无法ping通其他ip地址原因查找 https://blog.csdn.net/Mikeoperfect/article/details/80150206 模拟器：通过一台三层交换机及两台二层交换机和6台电脑划分3个VLAN，建立三个网关让电脑之间互通 https://blog.csdn.net/qq_37400312/article/details/64440410 linux两个网段默认网关_关于linux的默认网关 https://blog.csdn.net/weixin_28812943/article/details/112951809 linux 和 windows 如何跨网段使用网关 https://blog.csdn.net/hexf9632/article/details/112475677 网关和IP地址不在同一个网段下 https://blog.csdn.net/king523103/article/details/47727293 网段、子网掩码计算方法 https://blog.csdn.net/yzpbright/article/details/81384559 IP地址、子网掩码、网络号、主机号、网络地址、主机地址以及ip段/数字-如192.168.0.1/24是什么意思? https://blog.csdn.net/gatieme/article/details/50989257 网关和IP必须设置在同一个网段吗 https://blog.csdn.net/bytxl/article/details/41897287 关于路由器中设置IP与网关不在同一网段方法的问题 https://blog.csdn.net/thanklife/article/details/52523479 IP地址，子网掩码、默认网关，DNS的设置和工作原理（总结） https://blog.csdn.net/xiao__jia__jia/article/details/82767385 Docker如何修改默认网段 https://blog.csdn.net/smooth00/article/details/83023499 同网段和不同网段设备通信原理详解 https://blog.csdn.net/tao546377318/article/details/50313441 多个路由器设置静态路由 不同网段可以互相访问 https://blog.csdn.net/gengyiping18/article/details/53581534 数据编码 三种常用的数字数据编码方式 https://blog.csdn.net/qq_34902437/article/details/89515451 一篇文章彻底弄懂Base64编码原理 https://blog.csdn.net/wo541075754/article/details/81734770 3种常见的数字数据编码方式 https://blog.csdn.net/qq_34902437/article/details/88545465 Redis数据编码方式详解 https://blog.csdn.net/snakorse/article/details/78154402 关于http接口开发中json格式数据编码问题处理 https://blog.csdn.net/5iasp/article/details/10933077 关于python中pymysql数据编码问题 https://blog.csdn.net/csdnwws/article/details/51954825 [Python模块学习]使用base64模块进行二进制数据编码 https://blog.csdn.net/jy692405180/article/details/73272066 栅格数据的编码方法 https://blog.csdn.net/weixin_42078760/article/details/103791936 【数据结构】哈夫曼树及哈夫曼编码 https://blog.csdn.net/qq_28602957/article/details/71036402 UTF-8与GBK互转，为什么会乱码？ https://blog.csdn.net/u010234516/article/details/52853214 处理分类数据 非数值型编码 https://blog.csdn.net/luguanyou/article/details/80599666 图像数据base64编码 https://blog.csdn.net/u013002364/article/details/53179132 数据预处理：非数值型特征如何进行编码 https://blog.csdn.net/huoxingdeshidai6/article/details/90299854 如何查看网页的编码格式 https://blog.csdn.net/DCFANS/article/details/90199487 几种常见的编码格式 https://blog.csdn.net/maikelsong/article/details/81098456 python数据处理:对类别Category进行编码(转化为数值) https://blog.csdn.net/selous/article/details/72457476 编码基础知识 https://blog.csdn.net/qq_44932672/article/details/105779742 网站开发进阶(三十六)String.getBytes()方法中的中文编码问题 https://blog.csdn.net/sunhuaqiang1/article/details/51647382 js实现基于Base64的编码及解码 https://blog.csdn.net/weixin_42420703/article/details/81384901 两种转换mysql数据编码的方法-latin1转utf8 https://blog.csdn.net/guoguo1980/article/details/2070701 python中的编码方式 https://blog.csdn.net/xiaoyink/article/details/80850448 js 中编码和解码的三种方法 https://blog.csdn.net/yiyelanxin/article/details/82895131 计算机中编码方式—ASCII,ISO-8859-1以及UTF-8和UTF-16编码 https://blog.csdn.net/lili13897741554/article/details/82053351 数字信号的编码方式 https://blog.csdn.net/nameofcsdn/article/details/80630828 MYSQL设置数据库编码 https://blog.csdn.net/ypp91zr/article/details/89216979 进制转换 我们为什么要学习进制 https://blog.csdn.net/strom2418/article/details/79221996 进制之间的转换（二进制、八进制、十进制、十六进制） https://blog.csdn.net/mez_Blog/article/details/91354750 计算机基础进制转换（二进制、八进制、十进制、十六进制） https://blog.csdn.net/yuanxiang01/article/details/82503568 进制转换：二进制、八进制、十六进制、十进制之间的转换 https://blog.csdn.net/liubing8609/article/details/82695059 各种进制转换（二，八，十，十六进制间转换）详解附代码 https://blog.csdn.net/qq_41785863/article/details/84101711 C语言算法之将十进制数转换成二进制数 https://blog.csdn.net/weixin_41676881/article/details/80745177 JAVA 进制转换的几个方法 https://blog.csdn.net/m0_37961948/article/details/80438113 C++中的各种进制转换函数汇总 https://blog.csdn.net/vir_lee/article/details/80645066 C语言实现任意进制数之间的转换 https://blog.csdn.net/qq_36454961/article/details/79174645 c/c++进制转换方法汇总（含全部代码） https://blog.csdn.net/lady_killer9/article/details/87904318 2进制 , 8进制 , 10进制 , 16进制 , 介绍 及 相互转换 及 快速转换的方法 https://blog.csdn.net/diyu122222/article/details/80692904 二进制、八进制、十进制、十六进制关系及转换 https://blog.csdn.net/ruidianbaihuo/article/details/87797979 Python进制转换详细介绍 https://blog.csdn.net/weixin_43353539/article/details/89444838 C语言实现进制转换 https://blog.csdn.net/qq_42820622/article/details/82024324 进制转换C语言实现（十进制转换为任意进制） https://blog.csdn.net/baidu_41774120/article/details/85140853 C语言实现进制转换(详) https://blog.csdn.net/qq_41877184/article/details/88753144 c语言中16进制转换为十进制 https://blog.csdn.net/zhangjianjun521/article/details/79081435 Java:十六进制转换成十进制 https://blog.csdn.net/zl1zl2zl3/article/details/83615431 小数的进制转换方法 https://blog.csdn.net/u013349653/article/details/51367453 进制转换方法总结 https://blog.csdn.net/final__static/article/details/89405945 C语言算法之将十进制数转换成二进制数 https://blog.csdn.net/weixin_41676881/article/details/80745177 2进制 , 8进制 , 10进制 , 16进制 , 介绍 及 相互转换 及 快速转换的方法 https://blog.csdn.net/diyu122222/article/details/80692904 进制转换C语言实现（十进制转换为任意进制） https://blog.csdn.net/baidu_41774120/article/details/85140853 数据结构练习——栈（进制转换） https://blog.csdn.net/qq_41420747/article/details/81809063 十进制转换成八进制（C++） https://blog.csdn.net/liuzich/article/details/96602088","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"技术学习/算法","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"冒泡排序解析","slug":"技术学习/算法/Untitled 1","date":"2021-07-26T03:23:17.265Z","updated":"2021-08-10T15:49:17.847Z","comments":true,"path":"post/2235748871.html","link":"","permalink":"https://dd-code.site/post/2235748871.html","excerpt":"","text":"大知识点 小知识点 题目 链接 机器学习 概述总结 机器学习的基本概念和相关术语 https://blog.csdn.net/qq_43328040/article/details/106823245 机器学习系列（一）——机器学习简介 https://blog.csdn.net/hohaizx/article/details/80584307 机器学习是什么 https://blog.csdn.net/dk1543100966/article/details/80826771 这可能是最简单易懂的机器学习入门（小白必读） https://blog.csdn.net/qq_28168421/article/details/81351321 机器学习和深度学习路线 https://blog.csdn.net/baidu_33256174/article/details/101225734 深度学习入门笔记（一）：机器学习基础 https://blog.csdn.net/qq_43328040/article/details/107094840 《机器学习实战》学习笔记（一）：机器学习基础 https://blog.csdn.net/TeFuirnever/article/details/99734084 可解释的机器学习 https://blog.csdn.net/qq_42793029/article/details/94459036 机器学习知识体系 https://blog.csdn.net/XiaoYi_Eric/article/details/79679689 浅谈对于机器学习的理解 https://blog.csdn.net/T_I_A_N_/article/details/85914097 机器学习理论知识概述 https://blog.csdn.net/u014593570/article/details/77988681 机器学习路径规划 https://blog.csdn.net/Jade_Moon/article/details/78083967 机器学习（概述一）——定义 https://blog.csdn.net/zhanglianhai555/article/details/90607554 浅谈对统计机器学习的认识 https://blog.csdn.net/slx_share/article/details/79960635 辨析|深度学习与机器学习的基本区别 https://blog.csdn.net/qq_44621510/article/details/90097528 机器学习与隐私保护 https://blog.csdn.net/qiu1440528444/article/details/97375153 机器学习入门到进阶学习路线 https://blog.csdn.net/u010164625/article/details/79765798 《机器学习》总结与心得 https://blog.csdn.net/qq_17073497/article/details/81390086 [机器学习篇]机器学习知识总结篇 https://blog.csdn.net/BaiHuaXiu123/article/details/60884803 机器学习100+问 https://blog.csdn.net/sinat_22510827/article/details/110790020 机器学习未来十年：你需要把握的趋势和热点 https://blog.csdn.net/weixin_42137700/article/details/83614617 什么是机器学习 https://blog.csdn.net/weixin_42555080/article/details/91391390 机器学习方法分类总结 https://blog.csdn.net/m0_37167788/article/details/82836728 这可能是最简单易懂的机器学习入门（小白必读） https://blog.csdn.net/qq_28168421/article/details/81351321 我是如何入门机器学习的呢 https://blog.csdn.net/weixin_42137700/article/details/81869285 常用的三种机器学习预测方法 https://blog.csdn.net/qq_43337115/article/details/107309087 机器学习发展历史回顾 https://blog.csdn.net/SIGAI_CSDN/article/details/82428499 实例题目 机器学习案例——鸢尾花数据集分析 https://blog.csdn.net/heuguangxu/article/details/80426437 机器学习实例 https://blog.csdn.net/bigsec/article/details/79268545 机器学习及项目实战 https://blog.csdn.net/weixin_44888486/article/details/107047653 机器学习：入门实例 https://blog.csdn.net/xiaxianba/article/details/93849347 Python &amp; 机器学习之项目实践 https://blog.csdn.net/qq_40027052/article/details/78912963 机器学习高频面试题(41道) https://blog.csdn.net/wuxiaosi808/article/details/107084723 机器学习试题 https://blog.csdn.net/xwd18280820053/article/details/74306825 算法技能 机器学习、深度学习所需掌握的数学知识全都在这里了！ https://blog.csdn.net/xo3ylAF9kGs/article/details/108764752 机器学习&amp;图像分割——模型评价总结(含完整代码) https://blog.csdn.net/zichen_ziqi/article/details/80408465 机器学习常见算法 https://blog.csdn.net/weixin_39012047/article/details/81915204 机器学习原理详解 https://blog.csdn.net/fuhanghang/article/details/85218281 机器学习算法 综述（入门） https://blog.csdn.net/qq_41204464/article/details/92431679 机器学习文献综述 https://blog.csdn.net/a1742326479/article/details/81048473 机器学习1-机器学习中建模过程 https://blog.csdn.net/wangzi11111111/article/details/80504873 机器学习（基本图像分类） https://blog.csdn.net/qq_37598011/article/details/102853636 机器学习算法集锦 https://blog.csdn.net/xiangzhihong8/article/details/56049422 机器学习算法简要 https://blog.csdn.net/u013510838/article/details/84291176 机器学习的13种算法和4种学习方法，推荐给大家 https://blog.csdn.net/duozhishidai/article/details/82764044 机器学习-线性回归总结 https://blog.csdn.net/fengxinlinux/article/details/86556584 机器学习之特征提取 https://blog.csdn.net/Madazy/article/details/84036334 python机器学习手写算法系列——线性回归 https://blog.csdn.net/juwikuang/article/details/78420337 数学与机器学习的联系 https://blog.csdn.net/tonglin12138/article/details/103188969 项目经理 入门 高级项目经理和项目经理的区别 https://blog.csdn.net/u012757419/article/details/92812015 项目经理为什么一直遭人烦 https://blog.csdn.net/weixin_42400743/article/details/113932432 从程序员到项目经理（一）：为什么要当项目经理 https://blog.csdn.net/wt461290528/article/details/80683331 项目经理的苦，与谁说？ https://blog.csdn.net/devopscsdn/article/details/73825958 一个合格的项目经理都需要做哪些事情？ https://blog.csdn.net/shaoyezhangliwei/article/details/81709030 项目经理的权力来源 https://blog.csdn.net/weixin_42450461/article/details/84574746 项目经理的任命权 https://blog.csdn.net/weixin_42450461/article/details/86618658 一个合格的项目经理都需要做哪些事情？ https://blog.csdn.net/shaoyezhangliwei/article/details/81709030 项目经理价值的最终体现 https://blog.csdn.net/weixin_42450461/article/details/84996834 软件项目经理进阶 https://blog.csdn.net/wyqwilliam/article/details/90722120 项目整体流程及项目经理工作职责 https://blog.csdn.net/qq_23867645/article/details/87004247 我学习从事项目经理第一个课 https://blog.csdn.net/Ruan_Number3/article/details/81215876 软件公司项目经理岗位职责 https://blog.csdn.net/hong2511/article/details/81410222 项目经理职责理解 https://blog.csdn.net/weixin_42749765/article/details/82589991 产品经理和项目经理的职责分工 https://blog.csdn.net/bodierchen/article/details/99687442 给项目经理的五个建议 https://blog.csdn.net/lp1052843207/article/details/102582160 项目经理学习笔记 https://blog.csdn.net/ltaihyy/article/details/71170396 互联网项目经理的职业规划 https://blog.csdn.net/weixin_40402934/article/details/80983537 项目经理修炼之道：新项目经理如何成功转型 https://blog.csdn.net/weoln/article/details/78153237 不懂技术能做项目经理吗？ https://blog.csdn.net/weixin_42450461/article/details/88675910 项目经理书籍清单 https://blog.csdn.net/xiaoxiaoNB/article/details/79643180 真正理解项目经理 https://blog.csdn.net/w13240362354/article/details/51854281 IT项目经理如何学习 https://blog.csdn.net/zhongguomao/article/details/51957139 技能素质 项目经理之项目经理需要用哪些工具？ https://blog.csdn.net/taomanman/article/details/50779045 做软件项目经理需要具备的品质和素质 https://blog.csdn.net/Mikebj/article/details/53635700 资深项目经理推荐的五款项目管理工具 https://blog.csdn.net/weixin_44769148/article/details/100763724 优秀信息系统项目经理应该具备的技能和素质 https://blog.csdn.net/u011543541/article/details/52211006 项目经理需要具备的技能 https://blog.csdn.net/seagal890/article/details/83507745 新手项目经理如何进行项目管理？ https://blog.csdn.net/mist99/article/details/105393718 优秀项目经理的五大核心能力 https://blog.csdn.net/weixin_44769250/article/details/102837064 项目经理责任制核心要点之一：明确项目经理的责权利 https://blog.csdn.net/weixin_42400743/article/details/104249451 项目经理如何汇报工作 https://blog.csdn.net/changjiang366/article/details/83055036 项目经理需要的基本技能 https://blog.csdn.net/YCM1101743158/article/details/83549604 项目经理如何做好风险管理 https://blog.csdn.net/S_king_/article/details/80853998 一个优秀的项目经理应该具备的七个特点 https://blog.csdn.net/sea168/article/details/82974519 项目经理必备的项目管理十大技能 https://blog.csdn.net/weixin_42400743/article/details/86310279 IT项目经理必备生存指南 https://blog.csdn.net/S_king_/article/details/78087505 软件项目经理岗位职责、职业要求、必备技能、素质要求描述 https://blog.csdn.net/datamining2005/article/details/76172434 总结面试 项目经理面试的一些经验分享 https://blog.csdn.net/weixin_43664270/article/details/91372611 项目经理面试的一些问题讨论 https://blog.csdn.net/lp1052843207/article/details/89562226 项目经理面试宝典 https://blog.csdn.net/qq_39628933/article/details/90896835 做项目经理的自我总结(一) https://blog.csdn.net/wang_yuewen/article/details/58622729 项目经理面试题 https://blog.csdn.net/yanxilou/article/details/84867081 IT项目经理面试题 https://blog.csdn.net/tianzongnihao/article/details/81411403 项目管理5阶段｜一位高级项目经理的4年项目经验分享 https://blog.csdn.net/u012757419/article/details/92813823 华为项目经理面试经验分享——拿到offer https://blog.csdn.net/HuaCode/article/details/89761877 项目经理笔试题 https://blog.csdn.net/weixin_38234890/article/details/79919376 项目经理面试题 https://blog.csdn.net/fishmai/article/details/52224437 2018京东项目经理实习生面试经验 https://blog.csdn.net/SharonChuang/article/details/79965033 it项目经理面试题 https://blog.csdn.net/andymu077/article/details/52357095 产品经理 入门 产品经理入门：一、产品、产品经理 https://blog.csdn.net/nothair/article/details/114437231 认识产品经理 https://blog.csdn.net/forwardto9/article/details/52805022 产品经理 https://blog.csdn.net/xxm0720/article/details/107967256 浅谈产品经理 https://blog.csdn.net/ling615/article/details/90485550 转行产品经理，必看的避坑指南！ https://blog.csdn.net/weixin_40057354/article/details/89706606 万字长文|如何定义“失败的产品经理” https://blog.csdn.net/MUSHEN15936/article/details/106307391 软件产品经理需要技术吗？ https://blog.csdn.net/vx_hxy1010/article/details/79424607 产品经理职责 https://blog.csdn.net/weixin_40057354/article/details/89670534 产品经理的职业规划及绩效评估 https://blog.csdn.net/huanglei305/article/details/103128942 [产品经理]产品管理职位的级别 https://blog.csdn.net/Kandy_Ye/article/details/53581171 快速转行做产品经理 https://blog.csdn.net/Fessible_Max/article/details/101222557 互联网产品经理的工作职责 https://blog.csdn.net/m0_37591905/article/details/89914764 产品经理的七个阶段 https://blog.csdn.net/linapursue/article/details/78840966 产品经理的工作及职责 https://blog.csdn.net/huanglei305/article/details/103128228 项目经理和产品经理之区别 https://blog.csdn.net/sankever/article/details/95040846 （售前）销售经理和产品经理的区别以及未来发展 https://blog.csdn.net/leefangsong/article/details/106179195 产品经理你有自己的方法论吗 https://blog.csdn.net/weixin_40057354/article/details/89706195 产品经理的岗位职责 https://blog.csdn.net/qq_33361432/article/details/88078371 为什么产品经理总被吐槽是”水货 https://blog.csdn.net/buptgshengod/article/details/86693794 产品经理的职业生涯规划 https://blog.csdn.net/qq_30006749/article/details/88663044 从程序员到产品经理 https://blog.csdn.net/bit_kaki/article/details/81033327 产品经理是做什么的？ https://blog.csdn.net/weixin_40057354/article/details/90575567 产品经理 &amp; 项目管理 https://blog.csdn.net/maryzbf/article/details/49948671 《人人都是产品经理》之我也是产品经理 https://blog.csdn.net/weixin_40575956/article/details/82748326 转型产品经理必看 | 我是如何从程序员一步一步走向产品经理 https://blog.csdn.net/xuhui_louning/article/details/77412331 技能 产品经理做APP从头到尾的所有工作流程详解！ https://blog.csdn.net/eickandy/article/details/80294224 产品经理常见问题 https://blog.csdn.net/zcl050505/article/details/114433857 产品经理如何写PRD文档［最全］ https://blog.csdn.net/weixin_40057354/article/details/89667987 产品经理手册 https://blog.csdn.net/liwei16611/article/details/82630078 产品经理必须要掌握的数据分析能力 https://blog.csdn.net/xm10282010/article/details/107604568 产品经理技术篇 https://blog.csdn.net/weixin_40057354/article/details/90575599 产品经理必须懂名词 https://blog.csdn.net/weixin_40057354/article/details/89668071 产品经理常见沟通问题 https://blog.csdn.net/weixin_40057354/article/details/89705334 产品经理应掌握软件技能 https://blog.csdn.net/weixin_42078760/article/details/80809489 产品经理常用术语 https://blog.csdn.net/qq_15719037/article/details/79944131 产品经理谈拉新 https://blog.csdn.net/Julialove102123/article/details/88205672 产品经理的高阶能力：架构图的设计与画法 https://blog.csdn.net/weixin_42137700/article/details/85273996 产品经理的两个基本思维模型 https://blog.csdn.net/weixin_40057354/article/details/89705275 产品经理的两个基本思维模型 https://blog.csdn.net/weixin_40057354/article/details/89705275 产品经理数据分析入门 https://blog.csdn.net/u014555121/article/details/78580857 AI产品经理入门手册（上） https://blog.csdn.net/weixin_42137700/article/details/106980142 总结面试 产品经理面试技巧 https://blog.csdn.net/weixin_40057354/article/details/90575651 广联达产品经理笔试题目 https://blog.csdn.net/tfight/article/details/102468417 产品经理面试题汇总（1） https://blog.csdn.net/weixin_40838078/article/details/100888597 产品经理面试技巧，别说你不会 https://blog.csdn.net/lau317/article/details/81610857 产品经理面试题 https://blog.csdn.net/lau317/article/details/81604923 秋招尾声，二本的我终获产品经理offer，感触良多！ https://blog.csdn.net/weixin_46218781/article/details/113098183 产品经理笔试面试准备 https://blog.csdn.net/Julialove102123/article/details/82704358 我做产品经理这半年来的经验总结（一） https://blog.csdn.net/qq_42281648/article/details/91451462 产品经理的总结（一） https://blog.csdn.net/yx1166/article/details/61427538 网络安全 基础 小白怎么入门网络安全？看这篇就够啦！ https://blog.csdn.net/xuanyuan_fsx/article/details/108403062 [网络安全自学篇] 一.入门笔记之看雪Web安全学习及异或解密示例 https://blog.csdn.net/Eastmount/article/details/97784774 网络安全学习路线 https://blog.csdn.net/LTtiandd/article/details/106083703 网络安全基础知识 https://blog.csdn.net/qq_38388195/article/details/114369957 网络安全基础学习路线图 https://blog.csdn.net/weixin_42608762/article/details/100850895 网络安全学习指南 https://blog.csdn.net/qq_36402161/article/details/84035618 如何去学习网络安全 https://blog.csdn.net/lhd_paul/article/details/86354238 网络安全基础学习路线图 https://blog.csdn.net/weixin_42608762/article/details/100850895 什么是网络安全，为何要注重网络安全？ https://blog.csdn.net/slc685375/article/details/101367060 网络安全简介 https://blog.csdn.net/du_xtkp/article/details/60347857 小白怎么入门网络安全？看这篇就够啦！ https://blog.csdn.net/xuanyuan_fsx/article/details/108403062 网络安全基础要点知识介绍 https://blog.csdn.net/wangjiang_qianmo/article/details/87904270 网络安全系列第一讲 计算机网络安全概述 https://blog.csdn.net/m0_47157676/article/details/109141551 网络安全 https://blog.csdn.net/qq_40794973/article/details/96648662 计算机网络安全重要性 https://blog.csdn.net/tomy2426214836/article/details/86762764 网络安全思维导图 https://blog.csdn.net/xudongze53596525/article/details/79959417 网络安全的基本内容 https://blog.csdn.net/chengoes/article/details/79375179 提高 网络安全常见练习靶场 https://blog.csdn.net/qq_21516633/article/details/104241406 网络安全中常见攻击方式（SQL注入、XSS攻击、CSRF攻击、网页木马、文件包含漏洞攻击、目录遍历攻击、CC攻击… https://blog.csdn.net/csdn10086110/article/details/101194590 网络安全&amp;DOS攻击✍ https://blog.csdn.net/csdn10086110/article/details/90633296 网络安全 (加密, 解密) https://blog.csdn.net/qq_38975553/article/details/112917063 计算机网络安全知识汇总 https://blog.csdn.net/stay_foolish12/article/details/93060918 常见的网络安全协议 https://blog.csdn.net/weixin_41924879/article/details/101384544 无线网络安全技术基础 https://blog.csdn.net/weixin_41924879/article/details/101369864 网络安全方向与要求 https://blog.csdn.net/weixin_41176153/article/details/89321900 网络安全知识（一） https://blog.csdn.net/cccccfive/article/details/83145487 网络安全重点总结 https://blog.csdn.net/gjggj/article/details/72904136 网络运维与网络安全 https://blog.csdn.net/qq_40262295/article/details/103190641 计算机网络安全技术学习总结 https://blog.csdn.net/weixin_49340699/article/details/109992533 一些常见网络安全术语解释 https://blog.csdn.net/JackComeOn/article/details/83048096 网络安全第三讲 身份认证与访问控制 https://blog.csdn.net/m0_47157676/article/details/109173578 信息安全与网络安全的区别 https://blog.csdn.net/LMD_BTBU/article/details/102578870 网络安全第四讲 防火墙工作原理及应用 https://blog.csdn.net/m0_47157676/article/details/109173619 网络安全测评 https://blog.csdn.net/wowotuo/article/details/82825437 网络安全解决方案 https://blog.csdn.net/qq_35257875/article/details/94585193 黑客网络安全扫描工具 https://blog.csdn.net/xiaoyuge16/article/details/81291874 [网络安全学习篇5]：DHCP部署与安全、DNS部署与安全（千峰网络安全视频笔记 5 day） https://blog.csdn.net/weixin_43252204/article/details/105338995 其他 网络安全面试题 https://blog.csdn.net/fzx_hsaj/article/details/87093432 2020年中国网络安全产业白皮书分析解读 https://blog.csdn.net/liumiaocn/article/details/109502555 几率大的网络安全面试题（含答案） https://blog.csdn.net/Butterfly_resting/article/details/89638424 网络安全管理规章制度 https://blog.csdn.net/qq_45491298/article/details/102633639 网络安全学习网络资源链接汇总 https://blog.csdn.net/wys578/article/details/80691693 网络安全攻防 社工篇 简单介绍 https://blog.csdn.net/qq_42767842/article/details/81661426 网络安全题库一 https://blog.csdn.net/qq_30007885/article/details/98943462 CTF网络安全大赛介绍 https://blog.csdn.net/zxl2016/article/details/96482763 网络安全知识竞赛选择题(161-200题) https://blog.csdn.net/weixin_42146366/article/details/89304477 网络安全相关咨询（值得收藏） https://blog.csdn.net/sty945/article/details/88535623 网络安全知识竞赛选择题(1-30题) https://blog.csdn.net/weixin_42146366/article/details/89303876 浅谈企业网络安全边界 https://blog.csdn.net/haoren_xhf/article/details/82767180 网络安全知识竞赛选择题(31-60题) https://blog.csdn.net/weixin_42146366/article/details/89304034 ansj_seg NLPchina/ansj_seg https://blog.csdn.net/qq_26562641/article/details/62041492 ansj_seg使用 https://blog.csdn.net/hua_jing/article/details/78566100 ansj-seg包 https://blog.csdn.net/weixin_39838413/article/details/79193351 ansj_seg 学习，自定义词典加载 https://blog.csdn.net/jayzym/article/details/77481400 ansj分词史上最详细教程 https://blog.csdn.net/bitcarmanlee/article/details/53607776 基于ansj_seg的分词实现 https://blog.csdn.net/weixin_34403693/article/details/93677964 solr安装ansj_seg分词 https://blog.csdn.net/makang110/article/details/76079797 ik分词和jieba分词哪个好_中文分词器如何选择 jieba ik-analyzer ansj_seg HanLP https://blog.csdn.net/weixin_39585691/article/details/111751027 ansj_Seg5.0.1版本与lucene的集成以及ansj_seg 5.0.1使用 https://blog.csdn.net/iteye_13023/article/details/82671231 NLPChina_ansj_seg JAVA 实现热词及分词统计 https://blog.csdn.net/qq_37857921/article/details/108940251 分词jar使用（ansj_seg，ikanalyzer，mmseg4j-analysis） https://blog.csdn.net/qq_42014192/article/details/85247373 ansj_seg中文分词实例 https://blog.csdn.net/qq_26562641/article/details/84756974 IKanalyzer、ansj_seg、jcseg三种中文分词器的实战较量 https://blog.csdn.net/lies_joker/article/details/43150021 ansj_seg源码分析之用户自定义词库 https://blog.csdn.net/iteye_663/article/details/82610930 ansj_seg-5.0.3 MyStatic部分源码阅读 https://blog.csdn.net/Bleachswh/article/details/53619432","categories":[{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"技术学习/算法","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://dd-code.site/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"01|变量和数据类型","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型/ch3-1","date":"2021-05-25T16:00:00.000Z","updated":"2021-08-10T16:00:46.372Z","comments":true,"path":"post/860253879.html","link":"","permalink":"https://dd-code.site/post/860253879.html","excerpt":"","text":"变量什么是变量？ 变量就是初中数学的代数的概念，例如一个简单的方程，x，y都是变量： y=x2+1 在Java中，变量分为两种：基本类型的变量和引用类型的变量。 基本类型的变量在Java中，变量必须先定义后使用，在定义变量的时候，可以给它一个初始值。例如： 1int x = 1; 上述语句定义了一个整型int类型的变量，名称为x，初始值为1。 不写初始值，就相当于给它指定了默认值。默认值总是0。\\ 变量赋值来看一个完整的定义变量，然后打印变量值的例子： 1234567891011121314package com.study.basics.liaoxuefeng;/** * @author liudandan */public class HelloWord &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello Word!&quot;); // 定义int类型变量x，并赋予初始值100 int x = 100; // 打印该变量的值 System.out.println(x); &#125;&#125; 变量的一个重要特点是可以重新赋值。例如，对变量x，先赋值100，再赋值200，观察两次打印的结果： 123456789101112131415161718package com.study.basics.liaoxuefeng;/** * @author liudandan */public class HelloWord &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello Word!&quot;); // 定义int类型变量x，并赋予初始值100 int x = 100; // 打印该变量的值 System.out.println(x); // 重新赋值为200 x = 200; // 打印该变量的值，观察是否为200 System.out.println(x); &#125;&#125; 注意到第一次定义变量x的时候，需要指定变量类型int，因此使用语句int x = 100;。而第二次重新赋值的时候，变量x已经存在了，不能再重复定义，因此不能指定变量类型int，必须使用语句x = 200;。 变量不但可以重新赋值，还可以赋值给其他变量。让我们来看一个例子： 123456789101112131415161718192021222324252627282930package com.study.basics.liaoxuefeng;/** * @author liudandan */public class Assignment &#123; public static void main(String[] args) &#123; // 定义变量n，同时赋值为100 int n = 100; // 打印n的值 System.out.println(&quot;n = &quot; + n); // 变量n赋值为200 n = 200; // 打印n的值 System.out.println(&quot;n = &quot; + n); // 变量x赋值为n（n的值为200，因此赋值后x的值也是200） int x = n; // 打印x的值 System.out.println(&quot;x = &quot; + x); // 变量x赋值为x+100（x的值为200，因此赋值后x的值是200+100=300） x = x + 100; // 打印x的值 System.out.println(&quot;x = &quot; + x); // 再次打印n的值，n应该是200还是300？ System.out.println(&quot;n = &quot; + n); &#125;&#125; 代码执行流程分析执行int n = 100;，该语句定义了变量n，同时赋值为100，因此，JVM在内存中为变量n分配一个“存储单元”，填入值100： 123456 n │ ▼┌───┬───┬───┬───┬───┬───┬───┐│ │100│ │ │ │ │ │└───┴───┴───┴───┴───┴───┴───┘ 执行n = 200;时，JVM把200写入变量n的存储单元，因此，原有的值被覆盖，现在n的值为200： 123456 n │ ▼┌───┬───┬───┬───┬───┬───┬───┐│ │200│ │ │ │ │ │└───┴───┴───┴───┴───┴───┴───┘ 执行int x = n;时，定义了一个新的变量x，同时对x赋值，因此，JVM需要新分配一个存储单元给变量x，并写入和变量n一样的值，结果是变量x的值也变为200： 123456 n x │ │ ▼ ▼┌───┬───┬───┬───┬───┬───┬───┐│ │200│ │ │200│ │ │└───┴───┴───┴───┴───┴───┴───┘ 执行x = x + 100;时，JVM首先计算等式右边的值x + 100，结果为300（因为此刻x的值为200），然后，将结果300写入x的存储单元，因此，变量x最终的值变为300： 123456 n x │ │ ▼ ▼┌───┬───┬───┬───┬───┬───┬───┐│ │200│ │ │300│ │ │└───┴───┴───┴───┴───┴───┴───┘ 可见，变量可以反复赋值。注意，等号=是赋值语句，不是数学意义上的相等，否则无法解释x = x + 100。 基本数据类型","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"02-基本数据类型","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/02-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[]},{"title":"02|基本数据类型的说明","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型/ch3-2","date":"2021-05-25T16:00:00.000Z","updated":"2021-08-10T16:00:46.372Z","comments":true,"path":"post/117828488.html","link":"","permalink":"https://dd-code.site/post/117828488.html","excerpt":"","text":"基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型： 整数类型：byte，short，int，long 浮点数类型：float，double 字符类型：char 布尔类型：boolean Java定义的这些基本数据类型有什么区别呢？要了解这些区别，我们就必须简单了解一下计算机内存的基本结构。 计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从0000000011111111，换算成十进制是0255，换算成十六进制是00~`ff`。 内存单元从0开始编号，称为内存地址。每个内存单元可以看作一间房间，内存地址就是门牌号。 1234 0 1 2 3 4 5 6 ...┌───┬───┬───┬───┬───┬───┬───┐│ │ │ │ │ │ │ │...└───┴───┴───┴───┴───┴───┴───┘ 一个字节是1byte，1024字节是1K，1024K是1M，1024M是1G，1024G是1T。一个拥有4T内存的计算机的字节数量就是： 123454T &#x3D; 4 x 1024G &#x3D; 4 x 1024 x 1024M &#x3D; 4 x 1024 x 1024 x 1024K &#x3D; 4 x 1024 x 1024 x 1024 x 1024 &#x3D; 4398046511104 不同的数据类型占用的字节数不一样。我们看一下Java基本数据类型占用的字节数： 123456789101112131415161718192021 ┌───┐ byte │ │ └───┘ ┌───┬───┐ short │ │ │ └───┴───┘ ┌───┬───┬───┬───┐ int │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐ long │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┬───┬───┐ float │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐double │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┐ char │ │ │ └───┴───┘ byte恰好就是一个字节，而long和double需要8个字节。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"02-基本数据类型","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/02-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[]},{"title":"04|浮点型","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型/ch3-4","date":"2021-05-25T16:00:00.000Z","updated":"2021-08-10T16:00:46.372Z","comments":true,"path":"post/3158030992.html","link":"","permalink":"https://dd-code.site/post/3158030992.html","excerpt":"","text":"浮点类型的数就是小数，因为小数用科学计数法表示的时候，小数点是可以“浮动”的，如1234.5可以表示成12.345x102，也可以表示成1.2345x103，所以称为浮点数。 下面是定义浮点数的例子： 12345678910111213141516171819package com.study.basics.liaoxuefeng;/** * 数据类型的定义 * * @author liudandan */public class DataType &#123; public static void main(String[] args) &#123; //TODO::浮点型的定义 float f1 = 3.14f; // 科学计数法表示的3.14x10^38 float f2 = 3.14e38f; double d = 1.79e308; double d2 = -1.79e308; // 科学计数法表示的4.9x10^-324 double d3 = 4.9e-324; &#125;&#125; 对于float类型，需要加上f后缀。 浮点数可表示的范围非常大，float类型可最大表示3.4x1038，而double类型可最大表示1.79x10308。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"02-基本数据类型","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/02-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[]},{"title":"06|字符类型","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型/ch3-6","date":"2021-05-25T16:00:00.000Z","updated":"2021-08-10T16:00:46.372Z","comments":true,"path":"post/3819373199.html","link":"","permalink":"https://dd-code.site/post/3819373199.html","excerpt":"","text":"字符类型char表示一个字符。Java的char类型除了可表示标准的ASCII外，还可以表示一个Unicode字符： 1234567891011121314package com.study.basics.liaoxuefeng;/** * 数据类型的定义 * * @author liudandan */public class DataType &#123; public static void main(String[] args) &#123; //TODO:: 字符型 char a = &#x27;A&#x27;; char zh = &#x27;中&#x27;; &#125;&#125; 注意char类型使用单引号&#39;，且仅有一个字符，要和双引号&quot;的字符串类型区分开。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"02-基本数据类型","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/02-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[]},{"title":"07|引用类型和常量","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型/ch3-7","date":"2021-05-25T16:00:00.000Z","updated":"2021-08-10T16:00:46.372Z","comments":true,"path":"post/2916864214.html","link":"","permalink":"https://dd-code.site/post/2916864214.html","excerpt":"","text":"引用类型除了上述基本类型的变量，剩下的都是引用类型。例如，引用类型最常用的就是String字符串： 1String s = &quot;hello&quot;; 引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置，后续我们介绍类的概念时会详细讨论。 常量定义变量的时候，如果加上final修饰符，这个变量就变成了常量： 1234final double PI = 3.14; // PI是一个常量double r = 5.0;double area = PI * r * r;PI = 300; // compile error! 常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。 常量的作用是用有意义的变量名来避免魔术数字（Magic number），例如，不要在代码中到处写3.14，而是定义一个常量。如果将来需要提高计算精度，我们只需要在常量的定义处修改，例如，改成3.1416，而不必在所有地方替换3.14。 根据习惯，常量名通常全部大写。 var关键字有些时候，类型的名字太长，写起来比较麻烦。例如： 1StringBuilder sb = new StringBuilder(); 这个时候，如果想省略变量类型，可以使用var关键字： 1var sb = new StringBuilder(); 编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder。对编译器来说，语句： 1var sb = new StringBuilder(); 实际上会自动变成： 1StringBuilder sb = new StringBuilder(); 因此，使用var定义变量，仅仅是少写了变量类型而已。 变量的作用范围在Java中，多行语句用{ }括起来。很多控制语句，例如条件判断和循环，都以{ }作为它们自身的范围，例如： 1234567891011if (...) &#123; // if开始 ... while (...) &#123; // while 开始 ... if (...) &#123; // if开始 ... &#125; // if结束 ... &#125; // while结束 ...&#125; // if结束 只要正确地嵌套这些{ }，编译器就能识别出语句块的开始和结束。而在语句块中定义的变量，它有一个作用域，就是从定义处开始，到语句块结束。超出了作用域引用这些变量，编译器会报错。举个例子： 123456789101112131415161718192021&#123; ... int i = 0; // 变量i从这里开始定义 ... &#123; ... int x = 1; // 变量x从这里开始定义 ... &#123; ... String s = &quot;hello&quot;; // 变量s从这里开始定义 ... &#125; // 变量s作用域到此结束 ... // 注意，这是一个新的变量s，它和上面的变量同名， // 但是因为作用域不同，它们是两个不同的变量: String s = &quot;hi&quot;; ... &#125; // 变量x和s作用域到此结束 ...&#125; // 变量i作用域到此结束 定义变量时，要遵循作用域最小化原则，尽量将变量定义在尽可能小的作用域，并且，不要重复使用变量名。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"02-基本数据类型","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/02-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[]},{"title":"05|布尔类型","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型/ch3-5","date":"2021-05-25T16:00:00.000Z","updated":"2021-08-10T16:00:46.372Z","comments":true,"path":"post/677245709.html","link":"","permalink":"https://dd-code.site/post/677245709.html","excerpt":"","text":"布尔类型boolean只有true和false两个值，布尔类型总是关系运算的计算结果： 12345678910111213141516171819package com.study.basics.liaoxuefeng;/** * 数据类型的定义 * * @author liudandan */public class DataType &#123; public static void main(String[] args) &#123; //TODO::布尔型的定义 boolean b1 = true; boolean b2 = false; // 计算结果为true boolean isGreater = 5 &gt; 3; int age = 12; // 计算结果为false boolean isAdult = age &gt;= 18; &#125;&#125; Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"02-基本数据类型","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/02-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[]},{"title":"03|整型","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型/ch3-3","date":"2021-05-25T16:00:00.000Z","updated":"2021-08-10T16:01:18.700Z","comments":true,"path":"post/3232286694.html","link":"","permalink":"https://dd-code.site/post/3232286694.html","excerpt":"","text":"对于整型类型，Java只定义了带符号的整型，因此，最高位的bit表示符号位（0表示正数，1表示负数）。各种整型能表示的最大范围如下： byte：-128 ~ 127 short: -32768 ~ 32767 int: -2147483648 ~ 2147483647 long: -9223372036854775808 ~ 9223372036854775807 我们来看定义整型的例子： 1234567891011121314151617181920212223package com.study.basics.liaoxuefeng;/** * 数据类型的定义 * * @author liudandan */public class DataType &#123; public static void main(String[] args) &#123; //TODO::整型的定义 int i = 2147483647; int i2 = -2147483648; // 加下划线更容易识别 int i3 = 2_000_000_000; // 十六进制表示的16711680 int i4 = 0xff0000; // 二进制表示的512 int i5 = 0b1000000000; // long型的结尾需要加L long l = 9000000000000000000L; //TODO::浮点型的定义 &#125;&#125;","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"02-基本数据类型","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/02-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[]},{"title":"01|Java简介","slug":"课程学习/廖雪峰的Java教程/01-Java基础/ch2-1","date":"2021-05-24T16:00:00.000Z","updated":"2021-08-10T15:59:48.294Z","comments":true,"path":"post/2622184687.html","link":"","permalink":"https://dd-code.site/post/2622184687.html","excerpt":"","text":"推荐的Java学习路线图如下： 首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用； 如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的； 如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发； 如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。 无论怎么选择，Java SE的核心技术是基础，这个教程的目的就是让你完全精通Java SE！ Java版本 时间 版本 1995 1.0 1998 1.2 2000 1.3 2002 1.4 2004 1.5 / 5.0 2005 1.6 / 6.0 2011 1.7 / 7.0 2014 1.8 / 8.0 2017/9 1.9 / 9.0 2018/3 10 2018/9 11 2019/3 12 2019/9 13 2020/3 14 2020/9 15 本教程使用的Java版本是最新版的Java 15。 名词解释 JDK：Java Development Kit JRE：Java Runtime Environment 简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。 二者关系如下： 1234567891011 ┌─ ┌──────────────────────────────────┐ │ │ Compiler, debugger, etc. │ │ └──────────────────────────────────┘JDK ┌─ ┌──────────────────────────────────┐ │ │ │ │ │ JRE │ JVM + Runtime Library │ │ │ │ │ └─ └─ └──────────────────────────────────┘ ┌───────┐┌───────┐┌───────┐┌───────┐ │Windows││ Linux ││ macOS ││others │ └───────┘└───────┘└───────┘└───────┘ 要学习Java开发，当然需要安装JDK了。 那JSR、JCP……又是啥？ JSR规范：Java Specification Request JCP组织：Java Community Process 为了保证Java语言的规范性，SUN公司搞了一个JSR规范，凡是想给Java平台加一个功能，比如说访问数据库的功能，大家要先创建一个JSR规范，定义好接口，这样，各个数据库厂商都按照规范写出Java驱动程序，开发者就不用担心自己写的数据库代码在MySQL上能跑，却不能跑在PostgreSQL上。 所以JSR是一系列的规范，从JVM的内存模型到Web程序接口，全部都标准化了。而负责审核JSR的组织就是JCP。 一个JSR规范发布时，为了让大家有个参考，还要同时发布一个“参考实现”，以及一个“兼容性测试套件”： RI：Reference Implementation TCK：Technology Compatibility Kit 比如有人提议要搞一个基于Java开发的消息服务器，这个提议很好啊，但是光有提议还不行，得贴出真正能跑的代码，这就是RI。如果有其他人也想开发这样一个消息服务器，如何保证这些消息服务器对开发者来说接口、功能都是相同的？所以还得提供TCK。 通常来说，RI只是一个“能跑”的正确的代码，它不追求速度，所以，如果真正要选择一个Java的消息服务器，一般是没人用RI的，大家都会选择一个有竞争力的商用或开源产品。 参考：Java消息服务JMS的JSR：https://jcp.org/en/jsr/detail?id=914","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"01-Java基础","slug":"课程学习/廖雪峰的Java教程/01-Java基础","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/01-Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"02|第一个Java程序","slug":"课程学习/廖雪峰的Java教程/01-Java基础/ch2-2","date":"2021-05-24T16:00:00.000Z","updated":"2021-08-10T15:59:51.282Z","comments":true,"path":"post/3342559509.html","link":"","permalink":"https://dd-code.site/post/3342559509.html","excerpt":"","text":"Hello Word12345678910package com.study.basics.liaoxuefeng;/** * @author liudandan */public class HelloWord &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello Word!&quot;); &#125;&#125; Java规定，某个类定义的 public static void main(String[] args) 是Java程序的固定入口方法，因此，Java程序总是从main方法开始执行。 如何运行Java程序Java源码本质上是一个文本文件，我们需要先用javac把Hello.java编译成字节码文件Hello.class，然后，用java命令执行这个字节码文件： 12345678910111213┌──────────────────┐│ Hello.java │&lt;─── source code└──────────────────┘ │ compile ▼┌──────────────────┐│ Hello.class │&lt;─── byte code└──────────────────┘ │ execute ▼┌──────────────────┐│ Run on JVM │└──────────────────┘ 因此，可执行文件javac是编译器，而可执行文件java就是虚拟机。 第一步，在保存Hello.java的目录下执行命令javac Hello.java： 1$ javac Hello.java 如果源代码无误，上述命令不会有任何输出，而当前目录下会产生一个Hello.class文件： 12$ lsHello.class Hello.java 第二步，执行Hello.class，使用命令java Hello： 12$ java HelloHello, world! 注意：给虚拟机传递的参数Hello是我们定义的类名，虚拟机自动查找对应的class文件并执行。 有一些童鞋可能知道，直接运行java Hello.java也是可以的： 12$ java Hello.java Hello, world! 这是Java 11新增的一个功能，它可以直接运行一个单文件源码！ 需要注意的是，在实际项目中，单个不依赖第三方库的Java源码是非常罕见的，所以，绝大多数情况下，我们无法直接运行一个Java源码文件，原因是它需要依赖其他的库。 小结一个Java源码只能定义一个public类型的class，并且class名称和文件名要完全一致； 使用javac可以将.java源码编译成.class字节码； 使用java可以运行一个已编译的Java程序，参数是类名。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"01-Java基础","slug":"课程学习/廖雪峰的Java教程/01-Java基础","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/01-Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"03|Java程序基本结构","slug":"课程学习/廖雪峰的Java教程/01-Java基础/ch2-3","date":"2021-05-24T16:00:00.000Z","updated":"2021-08-10T15:59:54.989Z","comments":true,"path":"post/3119976000.html","link":"","permalink":"https://dd-code.site/post/3119976000.html","excerpt":"","text":"完整的Java程序的基本结构123456789101112/** * 可以用来自动创建文档的注释 */public class Hello &#123; public static void main(String[] args) &#123; // 向屏幕输出文本: System.out.println(&quot;Hello, world!&quot;); /* 多行注释开始 注释内容 注释结束 */ &#125;&#125; // class定义结束 因为Java是面向对象的语言，一个程序的基本单位就是class，class是关键字，这里定义的class名字就是Hello： 123public class Hello &#123; // 类名是Hello // ...&#125; // class定义结束 类名（class）要求： 类名必须以英文字母开头，后接字母，数字和下划线的组合 习惯以大写字母开头 要注意遵守命名习惯，好的类命名： Hello NoteBook VRPlayer 不好的类命名： hello Good123 Note_Book _World 注意到public是访问修饰符，表示该class是公开的。 不写public，也能正确编译，但是这个类将无法从命令行执行。 方法（method）要求：在class内部，可以定义若干方法（method）： 12345public class Hello &#123; public static void main(String[] args) &#123; // 方法名是main // 方法代码... &#125; // 方法定义结束&#125; 方法定义了一组执行语句，方法内部的代码将会被依次顺序执行。 这里的方法名是main，返回值是void，表示没有任何返回值。 我们注意到public除了可以修饰class外，也可以修饰方法。而关键字static是另一个修饰符，它表示静态方法，后面我们会讲解方法的类型，目前，我们只需要知道，Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。 方法名也有命名规则，命名和class一样，但是首字母小写： 好的方法命名： main goodMorning playVR 不好的方法命名： Main good123 good_morning _playVR 在方法内部，语句才是真正的执行代码。Java的每一行语句必须以分号结束： 12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello, world!&quot;); // 语句 &#125;&#125; 在Java程序中，注释是一种给人阅读的文本，不是程序的一部分，所以编译器会自动忽略注释。 Java有3种注释，第一种是单行注释，以双斜线开头，直到这一行的结尾结束： 1// 这是注释... 而多行注释以/*星号开头，以*/结束，可以有多行： 12345/*这是注释blablabla...这也是注释*/ 还有一种特殊的多行注释，以/**开头，以*/结束，如果有多行，每行通常以星号开头： 12345678910/** * 可以用来自动创建文档的注释 * * @auther liaoxuefeng */public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello, world!&quot;); &#125;&#125; 这种特殊的多行注释需要写在类和方法的定义处，可以用于自动创建文档。 Java程序对格式没有明确的要求，多几个空格或者回车不影响程序的正确性，但是我们要养成良好的编程习惯，注意遵守Java社区约定的编码格式。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"01-Java基础","slug":"课程学习/廖雪峰的Java教程/01-Java基础","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/01-Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"开篇词","slug":"课程学习/廖雪峰的Java教程/00-开篇词/ch1-0","date":"2021-05-23T16:00:00.000Z","updated":"2021-08-10T16:00:03.366Z","comments":true,"path":"post/188254797.html","link":"","permalink":"https://dd-code.site/post/188254797.html","excerpt":"","text":"这是专门针对小白的零基础Java教程 官方在线地址：https://www.liaoxuefeng.com/wiki/1252599548343744 为什么要学Java？因为Java是全球排名第一的编程语言，Java工程师也是市场需求最大的软件工程师，选择Java，就是选择了高薪。 为什么Java应用最广泛？从互联网到企业平台，Java是应用最广泛的编程语言，原因在于： Java是基于JVM虚拟机的跨平台语言，一次编写，到处运行； Java程序易于编写，而且有内置垃圾收集，不必考虑内存管理； Java虚拟机拥有工业级的稳定性和高度优化的性能，且经过了长时期的考验； Java拥有最广泛的开源社区支持，各种高质量组件随时可用。 Java语言常年霸占着三大市场： 互联网和企业应用，这是Java EE的长期优势和市场地位； 大数据平台，主要有Hadoop、Spark、Flink等，他们都是Java或Scala（一种运行于JVM的编程语言）开发的； Android移动平台。 这意味着Java拥有最广泛的就业市场。 教程特色虽然是零基础Java教程，但是覆盖了从基础到高级的Java核心编程，从小白成长到架构师，实现硬实力高薪就业！ 还可以边学边练，而且可以在线练习！ 并且，时刻更新至最新版Java！目前教程版本是：Java 15 关于作者廖雪峰，十年软件开发经验，业余产品经理，精通Java/Python/Ruby/Scheme/Objective C等，对开源框架有深入研究，著有《Spring 2.0核心技术与最佳实践》一书，多个业余开源项目托管在GitHub。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"00-开篇词","slug":"课程学习/廖雪峰的Java教程/00-开篇词","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/00-%E5%BC%80%E7%AF%87%E8%AF%8D/"}],"tags":[]},{"title":"08 | 集合类型：Array（数组）","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门/ch1-4-1","date":"2021-05-19T16:00:00.000Z","updated":"2021-08-10T16:03:25.682Z","comments":true,"path":"post/1956865009.html","link":"","permalink":"https://dd-code.site/post/1956865009.html","excerpt":"","text":"Array（数组）数组存放的是固定长度、相同类型的数据，而且这些存放的元素是连续的。所存放的数据类型没有限制，可以是整型、字符串甚至自定义。 数组声明1array:=[5]string&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;&#125; 声明了一个字符串数组，长度是5，所以其类型为 [5]string ，其中大括号中的元素用于初始化数组。在类型前边加 [] 中括号，并设置好长度，就可以通过它来推测数组的类型。 注意：[5]string 和 [4]string 不是一种类型，因为长度也是数组的一部分。 数组在内存中是连续存放的，如图： 因为每个数组都是连续存放的，所以每个元素都有一个下标。下标从 0 开始，第一个下标为 0 ，第二个为 0+1，第三个","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"22讲通关Go语言","slug":"课程学习/22讲通关Go语言","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/"},{"name":"01-Go语言快速入门","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/01-Go%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[]},{"title":"如何快速对应用系统做一个360度的画像诊断","slug":"每日一课/如何快速对应用系统做一个360度的画像诊断","date":"2021-05-18T16:00:00.000Z","updated":"2021-07-26T03:23:17.292Z","comments":true,"path":"post/495014278.html","link":"","permalink":"https://dd-code.site/post/495014278.html","excerpt":"","text":"","categories":[{"name":"每日一课","slug":"每日一课","permalink":"https://dd-code.site/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AF%BE/"}],"tags":[]},{"title":"豆瓣电影 Top250 榜单","slug":"分享收藏/豆瓣电影 Top250 榜单","date":"2021-05-18T16:00:00.000Z","updated":"2021-07-26T03:23:17.298Z","comments":true,"path":"post/1354050835.html","link":"","permalink":"https://dd-code.site/post/1354050835.html","excerpt":"","text":"以下信息来源于： https://github.com/Mayandev/where-is-douban250 这个仓库整理了腾讯视频、爱奇艺、优酷、哔哩哔哩等视频网站中，能够观看的「豆瓣电影 Top250 榜单」影片，点击 Badge 可跳转至相应的电影首页，👏 欢迎一同维护。 电影列表 排名 电影名称 推荐语 相关链接 1 肖申克的救赎 希望让人自由。 &nbsp;&nbsp;&nbsp;&nbsp; 2 霸王别姬 风华绝代。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 阿甘正传 一部美国近现代史。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 这个杀手不太冷 怪蜀黍和小萝莉不得不说的故事。 5 泰坦尼克号 失去的才是永恒的。 &nbsp;&nbsp; 6 美丽人生 最美的谎言。 &nbsp; 7 千与千寻 最好的宫崎骏，最好的久石让。 &nbsp; 8 辛德勒的名单 拯救一个人，就是拯救整个世界。 &nbsp;&nbsp;&nbsp;&nbsp; 9 盗梦空间 诺兰给了我们一场无法盗取的梦。 &nbsp;&nbsp;&nbsp;&nbsp; 10 忠犬八公的故事 永远都不能忘记你所爱的人。 &nbsp;&nbsp; 11 星际穿越 爱是一种力量，让我们超越时空感知它的存在。 &nbsp;&nbsp;&nbsp;&nbsp; 12 海上钢琴师 每个人都要走一条自己坚定了的路，就算是粉身碎骨。 &nbsp;&nbsp; 13 楚门的世界 如果再也不能见到你，祝你早安，午安，晚安。 &nbsp;&nbsp;&nbsp; 14 三傻大闹宝莱坞 英俊版憨豆，高情商版谢耳朵。 &nbsp;&nbsp;&nbsp; 15 机器人总动员 小瓦力，大人生。 &nbsp;&nbsp; 16 放牛班的春天 天籁一般的童声，是最接近上帝的存在。 &nbsp;&nbsp; 17 大话西游之大圣娶亲 一生所爱。 &nbsp;&nbsp; 18 疯狂动物城 迪士尼给我们营造的乌托邦就是这样，永远善良勇敢，永远出乎意料。 &nbsp;&nbsp;&nbsp; 19 无间道 香港电影史上永不过时的杰作。 &nbsp;&nbsp;&nbsp;&nbsp; 20 熔炉 我们一路奋战不是为了改变世界，而是为了不让世界改变我们。 21 教父 千万不要记恨你的对手，这样会让你失去理智。 &nbsp;&nbsp;&nbsp;&nbsp; 22 当幸福来敲门 平民励志片。 &nbsp;&nbsp; 23 龙猫 人人心中都有个龙猫，童年就永远不会消失。 24 怦然心动 真正的幸福是来自内心深处。 &nbsp;&nbsp;&nbsp; 25 控方证人 比利·怀德满分作品。 &nbsp; 26 触不可及 满满温情的高雅喜剧。 27 蝙蝠侠：黑暗骑士 无尽的黑暗。 &nbsp;&nbsp;&nbsp;&nbsp; 28 末代皇帝 “不要跟我比惨，我比你更惨”再适合这部电影不过了。 &nbsp;&nbsp;&nbsp;&nbsp; 29 活着 张艺谋最好的电影。 30 寻梦环游记 死亡不是真的逝去，遗忘才是永恒的消亡。 &nbsp;&nbsp;&nbsp;&nbsp; 31 何以为家 凝视卑弱生命，用电影改变命运。 &nbsp;&nbsp;&nbsp;&nbsp; 32 乱世佳人 Tomorrow is another day. &nbsp;&nbsp;&nbsp;&nbsp; 33 指环王3：王者无敌 史诗的终章。 &nbsp;&nbsp;&nbsp;&nbsp; 34 哈利·波特与魔法石 童话世界的开端。 &nbsp;&nbsp;&nbsp; 35 飞屋环游记 最后那些最无聊的事情，才是最值得怀念的。 &nbsp;&nbsp;&nbsp;&nbsp; 36 摔跤吧！爸爸 你不是在为你一个人战斗，你要让千千万万的女性看到女生并不是只能相夫教子。 &nbsp;&nbsp;&nbsp;&nbsp; 37 素媛 受过伤害的人总是笑得最开心，因为他们不愿意让身边的人承受一样的痛苦。 38 少年派的奇幻漂流 瑰丽壮观、无人能及的冒险之旅。 &nbsp;&nbsp;&nbsp; 39 十二怒汉 1957年的理想主义。 &nbsp;&nbsp;&nbsp;&nbsp; 40 哈尔的移动城堡 带着心爱的人在天空飞翔。 &nbsp; 41 鬼子来了 对敌人的仁慈，就是对自己残忍。 42 天空之城 对天空的追逐，永不停止。 43 大话西游之月光宝盒 旷古烁今。 &nbsp;&nbsp; 44 我不是药神 对我们国家而言，这样的电影多一部是一部。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 45 闻香识女人 史上最美的探戈。 &nbsp;&nbsp;&nbsp; 46 罗马假日 爱情哪怕只有一天。 &nbsp;&nbsp;&nbsp;&nbsp; 47 天堂电影院 那些吻戏，那些青春，都在影院的黑暗里被泪水冲刷得无比清晰。 48 辩护人 电影的现实意义大过电影本身。 49 猫鼠游戏 骗子大师和执著警探的你追我跑故事。 &nbsp;&nbsp;&nbsp; 50 大闹天宫 经典之作，历久弥新。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 51 搏击俱乐部 邪恶与平庸蛰伏于同一个母体，在特定的时间互相对峙。 52 教父2 优雅的孤独。 &nbsp;&nbsp;&nbsp;&nbsp; 53 狮子王 动物版《哈姆雷特》。 &nbsp;&nbsp; 54 指环王2：双塔奇兵 承前启后的史诗篇章。 &nbsp;&nbsp;&nbsp; 55 死亡诗社 当一个死水般的体制内出现一个活跃的变数时，所有的腐臭都站在了光明的对面。 &nbsp;&nbsp; 56 钢琴家 音乐能化解仇恨。 &nbsp;&nbsp;&nbsp; 57 黑客帝国 视觉革命。 &nbsp;&nbsp;&nbsp; 58 指环王1：魔戒再现 传说的开始。 &nbsp;&nbsp; 59 饮食男女 人生不能像做菜，把所有的料都准备好了才下锅。 &nbsp;&nbsp; 60 窃听风暴 别样人生。 &nbsp;&nbsp;&nbsp; 61 美丽心灵 爱是一切逻辑和原由。 &nbsp;&nbsp;&nbsp;&nbsp; 62 让子弹飞 你给我翻译翻译，神马叫做TMD的惊喜。 &nbsp;&nbsp; 63 绿皮书 去除成见，需要勇气。 &nbsp;&nbsp;&nbsp;&nbsp; 64 两杆大烟枪 4个臭皮匠顶个诸葛亮，盖·里奇果然不是盖的。 &nbsp; 65 本杰明·巴顿奇事 在时间之河里感受溺水之苦。 &nbsp;&nbsp;&nbsp;&nbsp; 66 海蒂和爷爷 如果生活中有什么使你感到快乐，那就去做吧！不要管别人说什么。 &nbsp;&nbsp; 67 飞越疯人院 自由万岁。 68 看不见的客人 你以为你以为的就是你以为的。 &nbsp;&nbsp; 69 西西里的美丽传说 美丽无罪。 &nbsp; 70 拯救大兵瑞恩 美利坚精神输出大片No1. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 71 穿条纹睡衣的男孩 尽管有些不切实际的幻想，这部电影依旧是一部感人肺腑的佳作。 &nbsp;&nbsp; 72 小鞋子 奔跑的孩子是天使。 &nbsp;&nbsp; 73 音乐之声 用音乐化解仇恨，让歌声串起美好。 &nbsp;&nbsp;&nbsp; 74 情书 暗恋的极致。 75 海豚湾 海豚的微笑，是世界上最高明的伪装。 &nbsp; 76 美国往事 往事如烟，无处祭奠。 77 致命魔术 孪生蝙蝠侠大战克隆金刚狼。 &nbsp;&nbsp;&nbsp;&nbsp; 78 沉默的羔羊 安东尼·霍普金斯的顶级表演。 &nbsp;&nbsp; 79 禁闭岛 昔日翩翩少年，今日大腹便便。 &nbsp;&nbsp;&nbsp;&nbsp; 80 低俗小说 故事的高级讲法。 &nbsp;&nbsp; 81 蝴蝶效应 人的命运被自己瞬间的抉择改变。 &nbsp;&nbsp; 82 七宗罪 警察抓小偷，老鼠玩死猫。 &nbsp;&nbsp; 83 心灵捕手 人生中应该拥有这样的一段豁然开朗。 &nbsp; 84 布达佩斯大饭店 小清新的故事里注入了大历史的情怀。 &nbsp;&nbsp; 85 春光乍泄 爱情纠缠，男女一致。 86 摩登时代 大时代中的人生，小人物的悲喜。 &nbsp;&nbsp;&nbsp; 87 哈利·波特与死亡圣器(下) 10年的完美句点。 &nbsp;&nbsp;&nbsp;&nbsp; 88 被嫌弃的松子的一生 以戏谑来戏谑戏谑。 &nbsp; 89 阿凡达 绝对意义上的美轮美奂。 90 喜剧之王 我是一个演员。 91 致命ID 最不可能的那个人永远是最可能的。 &nbsp; 92 剪刀手爱德华 浪漫忧郁的成人童话。 &nbsp;&nbsp; 93 勇敢的心 史诗大片的典范。 &nbsp;&nbsp; 94 杀人回忆 关于连环杀人悬案的集体回忆。 95 加勒比海盗 约翰尼·德普的独角戏。 &nbsp;&nbsp;&nbsp; 96 狩猎 人言可畏。 &nbsp; 97 请以你的名字呼唤我 沉醉在电影的情感和视听氛围中无法自拔。 98 天使爱美丽 法式小清新。 &nbsp;&nbsp; 99 断背山 每个人心中都有一座断背山。 100 红辣椒 梦的勾结。 101 7号房的礼物 《我是山姆》的《美丽人生》。 102 幽灵公主 人与自然的战争史诗。 103 小森林 那些静得只能听见呼吸的日子里，你明白孤独即生活。 &nbsp; 104 阳光灿烂的日子 一场华丽的意淫。 105 第六感 深入内心的恐怖，出人意料的结局。 &nbsp;&nbsp; 106 重庆森林 寂寞没有期限。 107 唐伯虎点秋香 华太师是黄霑，吴镇宇四大才子之一。 &nbsp;&nbsp;&nbsp; 108 小森林 尊敬他人，尊敬你生活的这片土地，明白孤独是人生的常态。 &nbsp; 109 入殓师 死可能是一道门，逝去并不是终结，而是超越，走向下一程。 110 超脱 穷尽一生，我们要学会的，不过是彼此拥抱。 &nbsp;&nbsp;&nbsp; 111 爱在黎明破晓前 缘分是个连绵词，最美不过一瞬。 &nbsp;&nbsp;&nbsp;&nbsp; 112 消失的爱人 年度最佳date movie。 &nbsp; 113 一一 我们都曾经是一一。 114 菊次郎的夏天 从没见过那么流氓的温柔，从没见过那么温柔的流氓。 &nbsp;&nbsp;&nbsp; 115 蝙蝠侠：黑暗骑士崛起 诺兰就是保证。 &nbsp;&nbsp;&nbsp;&nbsp; 116 侧耳倾听 少女情怀总是诗。 117 功夫 警恶惩奸，维护世界和平这个任务就交给你了，好吗？ &nbsp;&nbsp;&nbsp;&nbsp; 118 倩女幽魂 两张绝世的脸。 &nbsp;&nbsp; 119 无人知晓 我的平常生活就是他人的幸福。 &nbsp;&nbsp; 120 超能陆战队 Balalala~~~ &nbsp;&nbsp;&nbsp;&nbsp; 121 人生果实 土壤没有落叶不会肥沃，没有了你就不算人生。 &nbsp; 122 萤火之森 触不到的恋人。 &nbsp;&nbsp; 123 甜蜜蜜 相逢只要一瞬间，等待却像是一辈子。 124 借东西的小人阿莉埃蒂 曾经的那段美好会沉淀为一辈子的记忆。 125 玛丽和马克思 你是我最好的朋友，你是我唯一的朋友 。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 126 爱在日落黄昏时 九年后的重逢是世俗和责任的交叠，没了悸动和青涩，沧桑而温暖。 &nbsp;&nbsp;&nbsp; 127 驯龙高手 和谐的生活离不开摸头与被摸头。 &nbsp;&nbsp; 128 完美的世界 坏人的好总是比好人的好来得更感人。 &nbsp;&nbsp;&nbsp;&nbsp; 129 幸福终点站 有时候幸福需要等一等。 &nbsp;&nbsp;&nbsp;&nbsp; 130 告白 没有一人完全善，也没有一人完全恶。 131 哈利·波特与阿兹卡班的囚徒 不一样的导演，不一样的哈利·波特。 &nbsp;&nbsp;&nbsp;&nbsp; 132 大鱼 抱着梦想而活着的人是幸福的，怀抱梦想而死去的人是不朽的。 &nbsp;&nbsp;&nbsp; 133 阳光姐妹淘 再多各自牛逼的时光，也比不上一起傻逼的岁月。 134 射雕英雄传之东成西就 百看不厌。 135 恐怖直播 恐怖分子的“秋菊打官司”。 136 天书奇谭 传奇的年代，醉人的童话。 137 怪兽电力公司 不要给它起名字，起了名字就有感情了。 &nbsp;&nbsp;&nbsp; 138 神偷奶爸 Mr. I Don’t Care其实也有Care的时候。 &nbsp;&nbsp;&nbsp; 139 玩具总动员3 跨度十五年的欢乐与泪水。 &nbsp;&nbsp;&nbsp; 140 傲慢与偏见 爱是摈弃傲慢与偏见之后的曙光。 &nbsp;&nbsp;&nbsp; 141 哈利·波特与密室 魔法的密室之门已打开… &nbsp;&nbsp;&nbsp;&nbsp; 142 时空恋旅人 把每天当作最后一天般珍惜度过，积极拥抱生活，就是幸福。 &nbsp;&nbsp; 143 教父3 任何信念的力量，都无法改变命运。 &nbsp;&nbsp;&nbsp;&nbsp; 144 釜山行 揭露人性的丧尸题材力作。 145 血战钢锯岭 优秀的战争片不会美化战场，不会粉饰死亡，不会矮化敌人，不会无视常识，最重要的，不会宣扬战争。 &nbsp;&nbsp; 146 哪吒闹海 想你时你在闹海。 &nbsp;&nbsp;&nbsp;&nbsp; 147 被解救的姜戈 热血沸腾，那个低俗、性感的无耻混蛋又来了。 &nbsp;&nbsp;&nbsp; 148 七武士 时代悲歌。 &nbsp;&nbsp;&nbsp;&nbsp; 149 一个叫欧维的男人决定去死 惠及一生的美丽。 &nbsp; 150 喜宴 中国家庭的喜怒哀乐忍。 151 电锯惊魂 真相就在眼前。 152 风之谷 动画片的圣经。 153 我是山姆 爱并不需要智商 。 &nbsp;&nbsp;&nbsp; 154 头号玩家 写给影迷，动漫迷和游戏迷的一封情书。 &nbsp; 155 英雄本色 英雄泪短，兄弟情长。 &nbsp;&nbsp;&nbsp; 156 上帝之城 被上帝抛弃了的上帝之城。 157 谍影重重3 像吃了苏打饼一样干脆的电影。 &nbsp;&nbsp;&nbsp;&nbsp; 158 疯狂原始人 老少皆宜，这就是好莱坞动画的魅力。 &nbsp;&nbsp;&nbsp; 159 未麻的部屋 好的剧本是，就算你猜到了结局也猜不到全部。 160 卢旺达饭店 当这个世界闭上双眼，他却敞开了怀抱。 &nbsp; 161 纵横四海 香港浪漫主义警匪动作片的巅峰之作。 &nbsp; 162 三块广告牌 怼天怼地，你走后，她与世界为敌。 &nbsp;&nbsp; 163 岁月神偷 岁月流逝，来日可追。 &nbsp; 164 花样年华 偷情本没有这样美。 &nbsp; 165 达拉斯买家俱乐部 Jared Leto的腿比女人还美！ &nbsp;&nbsp;&nbsp; 166 心迷宫 荒诞讽刺，千奇百巧，抽丝剥茧，百转千回。 &nbsp; 167 模仿游戏 他给机器起名“克里斯托弗”，因为这是他初恋的名字。 &nbsp; 168 黑客帝国3：矩阵革命 不得不说，《黑客帝国》系列是商业片与科幻、哲学完美结合的典范。 &nbsp;&nbsp;&nbsp;&nbsp; 169 记忆碎片 一个针管引发的血案。 &nbsp; 170 新世界 要做就做得狠一点，这样才能活下去。 &nbsp; 171 头脑特工队 愿我们都不用长大，每一座城堡都能永远存在。 &nbsp;&nbsp;&nbsp;&nbsp; 172 你的名字。 穿越错位的时空，仰望陨落的星辰，你没留下你的名字，我却无法忘记那句“我爱你”。 &nbsp;&nbsp;&nbsp; 173 荒蛮故事 始于荒诞，止于更荒诞。 &nbsp;&nbsp;&nbsp; 174 忠犬八公物语 养狗三日，便会对你终其一生。 &nbsp;&nbsp; 175 真爱至上 爱，是个动词。 &nbsp;&nbsp;&nbsp;&nbsp; 176 爆裂鼓手 这个世界从不善待努力的人，努力了也不一定会成功，但是知道自己在努力，就是活下去的动力。 &nbsp;&nbsp;&nbsp;&nbsp; 177 贫民窟的百万富翁 上帝之城+猜火车+阿甘正传+开心辞典=山寨富翁 &nbsp;&nbsp;&nbsp; 178 萤火虫之墓 幸福是生生不息，却难以触及的远。 &nbsp; 179 东邪西毒 电影诗。 &nbsp;&nbsp;&nbsp; 180 海街日记 是枝裕和的家庭习作。 &nbsp;&nbsp;&nbsp;&nbsp; 181 黑天鹅 黑暗之美。 &nbsp;&nbsp; 182 惊魂记 故事的反转与反转，分裂电影的始祖。 &nbsp;&nbsp;&nbsp; 183 无敌破坏王 迪士尼和皮克斯拿错剧本的产物。 &nbsp;&nbsp;&nbsp;&nbsp; 184 你看起来好像很好吃 感情不分食草或者食肉。 &nbsp;&nbsp; 185 冰川时代 松鼠才是角儿。 &nbsp;&nbsp; 186 小偷家族 我们组成了家。 &nbsp;&nbsp;&nbsp;&nbsp; 187 雨人 生活在自己的世界里，也可以让周围的人显得可笑和渺小。 &nbsp;&nbsp; 188 绿里奇迹 天使暂时离开。 &nbsp;&nbsp;&nbsp; 189 恋恋笔记本 爱情没有那么多借口，如果不能圆满，只能说明爱的不够。 &nbsp; 190 寄生虫 191 爱在午夜降临前 所谓爱情，就是话唠一路，都不会心生腻烦，彼此嫌弃。 &nbsp;&nbsp;&nbsp;&nbsp; 192 哈利·波特与火焰杯 &nbsp;&nbsp;&nbsp;&nbsp; 193 疯狂的石头 中国版《两杆大烟枪》。 &nbsp;&nbsp;&nbsp; 194 恐怖游轮 不要企图在重复中寻找已经失去的爱。 195 奇迹男孩 世界不完美，爱会有奇迹。 &nbsp; 196 雨中曲 骨灰级歌舞片。 &nbsp;&nbsp; 197 魔女宅急便 宫崎骏的电影总让人感觉世界是美好的，阳光明媚的。 198 二十二 有一些东西不应该被遗忘。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 199 海边的曼彻斯特 我们都有权利不与自己的过去和解。 200 房间 被偷走的岁月，被伤害的生命，被禁锢的灵魂，终将被希望和善意救赎。 &nbsp; 201 虎口脱险 永远看不腻的喜剧。 202 九品芝麻官 &nbsp;&nbsp;&nbsp; 203 人工智能 对爱的执着，可以超越一切。 &nbsp;&nbsp;&nbsp;&nbsp; 204 2001太空漫游 现代科幻电影的开山之作，最伟大导演的最伟大影片。 &nbsp;&nbsp;&nbsp;&nbsp; 205 可可西里 坚硬的信仰。 &nbsp;&nbsp;&nbsp; 206 色，戒 假戏真情，爱欲深海 207 罗生门 人生的N种可能性。 &nbsp;&nbsp; 208 城市之光 永远的小人物，伟大的卓别林。 &nbsp;&nbsp;&nbsp;&nbsp; 209 终结者2：审判日 少见的超越首部的续集，动作片中的经典。 210 初恋这件小事 黑小鸭速效美白记。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 211 魂断蓝桥 中国式内在的美国电影。 &nbsp;&nbsp;&nbsp; 212 牯岭街少年杀人事件 弱者送给弱者的一刀。 213 遗愿清单 用剩余不多的时间，去燃烧整个生命。 &nbsp;&nbsp;&nbsp;&nbsp; 214 大佛普拉斯 人们可以登上月球，却永远无法探索人们内心的宇宙。 215 波西米亚狂想曲 &nbsp; 216 新龙门客栈 嬉笑怒骂，调风动月。 &nbsp; 217 源代码 邓肯·琼斯继《月球》之后再度奉献出一部精彩绝伦的科幻佳作。 &nbsp;&nbsp; 218 青蛇 人生如此，浮生如斯。谁人言，花彼岸，此生情长意短。谁都是不懂爱的罢了。 &nbsp; 219 海洋 大海啊，不全是水。 &nbsp;&nbsp;&nbsp; 220 燃情岁月 传奇，不是每个人都可以拥有。 &nbsp;&nbsp;&nbsp;&nbsp; 221 无耻混蛋 昆汀同学越来越变态了，比北野武还杜琪峰。 &nbsp;&nbsp;&nbsp; 222 疯狂的麦克斯4：狂暴之路 “多么美好的一天！”轰轰轰砰咚，啪哒哒哒轰隆隆，磅~ &nbsp;&nbsp;&nbsp;&nbsp; 223 血钻 每个美丽事物背后都是滴血的现实。 &nbsp;&nbsp;&nbsp;&nbsp; 224 步履不停 日本的家庭电影已经是世界巅峰了，步履不停是巅峰中的佳作。 &nbsp;&nbsp; 225 穿越时空的少女 爱上未来的你。 &nbsp; 226 谍影重重2 谁说王家卫镜头很晃？ &nbsp;&nbsp; 227 阿飞正传 王家卫是一种风格，张国荣是一个代表。 &nbsp;&nbsp;&nbsp; 228 彗星来的那一夜 小成本大魅力。 &nbsp; 229 地球上的星星 天使保护事件始末。 230 完美陌生人 来啊，互相伤害啊！ &nbsp; 231 战争之王 做一颗让别人需要你的棋子。 232 谍影重重 哗啦啦啦啦，天在下雨，哗啦啦啦啦，云在哭泣……找自己。 &nbsp;&nbsp;&nbsp;&nbsp; 233 香水 一个单凭体香达到高潮的男人。 &nbsp; 234 东京教父 &nbsp;&nbsp; 235 东京物语 东京那么大，如果有一天走失了，恐怕一辈子不能再相见。 &nbsp;&nbsp;&nbsp; 236 千钧一发 一部能引人思考的科幻励志片。 &nbsp;&nbsp; 237 朗读者 当爱情跨越年龄的界限，它似乎能变得更久远一点，成为一种责任，一种水到渠成的相濡以沫。 238 无间道2 &nbsp;&nbsp;&nbsp; 239 再次出发之纽约遇见你 爱我就给我看你的播放列表。 &nbsp;&nbsp;&nbsp;&nbsp; 240 驴得水 过去的如果就让它过去了，未来只会越来越糟！ &nbsp; 241 黑客帝国2：重装上阵 一个精彩的世界观正在缓缓建立。 &nbsp;&nbsp;&nbsp;&nbsp; 242 崖上的波妞 243 猜火车 不可猜的青春迷笛。 &nbsp; 244 我爱你 你要相信，这世上真的有爱存在，不管在什么年纪 &nbsp; 245 浪潮 世界离独裁只有五天。 246 聚焦 新闻人的理性求真。 &nbsp; 247 小萝莉的猴神大叔 宝莱坞的萝莉与大叔。 &nbsp;&nbsp;&nbsp;&nbsp; 248 追随 诺兰的牛逼来源于内心散发出的恐惧。 249 黑鹰坠落 还原真实而残酷的战争。 &nbsp;&nbsp;&nbsp;&nbsp; 250 网络谜踪 &nbsp;&nbsp;","categories":[{"name":"分享收藏","slug":"分享收藏","permalink":"https://dd-code.site/categories/%E5%88%86%E4%BA%AB%E6%94%B6%E8%97%8F/"}],"tags":[]},{"title":"二维码扫描登录是什么原理","slug":"每日一课/二维码扫描登录是什么原理","date":"2021-05-17T16:00:00.000Z","updated":"2021-07-26T03:23:17.291Z","comments":true,"path":"post/3792249270.html","link":"","permalink":"https://dd-code.site/post/3792249270.html","excerpt":"","text":"","categories":[{"name":"每日一课","slug":"每日一课","permalink":"https://dd-code.site/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AF%BE/"}],"tags":[]},{"title":"不错的在线学习平台","slug":"分享收藏/2020 华为|字节|腾讯|京东|网易|滴滴面经分享（6 个 offer）","date":"2021-05-17T16:00:00.000Z","updated":"2021-07-26T03:23:17.293Z","comments":true,"path":"post/2127643338.html","link":"","permalink":"https://dd-code.site/post/2127643338.html","excerpt":"","text":"以下文章来源于JavaGuide 。 本文是一位读者的面经分享（最终选择了腾讯），封面为读者本人。我对文章进了重新排版。 每个人成功的经历都不可复制， 我们可以借鉴吸收别人的经验为己所用。非常希望这篇文章的内容可以对小伙伴们有帮助！ 另外，把自己上岸的经历分享出来是一件非常棒的事情，我在这里实名为这位读者点个赞 👍 个人介绍目前大三，本科就读于电子科技大学。 我在大一进入学校实验室学习，负责数据收集、日常开发、NLP。用到的技术包括： 语言：Java、Python 技术： 爬虫：协程、异步 OI、正则表达式 后端：SpringBoot、MyBatis、MySQL 前端：HTML、CSS、JavaScript、BootStrap 深度学习：Pytorch、Keras 在实验室接触的比较广泛，不过感觉不够深入，于是在大二下开始深入后端技术。 我在大二下开始做了些开源项目并深入 Java 相关技术，深入学习了：Java 核心技术、Java 虚拟机、Java 并发编程、设计模式、MySQL、Spring、SpringBoot、Mybatis。 在大三上期，11 月开始准备 Java 实习相关事务： 一个月的面试后，陆续拿到了字节，网易、京东、滴滴、腾讯和某区块链公司的 6 个实习 offer。 复习经历因为之前就深入学习过，所以总的复习时间也不长，大概是一周左右，后面是通过边面试边查漏补缺的方式来补短板。 前两天的复习内容： Java 基础 面向对象特性：封装，多态（动态绑定，向上转型），继承 泛型，类型擦除 反射，原理，优缺点 static，final 关键字 String，StringBuffer，StringBuilder底层区别 BIO、NIO、AIO Object 类的方法 自动拆箱和自动装箱 Java 集合框架 List ：ArrayList、LinkedList、Vector、CopyOnWriteArrayList Set：HashSet、TreeSet、LinkedHashSet Queue：PriorityQueue Map：HashMap，TreeMap，LinkedHashMap fast-fail，fast-safe 机制 源码分析（底层数据结构，插入、扩容过程）、线程安全。 Java 虚拟机 类加载机制、双亲委派模式、3 种类加载器（BootStrapClassLoader，ExtensionClassLoader，ApplicationClassLoader） 运行时内存分区（PC，Java 虚拟机栈，本地方法栈，堆，方法区（永久代，元空间）） JMM：Java 内存模型 引用计数、可达性分析 垃圾回收算法：标记-清除，标记-整理，复制 垃圾回收器：比较，区别（Serial，ParNew，Parallel Scavenge ，CMS，G1）Stop The World 强、软、弱、虚引用 内存溢出、内存泄漏排查 JVM 调优，常用命令 Java 并发 三种线程初始化方法（Thread、Callable，Runnable）区别 线程池（ThreadPoolExecutor，7 大参数，原理，四种拒绝策略，四个变型：Fixed，Single，Cached，Scheduled） Synchronized： 使用：方法（静态，一般方法），代码块（this，ClassName.class） 1.6 优化：锁粗化，锁消除，自适应自旋锁，偏向锁，轻量级锁 锁升级的过程和细节：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁（不可逆） 重量级锁的原理（monitor对象，monitorenter,monitorexit） ReentrantLock：和Synchronized区别？（公平锁、非公平锁、可中断锁….）、原理、用法 有界、无界任务队列，手写BlockingQueue。 乐观锁：CAS（优缺点，ABA 问题，DCAS） 悲观锁： ThreadLocal ：底层数据结构：ThreadLocalMap、原理、应用场景。 Atomic 类（原理，应用场景） AQS：原理、Semaphore、CountDownLatch、CyclicBarrier Volatile：原理：有序性，可见性 第三天的复习内容： MySQL 架构：Server 层，引擎层（缓存，连接器，分析器，优化器，处理器） 引擎：InnoDB，MyISAM，Memory 区别 聚簇索引，非聚簇索引区别（从二叉平衡搜索树复习（AVL，红黑树）到 B 树，最后 B+树） MySQL、SQL 优化方法 覆盖索引，最左前缀匹配 当前读，快照读 MVCC 原理（事务 ID，隐藏字段，Undo，ReadView） Gap Lock、Next-Key Lock、Record Lock 三大范式 SQL 常用 SQL 连接：自连接，内连接（等值，非等值，自然连接），外连接（左，右，全） Group BY 和 Having Explain 第四天的复习内容： Spring AOP 原理（JDK 动态代理，CGLIB 动态代理）和 IOC 原理 Spring Bean 生命周期 SpringMVC 原理 SpringBoot 常用注解 设计模式 三种类型：创建、结构、行为 单例模式：饿汉，懒汉，DCL 简单工厂，工厂方法，抽象工厂 代理模式 装饰器模式 观察者模式 策略模式 迭代器模式 …. 第五天的复习内容： 计算机网络 OSI 模型、TCP/IP 模型 TCP 和 UDP 区别 TCP 可靠性传输原理：重传、流量控制、拥塞控制、序列号与确认应达号、校验和 三次握手、四次挥手过程、原理 timewait、closewait HTTP 报文格式 1.0 1.1 2.0 状态码 无状态解决（Cookie Session 原理） HTTPS CA 证书 对称加密 非对称加密 DNS 解析过程，原理 IP 协议、ICMP 协议（Ping、Tracert）、ARP 协议、路由协议 攻击手段与防范：XSS、CSRF、SQL 注入、DOS、DDOS 第六天的复习内容： 操作系统： 进程、线程和协程区别 进程通信方式（管道，消息队列，共享内存，信号，信号量，socket） 进程调度算法（先来先服务，短作业优先，时间片轮换，多级反馈队列，优先级调度） 内存管理：分页（页面置换算法：手写 LRU）、分段、虚拟内存 第七天和以后的复习内容： 每天做点刷算法题(剑指 offer、LeetCode 面试 Hot 题) +查漏补缺。 面试经历字节跳动第一面 自我介绍，介绍项目 协程、线程、进程区别 手写 LRU（要求用泛型写）、手写 DCL DNS 解析过程 输入一个 URL 到浏览器，整体流程 谈谈 Java 虚拟机你的认识？垃圾回收算法？垃圾回收器 知道哪些 Java 的锁？CAS 的缺点？ 第二面 自我介绍、介绍项目 手写最大堆 设计模式了解吗？几大类型？谈谈工厂模式？ 谈一下 Java 集合框架？HashMap 线程安全的吗？会出现什么问题？ 说说 MySQL 的架构？ InnoDB 和 MyISAM 区别？ 知道聚簇索引和非聚簇索引吗？B 树和 B+树区别？ 一道 LeetCode 难问题：接雨水（动态规划解决） 第三面 自我介绍、介绍开源项目 线程池了解吗？原理？可以写个 BlockingQueue 吗？ 说说 fast-fail 和 fast-safe？ 了解死锁吗？怎么解决？ 进程间通信方式？哪种最高效？ 说说 MYSQL 优化策略？ 说了一下部门介绍，主要业务，说可能会转 GO 等等 第四面（HR） 介绍自己 团队怎么协作？有没有矛盾？怎么解决的？ 入职时间？实习多久？ 华为第一面 自我介绍 谈项目（谈了很久） HTTP 的无状态怎么解决？（Cookie Session） TCP 如何保证可靠性传输？（校验和，序列号和确认应答号，重传，流量控制，拥塞控制） ARP 过程？ 进程调度算法？ 一道动态规划题目：不同路径 第二面 自我介绍 谈项目（你觉得收获最大的项目） 谈谈 Spring AOP 和 IOC 谈谈你知道的 MySQL 所有内容 手写个归并排序 谈谈你对分布式系统的认识？ 谈谈你对华为的认识？华为的文化和价值观？ HR技术面试都通过了，问 HR 怎么样，说应该没问题，等了一星期 offer，最后发 offer 的时候，HR 说我的性格测试没通过，Offer 审批不下来，人傻了。因为华为在成都，字节在北京，而且技术官的意向是很稳能进华为，我想着在家近的地方实习，在等待的一周中就把字节拒了，最后华为没发到 offer，直接架空，崩溃！第一次找实习没太多经验，策略不对，心里很难受，不过调整了一下，继续了新的面试 网易第一面 自我介绍 介绍一个对自己影响深刻的项目 说说进程间调度的算法 说说匿名函数 说说协程、线程、进程。 你对游戏引擎了解多少？ 手写地杰斯特拉算法？ 了解 A*算法吗？ 说说 Python 和 Java 的区别？ Java 是怎么进行垃圾回收的？ 然后聊了很多生活上的问题，非技术问题。 第二面 自我介绍 介绍项目 说说深度优先搜索算法、回溯算法 一道算法题：一个走迷宫问题，DFS+回溯解决。 你对 C 熟悉吗？Lua 使用过吗？ 介绍业务，主要工作内容。 HR 面 自我介绍 介绍一个项目中遇到的问题，怎么解决的？ 介绍一下博客？开源项目？为什么花时间做这些？ 大学最成功的一件事？ 滴滴第一面 自我介绍、介绍项目 Java 面向对象的三大特性？ 了解 Java 哪些锁？Synchronized 优化内容？锁升级过程？ 谈谈 Java 虚拟机？类加载机制？ 知道双亲委派模式吗？有什么好处？ Java 运行时内存分区？ 死锁了解吗？如何解决？ 哪些对象可以作为 GC ROOTS？ 了解的设计模式？手写一下 DCL 吧 第二面 自我介绍 介绍项目（难点以及怎么解决的？） 谈谈 MySQL 的各种引擎？ 覆盖索引和非覆盖索引区别？ MYSQL 优化方法有哪些？ 讲讲 HashMap 的原理，put 过程？resize 过程？线程安全吗？死循环问题？ 了解什么中间件吗？ 讲讲 Java 里面的锁？ 一道算法题：最长公共子串 HR 面 自我介绍 到岗时间 自己的优势 大学最失败的一件事 对加班的看法 京东第一面 自我介绍 谈项目 TCP 如何保证可靠传输？拥塞控制算法？ 讲讲 Spring 的 AOP？ SpringBoot 常用哪些注解？ 谈谈 Java 虚拟机？ 垃圾回收算法有哪些？ 了解哪些垃圾回收器？讲一下 CMS 垃圾回收过程 算法题： 两个栈实现队列 最近公共祖先节点 第二面 自我介绍 讲讲 Java 集合框架，HashMap 原理。 知道哪些锁？ 谈谈公平锁和非公平锁？ Synchronized 和 ReentrantLock 区别 MySQL 的索引为什么快？有哪些索引？原理数据结构？ MySQL 有哪些优化的策略？ 死锁了解吗？ ThreadLocal 了解吗？原理？ 手写一个堆排序。 一道算法题：完全平方数（动态规划） HR 面 自我介绍 多久可以到岗？实习时间？ 对加班看法？ 如何团队分工的？ 腾讯第一面 自我介绍 介绍项目 说说协程和线程区别？ Java 虚拟机的作用？垃圾回收的过程？ 了解的垃圾回收器？ 手写快排 算法题：按 K 位反转链表 一百亿个数，n 个机器，怎么排序？（桶排序） 第二面 自我介绍 介绍项目 TCP 和 UDP 区别？如何保证可靠性？ HTTP 的状态码记得哪些？ ICMP 是哪层的？有什么用？ 会哪些框架？ Spring 的 AOP 认识？ MySQL InnoDB 和 MyISAM 区别？ 谈谈各种索引？为什么用 B+树不用 B 树？ 死锁的条件？如何解决？ OOM 怎么排查？ 介绍业务 HR 面 自我介绍 多久能来实习？实习多久？ 加班看法？ 看你掌握技术挺多，如何快速学习一个技术的？ 总结因为之前学的也比较深入，复习时间也没用太多，主要就是写点算法题保持手感。 面试中遇到的问题，9 成都已经复习了，而且也比较基础，也都在掌握之中。 像中间件、微服务这些我没写在简历上，不是很会，面试官也不会刻意刁难你，实习的话，感觉大厂可能更注重基础和对知识的深入度，面试了一个月收货还是挺多的，希望总结一下面经，帮到更多的人~ 准备大厂面试的话，注重基础，多练算法题，基本上就没问题了！加油！","categories":[{"name":"分享收藏","slug":"分享收藏","permalink":"https://dd-code.site/categories/%E5%88%86%E4%BA%AB%E6%94%B6%E8%97%8F/"}],"tags":[]},{"title":"Go进阶训练营课程大纲学习体系","slug":"分享收藏/Go进阶训练营课程大纲学习体系","date":"2021-05-17T16:00:00.000Z","updated":"2021-07-26T03:23:17.294Z","comments":true,"path":"post/659461921.html","link":"","permalink":"https://dd-code.site/post/659461921.html","excerpt":"","text":"模块一Go 语言实践 - Runtime教学目标 了解 Go 语言中 Goroutine 的调度原理 了解 Go 语言中的内存模型 了解 Go 语言中 GC（垃圾回收）的原理 了解 Go 语言中 channel 的消息通讯原理 学习和工作中的痛点 分不清 Goroutine 和线程的区别 不熟悉 Go 的内存分配机制 搞不懂 GC 三色标记算法 不了解 channel 的底层实现 详细内容 Goroutine 的实现、GPM 调度模型、调度状态及流转、调度原理、协作式抢占以及和网络库的协作 Go 内存分配的内部结构和分配机制 Go GC 介绍、三色标记的实现原理、GC 的流程以及 GC 的一些优化方案 Go channel 的通讯机制、环形队列的结构、调度和唤醒的原理 模块二：Go 语言实践 - 并行编程教学目标 了解 Go 语言中的 Memory Model 了解 Go 语言的并发特性并发编程模式：Timeout、Pipeline、Cancellation、Fanout、errgroup 等模式 了解 Go 语言中 Context 的原理并掌握其使用方法 学习和工作中的痛点 搞不清楚 Go 中内存模型和同步语义 无法熟练使用基于 channel 通讯方式的并行编程模式 不明白 Context 传播式传递有什么意义 详细内容 内存模型：Happens Before、同步语义、channel 通讯、锁 利用 channel 完成并行开发的设计模式，包含超时控制、管道、扇出、errgroup 并发 使用 Go 标准库 Context 的原理和最佳实践，包含超时控制、元数据传递、生命周期控制 模块三：Go 语言实践 - 网络编程教学目标 熟练掌握 Go 语言中的 TCP 网络编程 熟练掌握 Go 语言中的 HTTP 网络编程 学习和工作中的痛点 不知道怎么用 Go 实现高性能的 TCP Server HTTP 框架有不少，但不知道怎样做选型 不会针对业务需求对 HTTP 框架做针对性的扩展 详细内容 结合 goim 项目了解 Go 语言中 TCP Server 的基础库和性能优化方案 结合 gin 项目了解 Go 语言中的 HTTP Server 的基础库和框架 模块四：Go 语言实践 - 异常处理教学目标 了解 Go 语言中 error 的处理方法 了解 Go 语言中业务错误的处理方法 学习和工作中的痛点 error 的处理复杂，不会正确使用 业务错误定义和 error 整合难度较高 详细内容 Go 语言中的 error 处理实践：检查错误、定义错误、追加上下文 Go 项目中的业务错误码如何结合 error 的最佳实践 模块五：Go 工程化实践教学目标 了解 Go 项目中良好的项目目录组织原则和规范 了解 Go 项目中 API 的设计方法和规范 了解 Go 项目中 Package 的管理和设计方法 了解 Go 项目中的单元测试方法 学习和工作中的痛点 不知道怎么做 Go 项目的标准化管理 总是设计出各种不合理的 API 不知道怎么做包管理 详细内容 良好的 Go 项目中的分层目录结构组织和代码规范 Go 项目中 API 的设计原则和方法：定义、状态和业务错误码处理 Go 项目中包的设计和最佳实践、go mod 的使用 go test 工具链的使用方法、单元测试的最佳实践以及 Mock 技术 模块六：Go 架构实践 - 分布式架构（前端负载均衡）教学目标 掌握高可用 DNS 的最佳实践 了解 CDN 的架构和应用场景 深入理解 4/7 层负载均衡的原理 学习和工作中的痛点 缺乏对在线服务的全链路视野 不了解应用服务上层的负载均衡 详细内容 DNS 的原理、防劫持的方法、HTTPDNS + IP 长连接 CDN 的系统架构、应用领域以及保证数据一致性的方法 LVS、Nginx 4/7 层负载均衡的原理和实践 模块七：Go 架构实践 - 分布式架构（数据分片）教学目标 掌握数据 Sharding 的设计原则 了解 Hash 分片的算法和演进历史 学习和工作中的痛点 不了解 Sharding 的应用场景，不会合理使用 搞不清楚各种变种 Hash 算法的使用场景 详细内容 架构设计中的数据分片设计，如：分库分表、多活的 Shard 设计等等 分片算法的 Hash 实现和演进：Hash 求余、一致性 Hash、有界负载一致性 Hash、节点映射 模块八：Go 架构实践 - 微服务（微服务概览与治理）教学目标 了解微服务的演进历史及它的优缺点 了解微服务的设计方法 了解微服务中 RPC 的底层原理 学习和工作中的痛点 不理解微服务的服务角色：API Gateway、BFF 还是 Service？ 不知道怎么做微服务拆分 不理解 RPC 的原理，不知道如何进行微服务 RPC 框架的选型 详细内容 微服务的原理、概念，以及微服务的实现细节 API Gateway、BFF、Service 等概念精讲 微服务通讯 RPC 框架的细节和选型 模块九：Go 架构实践 - 微服务（可用性设计）教学目标 掌握可用性设计的最佳实践 了解可用性设计的几大关键点：隔离、超时控制、过载保护、限流、容错&amp;重试 学习和工作中的痛点 不知道如何设计高可用的分布式服务 不清楚如何提升服务自愈能力 详细内容 微服务的隔离实现，以及架构设计中的隔离实现 进程内超时控制和跨进程超时控制 程序自保护避免过载，抛弃一定的流量完成自适应限流 单机限流、多租户场景的分布式限流 节点故障的容错逻辑、重试容错的策略和设计 模块十：Go 架构实践 - 中间件（日志、指标、链路追踪）教学目标 了解 Go 项目中的日志收集 了解 Go 项目中的监控指标体系 了解 Go 项目中的分布式链路追踪 学习和工作中的痛点 不知道如何解决微服务的可观测性难题 不清楚怎么做微服务的可视化和标准化 出故障后，难以对微服务进行问题诊断 详细内容 实现一个可以集中收集所有微服务实例的日志，并能统一查看和检索的日志采集架构 指标监控、使用 Prometheus 解决监控可视化、指标采集 微服务中的跨服务性能问题诊断，结合 Jaeger 实现分布式链路追踪 模块十一：Go 架构实践 - 中间件（缓存、数据库）教学目标 了解 Redis、Memcache 的原理和实战技巧 了解 MySQL 的常用设计和优化方法 学习和工作中的痛点 不会解决缓存的一致性问题 不知道怎样合理地设计 MySQL 的表 详细内容 Redis、Memcache 的应用场景、最佳实践，以及缓存的一致性设计 MySQL 的表设计、常用优化手段，以及如何解决分布式事务 模块十二：Go 架构实践 - 中间件（消息队列、服务发现）教学目标 深入理解消息队列的原理，掌握基于消息队列的架构设计方法 服务发现原理、选型策略，以及服务发现实现的微服务多租户架构 学习和工作中的痛点 不会做消息解耦的架构设计 不清楚如何实现服务发现对平滑发布的支持 不知道怎样利用多租户实现多测试环境 详细内容 Kafka 的实现原理、异步消息系统的架构设计 RPC 服务发现、动态地址的选型和实现原理，以及基于服务发现的平滑重启和多租户架构","categories":[{"name":"分享收藏","slug":"分享收藏","permalink":"https://dd-code.site/categories/%E5%88%86%E4%BA%AB%E6%94%B6%E8%97%8F/"}],"tags":[]},{"title":"高级 Go 工程师岗位职责","slug":"分享收藏/高级 Go 工程师岗位职责","date":"2021-05-17T16:00:00.000Z","updated":"2021-07-26T03:23:17.300Z","comments":true,"path":"post/1891777730.html","link":"","permalink":"https://dd-code.site/post/1891777730.html","excerpt":"","text":"数据来源：主流招聘网站、一线公司 JD 熟练掌握 Go 语言，熟悉 Goroutine、Channel、锁、GC 等核心特性； 具备 3 年以上后端开发经验，并具有 1 年以上 Go 语言服务端开发经验； 熟练掌握 Golang 常用框架，深入了解框架提供的特性及其实现原理细节； 熟悉常见的中间件技术，包括但不限于 MySQL、RPC、MQ、Redis 等； 了解分布式技术，具备扎实的工程经验和软件设计能力； 熟悉微服务架构，具有高并发或大型 Go 项目经验者优先。","categories":[{"name":"分享收藏","slug":"分享收藏","permalink":"https://dd-code.site/categories/%E5%88%86%E4%BA%AB%E6%94%B6%E8%97%8F/"}],"tags":[]},{"title":"2019年必学的DevOps流行工具","slug":"每日一课/2019年必学的DevOps流行工具","date":"2021-05-16T16:00:00.000Z","updated":"2021-07-26T03:23:17.291Z","comments":true,"path":"post/2648367562.html","link":"","permalink":"https://dd-code.site/post/2648367562.html","excerpt":"","text":"","categories":[{"name":"每日一课","slug":"每日一课","permalink":"https://dd-code.site/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AF%BE/"}],"tags":[]},{"title":"05 | 控制结构：If 条件语句","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门/ch1-3-1","date":"2021-04-24T16:00:00.000Z","updated":"2021-08-10T16:03:25.635Z","comments":true,"path":"post/1632346433.html","link":"","permalink":"https://dd-code.site/post/1632346433.html","excerpt":"","text":"If 条件语句1234567//if条件语句1 i := 6 if i &gt; 10 &#123; fmt.Println(&quot;i&gt;10&quot;) &#125; else &#123; fmt.Println(&quot;i&lt;=10&quot;) &#125; 123456789//if条件语句2 c := 6 if c &gt; 10 &#123; fmt.Println(&quot;c&gt;10&quot;) &#125; else if c &gt; 5 &amp;&amp; c &lt; 10 &#123; fmt.Println(&quot;5&lt;c&lt;=10&quot;) &#125; else &#123; fmt.Println(&quot;c&lt;=5&quot;) &#125; 关于 if 条件语句的使用有一些规则： if 后面的条件表达式不需要使用 ()，这和有些编程语言不一样，也更体现 Go 语言的简洁 每个条件分支（if 或者 else）中的大括号是必须的，哪怕大括号里只有一行代码（如示例） if 紧跟的大括号 { 不能独占一行，else 前的大括号 } 也不能独占一行，否则会编译不通过 在 if……else 条件语句中还可以增加多个 else if，增加更多的条件分支 12345678910func main() &#123; if i:=6; i &gt;10 &#123; fmt.Println(&quot;i&gt;10&quot;) &#125; else if i&gt;5 &amp;&amp; i&lt;=10 &#123; fmt.Println(&quot;5&lt;i&lt;=10&quot;) &#125; else &#123; fmt.Println(&quot;i&lt;=5&quot;) &#125;&#125;","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"22讲通关Go语言","slug":"课程学习/22讲通关Go语言","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/"},{"name":"01-Go语言快速入门","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/01-Go%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[]},{"title":"06 | 控制结构：switch 选择语句","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门/ch1-3-2","date":"2021-04-24T16:00:00.000Z","updated":"2021-08-10T16:03:25.636Z","comments":true,"path":"post/1946029743.html","link":"","permalink":"https://dd-code.site/post/1946029743.html","excerpt":"","text":"switch 选择语句12345678switch i:=6;&#123;case i&gt;10: fmt.(&quot;i&gt;10&quot;)case i&gt;5 &amp;&amp; i&lt;=10: fmt.Println(&quot;5&lt;i&lt;=10&quot;)default: fmt.Println(&quot;i&lt;=5&quot;)&#125; switch 语句同样也可以用一个简单的语句来做初始化，同样也是用分号 ; 分隔。每一个 case 就是一个分支，分支条件为 true 该分支才会执行，而且 case 分支后的条件表达式也不用小括号 () 包裹。 增加 fallthrough 关键字12345678switch j:=1;j &#123;case 1: fallthroughcase 2: fmt.Println(&quot;1&quot;)default: fmt.Println(&quot;没有匹配&quot;)&#125; 以上示例运行会输出 1，如果省略 case 1: 后面的 fallthrough，则不会有任何输出。 switch增加表达式操作123456switch 2&gt;1 &#123;case true: fmt.Println(&quot;2&gt;1&quot;)case false: fmt.Println(&quot;2&lt;=1&quot;)&#125;","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"22讲通关Go语言","slug":"课程学习/22讲通关Go语言","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/"},{"name":"01-Go语言快速入门","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/01-Go%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[]},{"title":"07 | 控制结构：for 循环语句","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门/ch1-3-3","date":"2021-04-24T16:00:00.000Z","updated":"2021-08-10T16:03:25.636Z","comments":true,"path":"post/3410127306.html","link":"","permalink":"https://dd-code.site/post/3410127306.html","excerpt":"","text":"for 循环语句12345sum:=0for i:=1;i&lt;=100;i++ &#123; sum+=i&#125;fmt.Println(&quot;the sum is&quot;,sum) 简写 for 循环（等同于while）1234567sum:=0i:=1for i&lt;=100 &#123; sum+=i i++&#125;fmt.Println(&quot;the sum is&quot;,sum) for 循环里边使用 break12345678910sum:=0i:=1for &#123; sum+=i i++ if i&gt;100 &#123; break &#125;&#125;fmt.Println(&quot;the sum is&quot;,sum) 这个示例使用的是没有任何条件的 for 循环，也称为 for 无限循环。此外，使用 break 退出无限循环，条件是 i&gt;100。 for 循环里边使用 continue123456789sum := 0for i:=1; i&lt;100; i++&#123; if i%2!=0 &#123; continue &#125; sum+=i&#125;fmt.Println(&quot;the sum is&quot;,sum) 这个示例的关键在于：如果 i 不是偶数，就会用 continue 跳出本次循环，继续下个循环；如果是偶数，则继续执行 sum+=i，然后继续循环，这样就达到了只计算 100 以内偶数之和的目的。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"22讲通关Go语言","slug":"课程学习/22讲通关Go语言","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/"},{"name":"01-Go语言快速入门","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/01-Go%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[]},{"title":"04 | 数据类型：查找字符串","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门/ch1-2-3","date":"2021-04-23T16:00:00.000Z","updated":"2021-08-10T16:03:25.668Z","comments":true,"path":"post/239718908.html","link":"","permalink":"https://dd-code.site/post/239718908.html","excerpt":"","text":"一个字符串中查找某个字符串是否存在1i:&#x3D;strings.Index(&quot;飞雪无情&quot;,&quot;飞雪&quot;)","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"22讲通关Go语言","slug":"课程学习/22讲通关Go语言","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/"},{"name":"01-Go语言快速入门","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/01-Go%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[]},{"title":"03 | 数据类型：字符串和数字","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门/ch1-2-2","date":"2021-04-23T16:00:00.000Z","updated":"2021-08-10T16:03:25.635Z","comments":true,"path":"post/3069556377.html","link":"","permalink":"https://dd-code.site/post/3069556377.html","excerpt":"","text":"字符串和数字互转Go 语言是强类型语言，不同类型的变量是不能相互使用和计算。 不同类型的变量在使用或者计算前，需要进行类型转换， 字符串转数字函数： strconv.Atoi 示例： 123456i2s:=strconv.Itoa(i)s2i,err:=strconv.Atoi(i2s)fmt.Println(i2s,s2i,err) 通过包 strconv 的 Itoa 函数可以把一个 int 类型转为 string，Atoi 函数则用来把 string 转为 int。 同理对于浮点数、布尔型，Go 语言提供了 strconv.ParseFloat、strconv.ParseBool、strconv.FormatFloat 和 strconv.FormatBool 进行互转 对于数字类型之间，可以通过强制转换的方式，如以下代码所示： 123456i2f:=float64(i)f2i:=int(f64)fmt.Println(i2f,f2i) Strings包官方关于介绍 strings 包的说明：https://golang.google.cn/pkg/strings/ Example123456789101112//判断s1的前缀是否是Hfmt.Println(strings.HasPrefix(s1,&quot;H&quot;))//在s1中查找字符串ofmt.Println(strings.Index(s1,&quot;o&quot;))//把s1全部转为大写fmt.Println(strings.ToUpper(s1))","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"22讲通关Go语言","slug":"课程学习/22讲通关Go语言","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/"},{"name":"01-Go语言快速入门","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/01-Go%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[]},{"title":"02 | 数据类型：变量的声明","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门/ch1-2-1","date":"2021-04-23T16:00:00.000Z","updated":"2021-08-10T16:03:25.635Z","comments":true,"path":"post/2755664247.html","link":"","permalink":"https://dd-code.site/post/2755664247.html","excerpt":"","text":"变量的声明1var 变量名 类型=表达式 Example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package mainimport &quot;fmt&quot;func main() &#123; //var声明一个变量格式 // var 变量名 类型 = 表达式 var a int = 10 fmt.Println(a) //也可以不指定变量的类型 var b = 20 fmt.Println(b) //一次声明多个变量 var ( c = 1 d = 2 ) fmt.Println(c) fmt.Println(d) //因为是同类型的变量，可以简写为 var ( j = 0 k = 1 ) fmt.Println(j) fmt.Println(k) //TODO::Go的基础类型学习 //TODO::整型，整型可分为： //TODO::有符号整型：int、int8、int16、int32和int64 //TODO::浮点型 fmt.Println(&quot;---------浮点型-------&quot;) var f32 float32 = 2.2 var f64 float64 = 10.3456 fmt.Println(&quot;f32:&quot;, f32, &quot;f64:&quot;, f64) //TODO::布尔型 fmt.Println(&quot;---------布尔型-------&quot;) var bf bool = false var bt bool = true fmt.Println(&quot;bf:&quot;, bf, &quot;bt:&quot;, bt) //TODO::字符串 fmt.Println(&quot;---------字符串-------&quot;) var s1 string = &quot;世界&quot; var s2 string = &quot;hello&quot; fmt.Println(&quot;say:&quot;, s1+s2) //TODO::零值 fmt.Println(&quot;---------零值-------&quot;) var z1 int var z2 float64 var z3 bool var z4 string fmt.Println(z1, z2, z3, z4) //TODO::变量 fmt.Println(&quot;---------变量的简短声明-------&quot;) //变量名:=b表达式（等于 var 变量名=表达式） i := 10 //bf1: = true //s1 := &quot;Hello&quot; fmt.Println(&quot;简短声明：&quot;, i) //TODO::指针 fmt.Println(&quot;---------指针-------&quot;) pi := &amp;i fmt.Println(*pi) //TODO::赋值 fmt.Println(&quot;---------赋值-------&quot;) i = 20 fmt.Println(&quot;i的新值为：&quot;, i) //TODO::常量【在 Go 语言中，只允许布尔型、字符串、数字类型这些基础类型作为常量】 fmt.Println(&quot;---------常量-------&quot;) const name = &quot;飞雪无情&quot; //TODO::常量生成器iota fmt.Println(&quot;---------常量生成器-------&quot;) const ( one = 1 two = 2 three = 3 four = 4 ) fmt.Println(&quot;常量生成器：&quot;, one, two, three, four) const ( oneI = iota + 1 twoI threeI fourI ) fmt.Println(&quot;常量生成器(递增)：&quot;, oneI, twoI, threeI, fourI)&#125;","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"22讲通关Go语言","slug":"课程学习/22讲通关Go语言","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/"},{"name":"01-Go语言快速入门","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/01-Go%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[]},{"title":"开篇词","slug":"课程学习/22讲通关Go语言/00-开篇词/ch1-0","date":"2021-04-22T16:00:00.000Z","updated":"2021-08-10T16:03:13.362Z","comments":true,"path":"post/188254796.html","link":"","permalink":"https://dd-code.site/post/188254796.html","excerpt":"","text":"Go 语言的优势 语法简洁、上手快（至于上手快不快，首先得上手）、开发效率更高 垃圾回收机制、自动释放内存、可以大大提高性能 Go 天生支持并发处理，可以开发出高性能程序 强大的标准库、丰富的第三方库，提升开发效率 可以编译为执行文件，不依赖其他的库，部署方便 跨平台支持，支持编译成不同平台的程序","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"22讲通关Go语言","slug":"课程学习/22讲通关Go语言","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/"},{"name":"00-开篇词","slug":"课程学习/22讲通关Go语言/00-开篇词","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/00-%E5%BC%80%E7%AF%87%E8%AF%8D/"}],"tags":[]},{"title":"01 | 基础入门：编写你的第一个 Go 语言程序","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门/ch1-1","date":"2021-04-22T16:00:00.000Z","updated":"2021-08-10T16:05:22.750Z","comments":true,"path":"post/1719467524.html","link":"","permalink":"https://dd-code.site/post/1719467524.html","excerpt":"","text":"第一个 Go 程序 “Hello Go”12345678package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello Go&quot;)&#125; 运行 Go 程序1go run main.go 结果1Hello Go 程序结构package main 代表的是一个可运行的应用程序，main 函数则是这个应用程序的主入口。 第一行的 package main 代表当前的 go 程序文件属于哪个包，其中 package 是 Go 语言声明包的关键字，main 代表声明的包的名字。 第二行的 import “fmt” 是导入一个 fmt 包，import 也是 Go 的关键字。 第三行的 func main() 代表定义一个函数，其中 func 也是 Go 的关键字，表示定义一个函数或者一个方法，main 是函数名。在 Go 语言中 main 函数是一个特殊的函数，它是整个程序的入口。在程序运行的时候，会先调用 main 函数，然后通过 main 函数再调用其他函数，实现业务逻辑。 第四行的 fmt.Println(“Hello Go”) ，是打印输出结果 “Hello Go” 第五行的 代表 main 函数结束，整个程序结束 编译发布 Go 程序1go build main.go 执行会生成 main 可执行文件，执行以下命令也会输出 “Hello Go” 1./main 跨平台编译官方文档：https://golang.org/doc/install/source#environment","categories":[{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"22讲通关Go语言","slug":"课程学习/22讲通关Go语言","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/"},{"name":"01-Go语言快速入门","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/01-Go%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[]}],"categories":[{"name":"自考提升","slug":"自考提升","permalink":"https://dd-code.site/categories/%E8%87%AA%E8%80%83%E6%8F%90%E5%8D%87/"},{"name":"网络经济与企业管理","slug":"自考提升/网络经济与企业管理","permalink":"https://dd-code.site/categories/%E8%87%AA%E8%80%83%E6%8F%90%E5%8D%87/%E7%BD%91%E7%BB%9C%E7%BB%8F%E6%B5%8E%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%AE%A1%E7%90%86/"},{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Service","slug":"技术学习/Service","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Service/"},{"name":"Redis","slug":"技术学习/Redis","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Redis/"},{"name":"数据库","slug":"技术学习/数据库","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Memcache","slug":"技术学习/数据库/Memcache","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/Memcache/"},{"name":"Oracle","slug":"技术学习/Oracle","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Oracle/"},{"name":"MySQL","slug":"技术学习/MySQL","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/MySQL/"},{"name":"Mongo","slug":"技术学习/Mongo","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Mongo/"},{"name":"LeetCode","slug":"技术学习/LeetCode","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/LeetCode/"},{"name":"Docker","slug":"技术学习/Docker","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/Docker/"},{"name":"分享收藏","slug":"分享收藏","permalink":"https://dd-code.site/categories/%E5%88%86%E4%BA%AB%E6%94%B6%E8%97%8F/"},{"name":"编程语言","slug":"编程语言","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"编程语言/PHP","permalink":"https://dd-code.site/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"},{"name":"课程学习","slug":"课程学习","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"廖雪峰的Java教程","slug":"课程学习/廖雪峰的Java教程","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/"},{"name":"03-运算","slug":"课程学习/廖雪峰的Java教程/03-运算","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/03-%E8%BF%90%E7%AE%97/"},{"name":"算法","slug":"技术学习/算法","permalink":"https://dd-code.site/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"},{"name":"02-基本数据类型","slug":"课程学习/廖雪峰的Java教程/02-基本数据类型","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/02-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"01-Java基础","slug":"课程学习/廖雪峰的Java教程/01-Java基础","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/01-Java%E5%9F%BA%E7%A1%80/"},{"name":"00-开篇词","slug":"课程学习/廖雪峰的Java教程/00-开篇词","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%9A%84Java%E6%95%99%E7%A8%8B/00-%E5%BC%80%E7%AF%87%E8%AF%8D/"},{"name":"22讲通关Go语言","slug":"课程学习/22讲通关Go语言","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/"},{"name":"01-Go语言快速入门","slug":"课程学习/22讲通关Go语言/01-Go语言快速入门","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/01-Go%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"每日一课","slug":"每日一课","permalink":"https://dd-code.site/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AF%BE/"},{"name":"00-开篇词","slug":"课程学习/22讲通关Go语言/00-开篇词","permalink":"https://dd-code.site/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/22%E8%AE%B2%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80/00-%E5%BC%80%E7%AF%87%E8%AF%8D/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://dd-code.site/tags/Linux/"},{"name":"技术学习","slug":"技术学习","permalink":"https://dd-code.site/tags/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://dd-code.site/tags/Ubuntu/"},{"name":"SSDB","slug":"SSDB","permalink":"https://dd-code.site/tags/SSDB/"},{"name":"排序","slug":"排序","permalink":"https://dd-code.site/tags/%E6%8E%92%E5%BA%8F/"},{"name":"优秀网站","slug":"优秀网站","permalink":"https://dd-code.site/tags/%E4%BC%98%E7%A7%80%E7%BD%91%E7%AB%99/"}]}